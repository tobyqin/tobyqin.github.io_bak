<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MacOXS上快速启动一个ELK</title>
      <link href="posts/2020-12-16/quickly-start-an-elk-on-macoxs/"/>
      <url>posts/2020-12-16/quickly-start-an-elk-on-macoxs/</url>
      
        <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><ol><li>确保你的Docker已经安装完毕。</li><li>配置一个docker的仓库镜像，任选其一或者自行搜索。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;hub-mirror.c.163.com</span><br><span class="line">https:&#x2F;&#x2F;ngim31fm.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure><ol start="3"><li>只需要一行命令即可。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it \</span><br><span class="line">  -e MAX_MAP_COUNT=262144 --name elk sebp/elk</span><br></pre></td></tr></table></figure><h2 id="功能验证"><a href="#功能验证" class="headerlink" title="功能验证"></a>功能验证</h2><p>如果启动过程没报错，那么可以通过以下地址访问服务。</p><ol><li>ElasticSearc: <a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a></li><li>Kibana: <a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a></li></ol><p>This command publishes the following ports, which are needed for proper operation of the ELK stack:</p><ul><li>5601 (Kibana web interface).</li><li>9200 (Elasticsearch JSON interface).</li><li>5044 (Logstash Beats interface, receives logs from Beats such as Filebeat – see the <em><a href="https://elk-docker.readthedocs.io/#forwarding-logs-filebeat" target="_blank" rel="noopener">Forwarding logs with Filebeat</a></em> section).</li></ul><p>The image exposes (but does not publish):</p><ul><li>Elasticsearch’s transport interface on port 9300. Use the <code>-p 9300:9300</code> option with the <code>docker</code> command above to publish it. This transport interface is notably used by <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/index.html" target="_blank" rel="noopener">Elasticsearch’s Java client API</a>, and to run Elasticsearch in a cluster.</li><li><a href="https://www.elastic.co/guide/en/logstash/current/monitoring-logstash.html" target="_blank" rel="noopener">Logstash’s monitoring API</a> on port 9600. Use the <code>-p 9600:9600</code> option with the <code>docker</code> command above to publish it.</li></ul><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ol><li><a href="https://elk-docker.readthedocs.io/" target="_blank" rel="noopener">https://elk-docker.readthedocs.io/</a></li></ol><p>其他操作系统的相关介绍也可以在这里找到。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tech </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年，再见</title>
      <link href="posts/2020-12-04/2020-bye/"/>
      <url>posts/2020-12-04/2020-bye/</url>
      
        <content type="html"><![CDATA[<p>todo</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给MacBook Pro升级硬盘</title>
      <link href="posts/2020-11-08/upgrade-hard-drive-for-macbook-pro/"/>
      <url>posts/2020-11-08/upgrade-hard-drive-for-macbook-pro/</url>
      
        <content type="html"><![CDATA[<p>小记一下，其实过程比较简单。</p><h2 id="购买工具"><a href="#购买工具" class="headerlink" title="购买工具"></a>购买工具</h2><p>在淘宝可以买到，需要苹果后盖专门定制的五角螺丝刀和m2硬盘转接口。一般买转接口会送螺丝刀，但是需要螺丝还是要品质好一点的，我买了第一个转接口送了个山寨螺丝刀，结果只拧了5颗螺丝就滑丝了，郁闷的要死，只能重新网购第一把螺丝刀，结果还搞错了型号。</p><p><img src="https://tobyqin.github.io/images/image-20201108210010053.png" alt="image-20201108210010053"></p><p>这个是比较好一点的，有两把螺丝刀，一个开后盖，一个拧硬盘，拧硬盘的螺丝属于标准六角螺丝，一般的工具箱里有。上面这套价格不超过30元就可以买到。</p><h2 id="选购硬盘"><a href="#选购硬盘" class="headerlink" title="选购硬盘"></a>选购硬盘</h2><p>选购硬盘前还需要确认你的MacBook能不能升级硬盘，简单区分就是2018年后的新款MacBook都不能升级，硬盘已经焊死在主板上，具体支持的型号淘宝卖转接口的店铺都有列表，2015之前型号基本都支持升级，不管是MacBook还是Pro。</p><p>然后就是选购的硬盘，需要M2接口的，型号也是有讲究的，不是所有都能很好的兼容，推荐比较多的是用三星的，因为原装的就是三星的。</p><p>也可以用西数的黑盘或者蓝盘，我买了蓝盘1T SN550，速度比黑盘差一点，但是发热量小不少。M2硬盘基本上速度越快热量越高。</p><p><img src="https://tobyqin.github.io/images/image-20201108211729043.png" alt="image-20201108211729043"></p><p>东西齐了，就可以开工了。</p><h2 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h2><p>整个过程挺简单的，就是比较费时间。</p><ol><li>确保系统版本大于10.13，这样它才认识NVME的M2硬盘</li><li>用一块空的移动硬盘备份整个系统：插入硬盘，格式化，启动TimeMachine等待备份完成即可</li><li>拆开后盖，卸下老硬盘，装上新硬盘（需要第一步的工具和转接口）</li><li>顺便清理一下里面的灰，合上后盖，开始恢复系统</li><li>恢复完成后确认系统OK后再拧上螺丝钉</li></ol><p><img src="https://tobyqin.github.io/images/image-20201108212846696.png" alt="image-20201108212846696"></p><p>具体到恢复系统，大致的步骤如下：</p><ol><li>先插入有TimeMachine备份的移动硬盘</li><li>同时按住 电源+cmd+option+r开机，等待小地球出现</li><li>进入MacOS实用工具系统，有可能需要输入wifi，我的没输入</li><li>选择磁盘工具，把新硬盘格式化为APFS，分区GUID</li><li>格式完成后回到前一个页面，选择从时间机器恢复</li><li>等待恢复完成后开机就是你原来的系统，除了需要重新输入密码里面啥也不会丢</li></ol><p><img src="https://tobyqin.github.io/images/image-20201108212948441.png" alt="image-20201108212948441"></p><p>恢复需要的时间取决于你备份的大小和移动硬盘的速度，最好是USB3.0和M2的移动硬盘，我用的是普通移动硬盘恢复了200多G的数据，花了4个小时以上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个升级还是很划算的，从256G的空间一下子变成1G，再也不会因为多跑两个虚拟机而删这删那，硬盘的整体速度也有了很大提升。原装的硬盘是5年前的产品，读写和现在的真的没法比。</p><p><img src="https://tobyqin.github.io/images/image-20201108214040099.png" alt="image-20201108214040099"></p><p>关于升级的细节网上也有很多文章，可以很容易查到。或者去淘宝找店家要视频甚至远程指导，也是有可能的。</p><p>发一个链接，仅供参考：<a href="https://post.smzdm.com/p/a783vk9g/" target="_blank" rel="noopener">https://post.smzdm.com/p/a783vk9g/</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑客马拉松后记</title>
      <link href="posts/2020-09-20/hackathon-postscript/"/>
      <url>posts/2020-09-20/hackathon-postscript/</url>
      
        <content type="html"><![CDATA[<p>今年已经参加了两次黑客马拉松。</p><h2 id="黑马流程"><a href="#黑马流程" class="headerlink" title="黑马流程"></a>黑马流程</h2><p>黑马(Hackathon)的一般流程就是主办方广告预热，然后组队报名，确认报名成功后及时了解大赛注意事项和黑马主题。</p><p>一般来说，正式比赛时间只会持续1~2天，这段时间是比较高强度的脑子和体力劳动，如果小组配合不默契的话，大概率只能出个PPT，demo也只能停留在搭环境或者Hello World上。</p><h2 id="组建团队"><a href="#组建团队" class="headerlink" title="组建团队"></a>组建团队</h2><p>一个真正高效的团队不需要每个人都是MVP，而是相互之间有足够的默契和信任，每个人能在比赛过程中都为同一个目标全力以赴。</p><p>那么这里有两个问题需要明确，什么是同一个目标，怎么全力以赴。</p><h3 id="共同目标"><a href="#共同目标" class="headerlink" title="共同目标"></a>共同目标</h3><p>在比赛开始前，我们的目标是想出一个点子，作为我们参赛的项目。团队里的每个人都应该尽可能的大开脑洞，去提供建议和意见。有新意并且有价值的点子并不是那么容易得到，但其实也是可以有一些套路的。</p><ol><li>头脑风暴：一群人一起提出各种想法，比如最优价值的产品，最优的解决方案，最大的痛点，最可能实现的创意，最想做的事情等等。</li><li>奔驰思考：这是美国心理学家Robert Eberie提出一种激发创新的改进思路，用7个字母总结 - SCAMPER。<ol><li>S - Substitued，是不是有替代的方法或者产品？</li><li>C - Combined，是不是结合在一起产生新的东西？</li><li>A - Adapt，能否调整或者改造，升级优化？</li><li>M - Modify，能否修改设计，尺寸，外观等等？</li><li>P - Put to other use，能否拓展其他用途？想象一下跨界。</li><li>E - Eliminate，能否缩减，消除，简化？看看手机按键的消失。</li><li>R - Rearrange，能否重组，逆向，反套路。</li></ol></li><li>六顶帽子：从不同角度去激发创意，假设你有六顶帽子，每顶帽子颜色不一样，轮着戴到自己头上。<ol><li>白色：中立而客观，关注客观事实和数据。</li><li>绿色：创造和生命力，突破常规的可能和意见。</li><li>黄色：价值和肯定，从正面考虑问题，表达乐观。</li><li>黑色：否定和怀疑，精确批判和找出逻辑上的错误。</li><li>红色：情绪和直觉，主观表达自己的感受和看法。</li><li>蓝色：结构化思维，纵览全局，规划和管理整个思考过程，并作出结论。</li></ol></li></ol><p>纵然有很多思维方式的套路，在现实中我们更多的创意是来源于生活和工作，如果平时有思考和总结的习惯，发现不合理的设计，你的创意就不会少。</p><h3 id="全力以赴"><a href="#全力以赴" class="headerlink" title="全力以赴"></a>全力以赴</h3><p>每个人都有自己擅长的领域，一旦目标定下来后就要主动去承担一些责任。比如分配任务时主动完成自己能够完成的部分，与此同时，还需要一个人来监控和推进任务的进度，确保项目能够顺利交付。</p><p>上午完成什么，下午完成什么，晚上完成什么，设置几个里程碑，里程碑时间到达时，大家一起坐下来分享成果。如果有需要调整技术方案，就及时提出。</p><p>一天时间想把项目做得很完美基本很难，切记不要调代码调的太入迷，忘记了最初的目的和最终的结果。</p><p>最初的目的是，把我们伟大的项目表达出来。</p><p>最终的结果是，我们伟大的项目完整地表达出来了，表达的方式可能是PPT，Demo或者其他形式。</p><h2 id="享受过程"><a href="#享受过程" class="headerlink" title="享受过程"></a>享受过程</h2><p>过程能不能享受其实还跟主办方有很大关系，比如有没有舒适的场地，提供免费的餐饮，设备和设施是否完善和周全。</p><p>如果一切都OK，小组成员各就各位，就可以开心码代码了。</p><p>有一些小贴士可以罗列一下，也许对各位看官有帮助。</p><ol><li>网络一定要好，能正常访问Google和SO，不然写不出代码。</li><li>开发环境也需要提前准备好，不然临时安装git，java，node，docker七七八八的环境，大半天就过去了。</li><li>弄个无线投屏器也是非常方便的，组里任何一个人想共享屏幕都一键上屏，吃饭时还可以一起看个动画片。</li><li>任务可以用看板跟踪，免费的看板可以用Github或者Teambition，还可以投到大屏上。</li><li>尽量坐在一排，坐在对面有时讲不清楚，需要结合屏幕有效避免鸡同鸭讲。</li><li>核心接口和约定要文档化，写到README里，不然来回问很费时间。</li><li>手上的任务要尽可能早获得反馈，好的项目是逐渐调整和优化出来的，不是憋半天大招憋出来的。</li><li>不要忘了做PPT或者演示文稿，至少安排2次以上彩排，避免伟大的创意因为糟糕的演讲而腹死胎中。</li><li>最好有人能扮演程序员鼓励师，买（拿）吃的喝的。</li></ol><p><img src="https://tobyqin.github.io/images/image-20200920154539693.png" alt="image-20200920154539693"></p><p>需要不要熬夜呢？看情况吧，其实这个事情在一开始就应该商量好，临时决定熬夜的话多少让人有些不愉快。如果大家觉得夜里效率更高，那么先浪起来，半夜一起debug。</p><p>我个人觉得，半夜写代码大概率会翻车，你不想被打扰，但是都已经快交作业了，难道Deadline Driven Development的感觉真的很爽？</p><h2 id="分享成果"><a href="#分享成果" class="headerlink" title="分享成果"></a>分享成果</h2><p>除了能和志同道合的伙伴码代码，当然我们还是希望能拿奖的。分享成果最重要的三件事是：</p><ol><li>不要翻车</li><li>不要翻车</li><li>不要翻车</li></ol><p><img src="https://tobyqin.github.io/images/image-20200920153632201.png" alt="image-20200920153632201"></p><p>由此可见系统的健壮性有多么重要，QA的测试有多么重要，多测试，早联调，考虑Plan B。</p><h2 id="我们做了什么项目？"><a href="#我们做了什么项目？" class="headerlink" title="我们做了什么项目？"></a>我们做了什么项目？</h2><p>两次比赛我们做了两个比较有意思的项目。</p><h3 id="开发人员年度账单"><a href="#开发人员年度账单" class="headerlink" title="开发人员年度账单"></a>开发人员年度账单</h3><p>一年到头你写了多少bug？做了多少需求？有了年度账单，你就可以对自己的成就（发量）一目了然，还可以分享到朋友圈哦。</p><p><img src="https://tobyqin.github.io/images/image-20200920152904079.png" alt="image-20200920152904079"></p><h3 id="自动修复代码鸭"><a href="#自动修复代码鸭" class="headerlink" title="自动修复代码鸭"></a>自动修复代码鸭</h3><p>有一些显而易见的问题代码，这只鸭子来自动帮你修复，比如依赖版本升级，不合理的语法等等。虽然已经有Sonar之类的工具可以检测出类似问题，我们希望能帮助团队往前走一小步，修复掉我们100%有信心修复的问题。</p><p><img src="https://tobyqin.github.io/images/image-20200920153415416.png" alt="image-20200920153415416"></p><p>修复后自动提PR。</p><p><img src="https://tobyqin.github.io/images/image-20200920160639683.png" alt="image-20200920160639683"></p><p>本文到此，戛然而止。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hackathon </tag>
            
            <tag> tech </tag>
            
            <tag> teamwork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现场互动方案</title>
      <link href="posts/2020-05-10/on-site-interactive-solution/"/>
      <url>posts/2020-05-10/on-site-interactive-solution/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tobyqin.github.io/images/%E5%A4%A7%E5%B1%8F%E4%BA%92%E5%8A%A8%E6%96%B9%E6%A1%88.png" alt="大屏互动方案"></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享</title>
      <link href="posts/2020-05-10/share-it/"/>
      <url>posts/2020-05-10/share-it/</url>
      
        <content type="html"><![CDATA[<p>古人说授人以渔，今天说说这个渔。</p><a id="more"></a><p>当你学到新的知识时，</p><p>有可能会记笔记，写备忘，或者去实践；</p><p>或者去分享给其他人。</p><p>但当你尝试去分享一个知识时，</p><p>你会很害怕，害怕被笑话，害怕出丑。</p><p>所以，当你决定去分享一个知识时，</p><p>你会努力深入，避免自己误人子弟；</p><p>你会反复检查，避免犯了低级错误。</p><p>做笔记，有没有把握都没关系；</p><p>去实践，你也许需要50%的把握；</p><p>去分享，你应该有80%的把握，或者更多。</p><p>如果你真的想掌握它，那就去分享它。</p><p>在分享过程中，你会重新理顺思路，组织语言，甚至画图。</p><p>看，记忆又加深了。</p><p>就好比Code Review，</p><p>如果没人看，你会很洒脱很真我，</p><p>又不是不能用。</p><p>如果有人看，你还是会在大家面前努力一下， </p><p>让阳光下的代码更漂亮，</p><p>毕竟那是自家的娃。</p><p>鲁迅说，</p><p>如果你有一个主意，我有一个主意，</p><p>我们互相交互，我们就都有了两个主意。</p><p>这就是分享。</p><p>鲁迅说，我没说过。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallels Desktop里的虚拟机的Docker无网络</title>
      <link href="posts/2020-05-07/virtual-machine-docker-in-parallels-desktop-without-network/"/>
      <url>posts/2020-05-07/virtual-machine-docker-in-parallels-desktop-without-network/</url>
      
        <content type="html"><![CDATA[<p>Parallel Desktop里装了一个CentOS，CentOS里装了一个Docker，有点像套娃。</p><a id="more"></a><p>安装过程很顺利，运行第一个例子也很正常，Hello World而已。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl status docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo usermod -aG docker $(whoami)</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>我想做什么呢？我想用原生的Docker来替代MacOS上的Docker。</p><p>接下来就是映射本地文件到虚拟机里，配置共享就好了。</p><p><img src="https://tobyqin.github.io/images/image-20200507220741525.png" alt="image-20200507220741525"></p><p>然后从本地iTerm登录到虚拟机的命令行，切换到本地工作目录（被挂载到了<code>/media/psf/Home/src</code>）。这样就可以在本地获得一个原生的Linux Shell，操作的还是项目里的文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh toby@centos-linux</span><br><span class="line">cd &#x2F;media&#x2F;psf&#x2F;Home&#x2F;src&#x2F;xmind2testlink&#x2F;web</span><br><span class="line">docker build -t xmind2testlink .</span><br></pre></td></tr></table></figure><p>开始用原生的Docker打包镜像，发现基础镜像可以拉下来，但是安装Python包失败因为没有网络。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Step 1&#x2F;6 : FROM frolvlad&#x2F;alpine-python3:latest</span><br><span class="line">latest: Pulling from frolvlad&#x2F;alpine-python3</span><br><span class="line">aad63a933944: Pull complete</span><br><span class="line">071e92db37fc: Pull complete</span><br><span class="line">Digest: sha256:ee37502c33d69a230096c8abcda4f293cc398d1e08d3c3b854375b209ab85fe9</span><br><span class="line">Status: Downloaded newer image for frolvlad&#x2F;alpine-python3:latest</span><br><span class="line"> ---&gt; dd1e5224fc24</span><br><span class="line">Step 2&#x2F;6 : RUN mkdir &#x2F;app</span><br><span class="line"> ---&gt; Running in 1761ff57cd39</span><br><span class="line">Removing intermediate container 1761ff57cd39</span><br><span class="line"> ---&gt; 7b4a6a4e13c4</span><br><span class="line">Step 3&#x2F;6 : WORKDIR &#x2F;app</span><br><span class="line"> ---&gt; Running in cbf60703344e</span><br><span class="line">Removing intermediate container cbf60703344e</span><br><span class="line"> ---&gt; 24e13fb03163</span><br><span class="line">Step 4&#x2F;6 : ADD . &#x2F;app</span><br><span class="line"> ---&gt; b2b737f9503b</span><br><span class="line">Step 5&#x2F;6 : RUN pip3 install -r requirements.txt</span><br><span class="line"> ---&gt; Running in c574837c3e7f</span><br><span class="line">WARNING: Retrying (Retry(total&#x3D;4, connect&#x3D;None, read&#x3D;None, redirect&#x3D;None, status&#x3D;None)) after connection broken by &#39;NewConnectionError(&#39;&lt;pip._vendor.urllib3.connection.VerifiedHTTPSConnection object at 0x7fafbcc4b3a0&gt;: Failed to establish a new connection: [Errno -3] Try again&#39;)&#39;: &#x2F;simple&#x2F;flask&#x2F;</span><br></pre></td></tr></table></figure><p>在网上搜寻半天，各种配DNS，改防火墙，改代理，一点效果都没有。最简单的测试办法：</p><ul><li>在虚拟机里ping baidu，没问题。</li><li>在虚拟机的Docker里ping baidu，不行。</li><li>在虚拟机里ping 路由或者ip，没问题</li><li>在虚拟机里的Docker里ping 路由或者ip，不行。</li></ul><p>说明主机和虚拟机的网络桥接没问题，但是虚拟机和Docker之间的网络不通。不管切换什么网络共享方式，都行不通。</p><p><img src="https://tobyqin.github.io/images/image-20200507222519106.png" alt="image-20200507222519106"></p><p>算了，我打不过你。</p><p>我打开VMWare Workstation，把CentOS和Docker又装了一遍，上面的命令再跑一遍，行了。</p><p>MMP。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实VMWare也不是没有坑，它最坑的是需要安装VMWare Tools才能访问主机文件。官网的文档经久失修有误导性，便捷的办法就是用yum来安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y open-vm-tools</span><br><span class="line">ls /usr/bin/vmtoolsd <span class="comment"># 确认安装完毕</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>然后本地文件就可以在虚拟机里访问了，被挂载在 <code>/mnt/hgfs/tobyqin/src/</code>。</p><p>是不是我把CentOS和Docker再到PD里装一遍就好了呢？谁知道呢。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
            <tag> macosx </tag>
            
            <tag> vmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N1用Docker刷旁路由</title>
      <link href="posts/2020-05-02/n1-uses-docker-with-openwrt/"/>
      <url>posts/2020-05-02/n1-uses-docker-with-openwrt/</url>
      
        <content type="html"><![CDATA[<p>前提条件是docker已经安装，用网线连接N1。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装Portainer很有用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer:linux-arm64</span><br></pre></td></tr></table></figure><p>打开网卡混淆模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> eth0 promisc on</span><br></pre></td></tr></table></figure><p>创建docker虚拟网络，IP段需要和主路由的一致。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.254 -o parent=eth0 macnet</span><br></pre></td></tr></table></figure><p><code>192.168.1.254</code> 就是旁路由的地址，后面的登录和配置都要用这个地址。</p><h2 id="配置OpenWrt"><a href="#配置OpenWrt" class="headerlink" title="配置OpenWrt"></a>配置OpenWrt</h2><p>运行OpenWrt容器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --restart always --name=openwrt -d --network macnet --privileged unifreq/openwrt-aarch64:latest</span><br></pre></td></tr></table></figure><p>进入OpenWrt的shell，修改网络。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it openwrt bash</span><br><span class="line">vi /etc/config/network</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 192.168.1.1 改成 192.168.0.254， 配置参考如下</span></span><br><span class="line"></span><br><span class="line">config interface <span class="string">'lan'</span></span><br><span class="line">        option <span class="built_in">type</span> <span class="string">'bridge'</span></span><br><span class="line">        option ifname <span class="string">'eth0'</span></span><br><span class="line">        option proto <span class="string">'static'</span></span><br><span class="line">        option ipaddr <span class="string">'192.168.1.254'</span> <span class="comment"># 改这行</span></span><br><span class="line">        option netmask <span class="string">'255.255.255.0'</span></span><br><span class="line">        option ip6assign <span class="string">'60'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器里的shell，重启N1</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启完成后就可以在浏览器访问旁路由了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://192.168.1.254/</span><br><span class="line"><span class="comment"># 默认用户名密码 root / password</span></span><br></pre></td></tr></table></figure><p>修改网络接口，使用主路由网关和DNS。</p><p><img src="https://tobyqin.github.io/images/image-20200502154013741.png" alt="image-20200502154013741"></p><p><img src="https://tobyqin.github.io/images/image-20200502154126282.png" alt="image-20200502154126282"></p><p>关闭旁路由DHCP服务。</p><p><img src="https://tobyqin.github.io/images/image-20200502154244314.png" alt="image-20200502154244314"></p><p><img src="https://tobyqin.github.io/images/image-20200502154256056.png" alt="image-20200502154256056"></p><p>到此为止，旁路由的配置基本完毕，后面就是测试了。如果中间任何配置有问题想重来，停止并删除容器即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop openwrt</span><br><span class="line">docker rm openwrt</span><br></pre></td></tr></table></figure><h2 id="使用旁路由"><a href="#使用旁路由" class="headerlink" title="使用旁路由"></a>使用旁路由</h2><p>第一种方式，非全局模式。如果只需要某一些设备走旁路由，需要手动配置网络为旁路由地址，主路由不需要做任何配置。好处是旁路由挂了只会影响这些特定的设备，坏处就是比较麻烦。</p><p><img src="https://tobyqin.github.io/images/image-20200502162133900.png" alt="image-20200502162133900"></p><p>第二种方式，主路由全局模式。经旁路由的网关配置到主路由的DHCP即可，以后所有连接主路由的设备都会先经过旁路由。</p><p>配置方法就是进入主路由后台，将DHCP默认网关改成 192.168.1.254，DNS也改成这个地址。已经连接的设备重新连接主路由一下才会生效。</p><p><img src="https://tobyqin.github.io/images/image-20200502162550814.png" alt="image-20200502162550814"></p><p>一般用第一种方式测试一下旁路由是不是正常工作了，然后我会全局都走旁路由。我发现N1放那么几天就会死机，所有最后配置一下自动重启，比如每天重启一次。</p><h2 id="旁路由的作用"><a href="#旁路由的作用" class="headerlink" title="旁路由的作用"></a>旁路由的作用</h2><p>配置了半天，旁路由的作用都没说出来，在旁路由里世界无穷大。去广告什么的都不说了，还有很多只可以意会不可言传的功能。</p><p><img src="https://tobyqin.github.io/images/image-20200502163251438.png" alt="image-20200502163251438"></p><p><img src="https://tobyqin.github.io/images/image-20200502163305280.png" alt="image-20200502163305280"></p><p><img src="https://tobyqin.github.io/images/image-20200502163321286.png" alt="image-20200502163321286"></p><p>参考文章：</p><ul><li><a href="https://instar.me/archives/e806f8ac.html" target="_blank" rel="noopener">https://instar.me/archives/e806f8ac.html</a></li><li><a href="https://post.smzdm.com/p/akm7q5xk/" target="_blank" rel="noopener">https://post.smzdm.com/p/akm7q5xk/</a></li><li><a href="http://hostloc.com/thread-532624-1-1.html" target="_blank" rel="noopener">http://hostloc.com/thread-532624-1-1.html</a></li><li><a href="https://leeyr.com/326.html" target="_blank" rel="noopener">https://leeyr.com/326.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> docker </tag>
            
            <tag> n1 </tag>
            
            <tag> route </tag>
            
            <tag> armbian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署一个私有的在线绘图服务</title>
      <link href="posts/2020-04-26/deploy-a-private-online-drawing-service/"/>
      <url>posts/2020-04-26/deploy-a-private-online-drawing-service/</url>
      
        <content type="html"><![CDATA[<p>现在很多服务都已经云端化了，浏览器早已不是只用来浏览信息的浏览器了。</p><a id="more"></a><h2 id="在线绘图"><a href="#在线绘图" class="headerlink" title="在线绘图"></a>在线绘图</h2><p>国内最常用的就是 ProcessOn 了，功能很全，就是免费额度有点少。</p><p><img src="https://tobyqin.github.io/images/image-20200426214245160.png" alt="image-20200426214245160"></p><p>国外最知名的就是 <a href="https://draw.io" target="_blank" rel="noopener">Draw.io</a> 了，基本上就是免费的，常常集成在各种服务里。就是速度有点慢，不，是非常慢。</p><p><img src="https://tobyqin.github.io/images/image-20200426214432654.png" alt="image-20200426214432654"></p><p>Draw.io 现在改名了，叫 diagrams.net。最关键的是，它还是开源的！</p><h2 id="部署一个-Draw-io"><a href="#部署一个-Draw-io" class="headerlink" title="部署一个 Draw.io"></a>部署一个 Draw.io</h2><p>Draw.io 是基于<a href="https://github.com/jgraph/mxgraph" target="_blank" rel="noopener">mxGraph library</a>构建的，后端用 Java 实现了简单的文件导出和处理功能，画图的功能都是通过 JavaScript 在浏览器的，所以是完全可以用静态页面的方式来托管一个不需要文件导出和鉴权的绘图站点。</p><p>欲知详情请移步至该项目：</p><ul><li><a href="https://github.com/jgraph/drawio" target="_blank" rel="noopener">https://github.com/jgraph/drawio</a></li></ul><p>要完整部署该项目需要用 ant 来编译 war，并用 tomcat 托管。但是，我不想用 ant 去编译也不想和 Tom 猫发生什么关系，所以我要对这个项目的功能进行阉割。</p><ul><li>去除所有国外的在线服务，比如 Google Drive，OneDrive，Github 等等</li><li>避免跳转到 Draw.io 官网</li><li>去除后端服务，只要能在浏览器绘图并缓存，能保存为本地文件</li></ul><p>来来来，folk 一下这个项目开干，新项目地址：</p><ul><li><a href="https://github.com/tobyqin/drawio-local" target="_blank" rel="noopener">https://github.com/tobyqin/drawio-local</a></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步，干掉Java，只保留Web应用</span></span><br><span class="line">mv -r src/main/webapp /temp/webapp</span><br><span class="line">rm -rf *</span><br><span class="line">mv -r /tmp/webapp .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步，去掉在线服务</span></span><br><span class="line">code js/PreConfig.js</span><br><span class="line"><span class="comment"># 配置 local='1'</span></span><br><span class="line"><span class="comment"># 参考 https://desk.draw.io/support/solutions/articles/16000042546-what-url-parameters-are-supported-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步，修改错误的资源引用，用Chrome的开发者工具</span></span><br><span class="line"><span class="comment"># 第四步，加一些黑科技到 index.html 来hack外部跳转，balabala</span></span><br></pre></td></tr></table></figure><p>完事具备，用一行代码在本地托管：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure><p>OK 啦，干净清爽的感觉就是那么好。</p><p><img src="https://tobyqin.github.io/images/demo.jpg" alt="demo"></p><p>改一下 <code>README.md</code> 就推送了吧。感觉我只需要花几分钟，其实我调试了几小时，开发为什么总估不准时间呢？奇怪。</p><h2 id="部署到-Docker"><a href="#部署到-Docker" class="headerlink" title="部署到 Docker"></a>部署到 Docker</h2><p>没有容器化的服务是没有灵魂的服务，那么我们就给它加点灵魂。加灵魂需要一个 <code>Dockerfile</code>，这样写：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> frolvlad/alpine-python3:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install flask</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /app/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> python3 app.py</span></span><br></pre></td></tr></table></figure><p>这个灵魂是有讲究的，为什么这么说呢？</p><ol><li>用的是 apline 的基础镜像，这个是开源界最常用的基础镜像，因为它及其的小，一般只有几 MB 或者几十 MB。对应的 apline 镜像还有 node，java，go 版的，应有尽有。</li><li>先安装 flask 后 copy 应用，因为 flask 安装后这个 layer 就不变了，但是 app 每次打包都会不一样。</li></ol><p>为啥要加个 flask 啊？因为我想在它访问后端报错时可以更友好一点，人性化和用户体验，Understand？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route('/not-support', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_support</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Sorry, this action is not supported."</span></span><br></pre></td></tr></table></figure><p>好啦，打包镜像走起。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t tobyqin/drawio-local:latest .</span><br></pre></td></tr></table></figure><p>让这个灵魂跑起来。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -p 5000:5000  tobyqin/drawio-local</span><br></pre></td></tr></table></figure><p>访问本地 5000 端口，一点毛病都没有，注意 <code>--rm</code> 在调试时很有用，它可以帮你自动清理退出的容器。</p><p>让我们来把这个灵魂发布到全世界。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login</span><br><span class="line">docker push tobyqin/drawio-local</span><br></pre></td></tr></table></figure><p>咦？这个灵魂好像有点重啊，完全推不动嘛。用 Portainer 查看一下里面到底有什么东西。</p><p><img src="https://tobyqin.github.io/images/image-20200426222414429.png" alt="layer"></p><p>基础镜像层总共才 4M，应用层居然接近 100M，要给灵魂减减肥了。在根目录加个 <code>.dockerignore</code> 文件，把不想打包的文件统统写在里面。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">.DS_Store</span><br><span class="line">.vscode</span><br><span class="line">*.md</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>321 再来一遍灵魂序曲，嗯，有内味了。</p><h2 id="拿来主义"><a href="#拿来主义" class="headerlink" title="拿来主义"></a>拿来主义</h2><p>我想你是不愿意再踩一遍我的坑了，反正这个东西做一遍就行了，拿去用吧。</p><h3 id="1-静态托管"><a href="#1-静态托管" class="headerlink" title="1. 静态托管"></a>1. 静态托管</h3><p>直接到<a href="https://github.com/tobyqin/drawio-local" target="_blank" rel="noopener">Github</a> 下载 zip 解压后丢到 nginx 或者 iis 即可，顺手给项目加个星呗。</p><h3 id="2-Docker-部署"><a href="#2-Docker-部署" class="headerlink" title="2. Docker 部署"></a>2. Docker 部署</h3><p>一行命令即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name=<span class="string">"drawio-local"</span> --restart always -p 5000:5000  tobyqin/drawio-local</span><br></pre></td></tr></table></figure><h3 id="3-薅我羊毛"><a href="#3-薅我羊毛" class="headerlink" title="3. 薅我羊毛"></a>3. 薅我羊毛</h3><p>这个服务我已经部署到了我的主机，免费用，随便用，但不保证它的速度和生命延续。</p><ul><li><a href="https://draw.pytips.cn" target="_blank" rel="noopener">https://draw.pytips.cn</a></li></ul><p>就这样，Peace。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
            <tag> docker </tag>
            
            <tag> draw.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行配置备忘</title>
      <link href="posts/2020-04-04/command-line-configuration-memo/"/>
      <url>posts/2020-04-04/command-line-configuration-memo/</url>
      
        <content type="html"><![CDATA[<p>换到新的机器，命令行配置少不了。</p><a id="more"></a><h2 id="zsh-amp-oh-my-zsh"><a href="#zsh-amp-oh-my-zsh" class="headerlink" title="zsh &amp; oh-my-zsh"></a>zsh &amp; oh-my-zsh</h2><p>大概是需要代理加速的，下面是简要步骤，适用于MacOS或者Linux平台。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装zsh，各平台命令不一样，但差不多</span></span><br><span class="line">yum install zsh -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查已经安装好的shell</span></span><br><span class="line">cat /etc/shells</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式更换当前用户的shell，输入上面看到的 /bin/zsh</span></span><br><span class="line">chsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 免交互直接更改root的shell</span></span><br><span class="line">chsh -s /bin/zsh root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装oh-my-zsh</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是我必修改的配置，主题用ys，在配置文件的开头部分</span></span><br><span class="line">ZSH_THEME=<span class="string">"ys"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用的插件，在配置文件的中间位置，autojump, zsh-autosuggestions 非常好用</span></span><br><span class="line">plugins=(git pip python autojump zsh-autosuggestions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件末尾补充几部分内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 兼容bash的配置文件，忽略导入失败的错误</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc &amp;&gt;/dev/null</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile  &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路径到PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/usr/local/sbin:<span class="variable">$PATH</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用的别名</span></span><br><span class="line"><span class="built_in">alias</span> s=systemctl</span><br><span class="line"><span class="built_in">alias</span> k=kubectl</span><br><span class="line"><span class="built_in">alias</span> n=nginx</span><br><span class="line"><span class="built_in">alias</span> vi=vim</span><br><span class="line"><span class="built_in">alias</span> cls=clear</span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -a'</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">"grep --color=auto"</span></span><br></pre></td></tr></table></figure><h2 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h2><p>autojump是一个很方便的让你跳转目录的命令行工具。需要额外安装，在MacOSX可以用brew安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install autojump</span><br></pre></td></tr></table></figure><p>在其他Linux平台需要从源码安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/wting/autojump.git</span><br><span class="line"><span class="built_in">cd</span> autojump</span><br><span class="line">./install.py</span><br><span class="line"><span class="comment"># or ./uninstall.py</span></span><br></pre></td></tr></table></figure><p>装完之后注意看安装成功后提示，你需要把这段内容加到 <code>.bash_profile</code>里。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ -s &#x2F;root&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; source &#x2F;root&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh</span><br></pre></td></tr></table></figure><p>然后重启命令行就可以开心的autojump了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j toby  # cd 到带有toby的最近目录</span><br><span class="line">j music # cd 到有可能是music的目录</span><br><span class="line">j doc   # cd 到有可能是doc的目录</span><br></pre></td></tr></table></figure><p>autojump非常智能，你只要给少量关键字就可以cd到你想要到的目录。</p><h2 id="autosuggestions"><a href="#autosuggestions" class="headerlink" title="autosuggestions"></a>autosuggestions</h2><p>有了oh-my-zsh 大部分命令是可以通过TAB补全的，autosuggestion可以锦上添花。但这玩意还是需要额外安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>然后在zsh的配置文件里启用即可，参考上文。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins&#x3D;(zsh-autosuggestions)</span><br></pre></td></tr></table></figure><p>成功启用后的效果如下。</p><p><img src="https://tobyqin.github.io/images/image-20200404202408289.png" alt="image-20200404202408289"></p><p>灰色部分是自动提示的，主要是根据输入历史和自动完成的可能性，按右方向键就可以直接使用提示的完整命令，爽歪歪。</p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>命令行的别名可以极大提高效率。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls --color=auto &amp;&gt;/dev/null &amp;&amp; <span class="built_in">alias</span> ls=<span class="string">'ls --color=auto'</span> &amp;&amp; <span class="built_in">eval</span> <span class="string">"<span class="variable">$(dircolors)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> g=<span class="string">'git'</span></span><br><span class="line"><span class="built_in">alias</span> k=<span class="string">'kubectl'</span></span><br><span class="line"><span class="built_in">alias</span> n=<span class="string">'nginx'</span></span><br><span class="line"><span class="built_in">alias</span> h=<span class="string">'history'</span></span><br><span class="line"><span class="built_in">alias</span> s=<span class="string">'systemctl'</span></span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> svi=<span class="string">'sudo vim'</span></span><br><span class="line"><span class="built_in">alias</span> c=<span class="string">'clear'</span></span><br><span class="line"><span class="built_in">alias</span> cls=<span class="string">'clear'</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">'ls -lah'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ll -la'</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">"grep --color=auto"</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">'egrep --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">'fgrep --color=auto'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bind file with default actions</span></span><br><span class="line"><span class="built_in">alias</span> -s html=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> -s rb=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> -s py=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> -s js=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> -s c=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> -s java=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> -s txt=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> -s gz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> -s tgz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> -s zip=<span class="string">'unzip'</span></span><br><span class="line"><span class="built_in">alias</span> -s bz2=<span class="string">'tar -xjvf'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> cdback=<span class="string">'cd -'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="string">'..'</span>=<span class="string">'cd ..'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="string">'...'</span>=<span class="string">'../..'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="string">'....'</span>=<span class="string">'../../..'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="string">'.....'</span>=<span class="string">'../../../..'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="string">'......'</span>=<span class="string">'../../../../..'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> df=<span class="string">'df -h'</span></span><br><span class="line"><span class="built_in">alias</span> du=<span class="string">'du -h'</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">'cp -v'</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">'mv -v'</span></span><br><span class="line"><span class="built_in">alias</span> mkdir=<span class="string">'mkdir -pv'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">which</span>=<span class="string">'which -a'</span></span><br><span class="line"><span class="built_in">alias</span> path=<span class="string">'echo -e $&#123;PATH//:/\\n&#125;'</span></span><br><span class="line"><span class="built_in">alias</span> ping=<span class="string">'ping -c 5'</span></span><br><span class="line"><span class="built_in">alias</span> ports=<span class="string">'netstat -tulanp'</span></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">'rm -I --preserve-root'</span></span><br><span class="line"><span class="built_in">alias</span> chown=<span class="string">'chown -v --preserve-root'</span></span><br><span class="line"><span class="built_in">alias</span> chmod=<span class="string">'chmod -v --preserve-root'</span></span><br><span class="line"><span class="built_in">alias</span> chgrp=<span class="string">'chgrp --preserve-root'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> virc=<span class="string">'vi ~/.vimrc'</span></span><br><span class="line"><span class="built_in">alias</span> barc=<span class="string">'vi ~/.bashrc &amp;&amp; source ~/.bashrc'</span></span><br><span class="line"><span class="built_in">alias</span> baprofile=<span class="string">'vi ~/.bash_profile &amp;&amp; source ~/.bash_profile'</span></span><br><span class="line"><span class="built_in">alias</span> bareload=<span class="string">'source ~/.bash_profile &amp;&gt;/dev/null || source ~/.bashrc  &amp;&gt;/dev/null'</span></span><br><span class="line"><span class="built_in">alias</span> zshrc=<span class="string">'vi ~/.zshrc &amp;&amp; source ~/.zshrc'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> untar=<span class="string">'tar -zxvf'</span></span><br><span class="line"><span class="built_in">alias</span> www=<span class="string">'python2 -m SimpleHTTPServer 8000'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> ngx=<span class="string">'nginx'</span></span><br><span class="line"><span class="built_in">alias</span> ngxreload=<span class="string">'sudo ng -s reload'</span></span><br><span class="line"><span class="built_in">alias</span> ngxtest=<span class="string">'sudo ng -t'</span></span><br><span class="line"><span class="built_in">alias</span> ngxconf=<span class="string">'sudo vi /etc/nginx/conf/nginx.conf &amp;&amp; ngxtest'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">help</span>=<span class="string">'tldr'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> alias </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS安装最新版Nodejs</title>
      <link href="posts/2020-03-29/centos-installs-the-latest-version-of-nodejs/"/>
      <url>posts/2020-03-29/centos-installs-the-latest-version-of-nodejs/</url>
      
        <content type="html"><![CDATA[<p>添加 Nodejs 到 Yum Repo</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++ make</span><br><span class="line">curl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_13.x | sudo -E bash -</span><br></pre></td></tr></table></figure><p>如果要稳定版就改成这样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y gcc-c++ make</span><br><span class="line">curl -sL https:&#x2F;&#x2F;rpm.nodesource.com&#x2F;setup_12.x | sudo -E bash -</span><br></pre></td></tr></table></figure><p>然后用yum安装即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install nodejs -y</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Docker部署NextCloud到N1</title>
      <link href="posts/2020-03-28/deploy-nextcloud-to-n1-with-docker/"/>
      <url>posts/2020-03-28/deploy-nextcloud-to-n1-with-docker/</url>
      
        <content type="html"><![CDATA[<p>只需要一个命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8888:80  --name nextcloud  -v /data/nextcloud/:/var/www/html/ --restart=always   --privileged=<span class="literal">true</span>  arm64v8/nextcloud</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果是部署到U盘，可以这样。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8888:80  --name nextcloud  -v /media/udisk/:/var/www/html/ --restart=always   --privileged=<span class="literal">true</span>  arm64v8/nextcloud</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> n1 </tag>
            
            <tag> nextcloud </tag>
            
            <tag> nas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx常用命令</title>
      <link href="posts/2020-03-28/nginx-commonly-used-commands/"/>
      <url>posts/2020-03-28/nginx-commonly-used-commands/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -t           <span class="comment">#测试配置文件</span></span><br><span class="line">nginx              <span class="comment">#启动命令</span></span><br><span class="line">nginx -s stop      <span class="comment">#强制停止Nginx服务</span></span><br><span class="line">nginx -s quit      <span class="comment">#处理完请求后再停止服务</span></span><br><span class="line">nginx -s reload    <span class="comment">#重启命令</span></span><br><span class="line">ps -ef |grep nginx <span class="comment">#查看进程命令</span></span><br><span class="line">nginx -v           <span class="comment">#查看Nginx的版本号</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerShell和Cmd和谐共处</title>
      <link href="posts/2020-03-19/powershell-and-cmd-live-in-harmony/"/>
      <url>posts/2020-03-19/powershell-and-cmd-live-in-harmony/</url>
      
        <content type="html"><![CDATA[<p>PowerShell真的很强大啊，但是双击运行不OK啊。批处理好方便啊，可是写一个<code>if</code>要半天啊。他俩就不能既方便又强大吗？</p><a id="more"></a><h2 id="在批处理嵌入PowerShell"><a href="#在批处理嵌入PowerShell" class="headerlink" title="在批处理嵌入PowerShell"></a>在批处理嵌入PowerShell</h2><p>这是可以的，<a href="https://stackoverflow.com/questions/2609985/how-to-run-a-powershell-script-within-a-windows-batch-file" target="_blank" rel="noopener">Stack Overflow</a>有帖子，这个操作可谓风骚非常。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@findstr /v <span class="string">"^@f.*&amp;"</span> <span class="string">"%~f0"</span> | powershell -&amp; goto:eof</span><br><span class="line"><span class="built_in">Write-Output</span> <span class="string">"Hello World"</span> </span><br><span class="line"><span class="built_in">Write-Output</span> <span class="string">"Hello some@com &amp; again"</span></span><br></pre></td></tr></table></figure><p>文件存成 <code>.bat</code> 或者 <code>.cmd</code>，双击就能运行。唯一的缺点是这个后缀的文件IDE或者编辑器都当成了批处理，没法用ISE或者VSCODE去编写和调试代码，只能先改成<code>ps1</code>调试好了再改成批处理。</p><h2 id="用批处理调用PowerShell"><a href="#用批处理调用PowerShell" class="headerlink" title="用批处理调用PowerShell"></a>用批处理调用PowerShell</h2><p>你还可以建两个文件，像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-script.cmd</span><br><span class="line">my-script.ps1</span><br></pre></td></tr></table></figure><p>你的PowerShell想怎么写就怎么写，但是批处理要这么写。</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">ECHO</span> OFF</span><br><span class="line"><span class="built_in">SET</span> PowerShellScriptPath=%~dpn0.ps1</span><br><span class="line">PowerShell -NoProfile -ExecutionPolicy Bypass -Command "&amp; '<span class="variable">%PowerShellScriptPath%</span>'";</span><br></pre></td></tr></table></figure><p>而且名字还必须和PowerShell脚本的名字一致，如熊大和熊二的关系一般。</p><h3 id="调用说明"><a href="#调用说明" class="headerlink" title="调用说明"></a>调用说明</h3><p>如果你希望运行PowerShell带参数，第三行就这样写：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PowerShell -NoProfile -ExecutionPolicy Bypass -Command <span class="string">"&amp; '%PowerShellScriptPath%' 'First Param Value' 'Second Param Value'"</span>;</span><br></pre></td></tr></table></figure><p>带命名参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PowerShell -NoProfile -ExecutionPolicy Bypass -Command <span class="string">"&amp; '%PowerShellScriptPath%' -Param1Name 'Param 1 Value' -Param2Name 'Param 2 Value'"</span></span><br></pre></td></tr></table></figure><p>以管理员身份运行：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PowerShell -NoProfile -ExecutionPolicy Bypass -Command <span class="string">"&amp; &#123;Start-Process PowerShell -ArgumentList '-NoProfile -ExecutionPolicy Bypass -File "</span><span class="string">"%PowerShellScriptPath%"</span><span class="string">"' -Verb RunAs&#125;"</span>;</span><br></pre></td></tr></table></figure><p>以管理员身份运行还带参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PowerShell -NoProfile -ExecutionPolicy Bypass -Command <span class="string">"&amp; &#123;Start-Process PowerShell -ArgumentList '-NoProfile -ExecutionPolicy Bypass -File "</span><span class="string">""</span><span class="string">"%PowerShellScriptPath%"</span><span class="string">""</span><span class="string">" "</span><span class="string">""</span><span class="string">"First Param Value"</span><span class="string">""</span><span class="string">" "</span><span class="string">""</span><span class="string">"Second Param Value"</span><span class="string">""</span><span class="string">" ' -Verb RunAs&#125;"</span></span><br></pre></td></tr></table></figure><p>以管理员身份运行还带命名参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PowerShell -NoProfile -ExecutionPolicy Bypass -Command <span class="string">"&amp; &#123;Start-Process PowerShell -ArgumentList '-NoProfile -ExecutionPolicy Bypass -File "</span><span class="string">""</span><span class="string">"%PowerShellScriptPath%"</span><span class="string">""</span><span class="string">" -Param1Name "</span><span class="string">""</span><span class="string">"Param 1 Value"</span><span class="string">""</span><span class="string">" -Param2Name "</span><span class="string">""</span><span class="string">"Param 2 value"</span><span class="string">""</span><span class="string">" ' -Verb RunAs&#125;"</span>;</span><br></pre></td></tr></table></figure><h2 id="远程运行PowerShell"><a href="#远程运行PowerShell" class="headerlink" title="远程运行PowerShell"></a>远程运行PowerShell</h2><p>这里说的是运行某台服务器的上的PowerShell，管理员用的比较多，对运程机器也要提前配置好让它能接受远程命令。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-ComputerName</span> Server01, Server02 <span class="literal">-FilePath</span> c:\Scripts\DiskCollect.ps1</span><br></pre></td></tr></table></figure><p>配置相对复杂，具体请查阅文档。</p><h2 id="运行远程的PowerShell"><a href="#运行远程的PowerShell" class="headerlink" title="运行远程的PowerShell"></a>运行远程的PowerShell</h2><p>这里说的去执行一个远程已经存在的脚本，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; \\server\path\to\your\scriptmcscript.ps1</span><br></pre></td></tr></table></figure><p>不不不，我要说的远程脚本是在云上，比如 <a href="http://server/setup.ps1，没问题。" target="_blank" rel="noopener">http://server/setup.ps1，没问题。</a></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 PowerShell 中执行</span></span><br><span class="line">iex ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">'https://chocolatey.org/install.ps1'</span>))</span><br></pre></td></tr></table></figure><p>但是你需要让别人打开PowerShell命令行后粘贴才行。</p><p>双击运行行不行？行，大兄弟。把下面的内容保存成批处理文件，让他双击，狠狠地双击吧。</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">PowerShell -NoProfile -ExecutionPolicy Bypass -Command "iex ((New-Object System.<span class="built_in">Net</span>.WebClient).DownloadString('http://server/setup.ps1'))";</span><br></pre></td></tr></table></figure><p>不要小看上面的小技巧，PowerShell可以做出你难以想象的事情，PowerShell是高效码农的必备，是黑客渗透Windows的首选。</p><p>这个双击，可以是来自天堂的Hello World，也可以是来自地狱的Goodbye Boy. </p><p>安全和便利从来都是背道而驰的，这个尺度需要自己把握。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> powershell </tag>
            
            <tag> batch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在ParallelDesktop虚拟机中访问Mac的IP</title>
      <link href="posts/2020-03-14/access-mac-s-ip-in-paralleldesktop-virtual-machine/"/>
      <url>posts/2020-03-14/access-mac-s-ip-in-paralleldesktop-virtual-machine/</url>
      
        <content type="html"><![CDATA[<p>假设在Mac主机开了一个http的服务。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python -m http.server 8000</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http:&#x2F;&#x2F;0.0.0.0:8000&#x2F;) ...</span><br></pre></td></tr></table></figure><p>我们可以找到PD的网络设置，看到DHCP的地址。</p><p><img src="https://tobyqin.github.io/images/image-20200314154520597.png" alt="image-20200314154520597"></p><p>这里是 10.211.55.1，那么宿主机就是2号位。</p><p><img src="https://tobyqin.github.io/images/image-20200314154808932.png" alt="image-20200314154808932"></p><p>当然，如果你的机器联网了，也可以用路由器分配的地址。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ifconfig | grep 192</span><br><span class="line">trueinet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20200314154939087.png" alt="image-20200314154939087"></p><p>最后，如果你知道你的Mac的机器名是什么（hostname），也可以用机器名来访问。</p><p><img src="https://tobyqin.github.io/images/image-20200314155350759.png" alt="image-20200314155350759"></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> paralledesktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在N1上快速部署一个博客</title>
      <link href="posts/2020-03-09/quickly-deploy-a-blog-on-n1/"/>
      <url>posts/2020-03-09/quickly-deploy-a-blog-on-n1/</url>
      
        <content type="html"><![CDATA[<p>前提是你已经<a href="https://tobyqin.github.io/posts/2020-02-09/feixun-n1s-road-of-twists-and-turns/" target="_blank" rel="noopener">刷了armbian</a>。</p><a id="more"></a><p>然后你还需要docker，一个命令即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.docker.com | sh</span><br></pre></td></tr></table></figure><p>接下来一句话就可以搞定typecho。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name&#x3D;typecho \</span><br><span class="line">--restart always \</span><br><span class="line">--mount type&#x3D;tmpfs,destination&#x3D;&#x2F;tmp \</span><br><span class="line">-v &#x2F;data&#x2F;typecho:&#x2F;data \</span><br><span class="line">-e PHP_TZ&#x3D;Asia&#x2F;Shanghai \</span><br><span class="line">-e PHP_MAX_EXECUTION_TIME&#x3D;600 \</span><br><span class="line">-p 90:80 \</span><br><span class="line">80x86&#x2F;typecho:latest</span><br></pre></td></tr></table></figure><p>docker命令里<strong>冒号左边</strong>是本机的路径或者端口，根据情况调整。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的压缩和解压</title>
      <link href="posts/2020-03-08/compression-and-decompression-for-linux/"/>
      <url>posts/2020-03-08/compression-and-decompression-for-linux/</url>
      
        <content type="html"><![CDATA[<p>最常用的是 zip 和 tar 命令。</p><a id="more"></a><h2 id="1-zip命令"><a href="#1-zip命令" class="headerlink" title="1.zip命令"></a>1.zip命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将指定目录压缩成zip文件</span></span><br><span class="line">zip -r compressed.zip /path/to/dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩文件夹，但排除某些文件</span></span><br><span class="line">zip -r compressed.zip path/to/dir -x path/to/exclude</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多个目录压缩成zip</span></span><br><span class="line">zip -r compressed.zip /path/to/dir1 /path/to/dir2 /path/to/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩加密码</span></span><br><span class="line">zip -e -r compressed.zip path/to/dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件到已经存在的zip</span></span><br><span class="line">zip compressed.zip path/to/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除zip里的文件</span></span><br><span class="line">zip -d compressed.zip <span class="string">"foo/*.tmp"</span></span><br></pre></td></tr></table></figure><p>zip可以将当前文件夹压缩至当前文件夹，比如 /home/toby =&gt; /home/toby/toby.zip</p><h2 id="2-unzip命令"><a href="#2-unzip命令" class="headerlink" title="2.unzip命令"></a>2.unzip命令</h2><p>与zip命令相反，这是解压命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压文件，用空格来接受多个文件</span></span><br><span class="line">unzip file(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压文件到指定目录</span></span><br><span class="line">unzip compressed_file(s) -d /path/to/put/extracted_file(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示zip里的文件，不解压</span></span><br><span class="line">unzip -l file.zip</span><br></pre></td></tr></table></figure><h2 id="3-tar命令"><a href="#3-tar命令" class="headerlink" title="3.tar命令"></a>3.tar命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只是打包成 tar</span></span><br><span class="line">tar cf target.tar file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包并使用gzip压缩</span></span><br><span class="line">tar czf target.tar.gz file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压tar到当前目录</span></span><br><span class="line">tar xf source.tar[.gz|.bz2|.xz]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压tar到指定目录</span></span><br><span class="line">tar xf source.tar -C directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示tar里的文件，不解压</span></span><br><span class="line">tar tvf source.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压tar里符合规则的文件</span></span><br><span class="line">tar xf source.tar --wildcards <span class="string">"*.html"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux，zip，unzip，tar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux里的计划任务</title>
      <link href="posts/2020-03-07/scheduled-tasks-in-linux/"/>
      <url>posts/2020-03-07/scheduled-tasks-in-linux/</url>
      
        <content type="html"><![CDATA[<p>cron 是 Linux 内置的计划任务程序。</p><p>crontab 是 cron 定期执行任务所需的列表文件，注意通过 crontab 命令来修改。</p><p>anacron 可以看做是 cron 的补充程序，可以每月，每周，每天执行某些任务。</p><a id="more"></a><h2 id="cron-服务"><a href="#cron-服务" class="headerlink" title="cron 服务"></a>cron 服务</h2><p>cron服务的守护进程是crond。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：service crond start</span><br><span class="line">停止：service crond stop</span><br><span class="line">重启：service crond restart</span><br><span class="line">查看状态：service crond status</span><br><span class="line">重新载入配置：service crond reload</span><br></pre></td></tr></table></figure><p>在 CentOS7 也可以用 <code>systemctl start crond</code> 来管理服务。默认情况下 cron 服务应该是开机自动运行的，如果没有可以 enable 一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable crond</span><br></pre></td></tr></table></figure><h2 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab -u     <span class="comment"># 设定某个用户的cron服务，一般root用户在执行这个命令的时候需要此参数</span></span><br><span class="line">crontab -l     <span class="comment"># 列出某个用户cron服务的详细内容</span></span><br><span class="line">crontab -r     <span class="comment"># 删除某个用户的cron服务，这个命令最没用还容易按错！！！</span></span><br><span class="line">crontab -e     <span class="comment"># 编辑某个用户的cron服务 </span></span><br><span class="line">crontab &lt;file&gt; <span class="comment"># 将 &lt;file&gt; 恢复至crontab</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看自己的cron设置</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="comment"># 编辑自己的cron设置</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># root想删除toby的cron设置</span></span><br><span class="line">crontab -u toby -r</span><br></pre></td></tr></table></figure><p>你也可以直接修改 crontab 的配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统配置文件：</span><br><span class="line">&#x2F;etc&#x2F;crontab</span><br><span class="line">系统级任务，一般为空，如果anacron不存在有可能会把anacron 类似的配置写到这里</span><br><span class="line"></span><br><span class="line">用户配置文件：</span><br><span class="line">&#x2F;var&#x2F;spool&#x2F;cron&#x2F;[user]</span><br><span class="line">比如 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;toby</span><br></pre></td></tr></table></figure><p>crontab文件的内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo task</span></span><br><span class="line">01 * * * * root <span class="built_in">echo</span> hello</span><br></pre></td></tr></table></figure><p>前半部分用于声明环境变量，这四个变量是固定的，但值可以改。后半部分就是具体的任务，建议任务前用#号加以注释，方便以后管理。关于cron语法，可以参考其他文档或自行搜索：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br></pre></td></tr></table></figure><p>crontab 配置修改后不用重启服务，Linux会自动加载最新的改动。每次任务执行完毕后会将执行日志写到 <code>/var/log/cron</code>，可以通过 tail 命令排错。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>要经常备份 crontab 文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l &gt; ~&#x2F;mycrontab</span><br></pre></td></tr></table></figure><p>恢复你的备份：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab ~&#x2F;mycrontab</span><br></pre></td></tr></table></figure><p>环境变量可以在具体命令前加载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 * * * * . &#x2F;etc&#x2F;profile;&#x2F;bin&#x2F;sh &#x2F;var&#x2F;my.sh</span><br></pre></td></tr></table></figure><p>定时重启的任务需要root权限：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 * * * root &#x2F;sbin&#x2F;reboot</span><br></pre></td></tr></table></figure><h2 id="anacron-命令"><a href="#anacron-命令" class="headerlink" title="anacron 命令"></a>anacron 命令</h2><p>anacron 算是 crontab 补充。假如你的服务器因为某些原因关机了，crontab 里配置的任务就错过了，例如你一个月备份一次数据库，刚好要备份那天服务器宕机了，当你重启后这个任务又要重新计算了，因为错过了备份时间。</p><p>但如果你把备份任务写到 anacron 里，服务器重启后依然会去执行你的任务。anacron 会通过计算记录文件的时间戳来判断上次任务是否已经执行，anacron 没那么灵活，只能按天，周，月配置任务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anacron 配置文件： </span><br><span class="line">&#x2F;etc&#x2F;anacrontab</span><br></pre></td></tr></table></figure><p>cat 一下这个配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;sh</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line"># the maximal random delay added to the base delay of the jobs</span><br><span class="line">RANDOM_DELAY&#x3D;45</span><br><span class="line"># the jobs will be started during the following hours only</span><br><span class="line">START_HOURS_RANGE&#x3D;3-22</span><br><span class="line"></span><br><span class="line">#period in days   delay in minutes   job-identifier   command</span><br><span class="line">15cron.dailynice run-parts &#x2F;etc&#x2F;cron.daily</span><br><span class="line">725cron.weeklynice run-parts &#x2F;etc&#x2F;cron.weekly</span><br><span class="line">@monthly 45cron.monthlynice run-parts &#x2F;etc&#x2F;cron.monthly</span><br></pre></td></tr></table></figure><p>可以看到所有放入 <code>/etc/cron.{daily，weekly，monthly}</code> 目录中的脚本都会在指定时间执行，而且不用担心服务器万一关机的情况。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux，cron，crontab，anacron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nano的简单用法</title>
      <link href="posts/2020-03-07/simple-usage-of-nano/"/>
      <url>posts/2020-03-07/simple-usage-of-nano/</url>
      
        <content type="html"><![CDATA[<p>不小心进了nano，都不知道怎么退出来。</p><a id="more"></a><p><img src="https://tobyqin.github.io/images/image-20200307150218747.png" alt="image-20200307150218747"></p><p>虽然画面上有快捷键，按完之后还是一脸懵逼。<code>^</code>是<code>Ctrl</code>键的缩写。</p><p><code>^O</code>是写入，按完之后就这样了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File Name to Write: test</span><br><span class="line">^G Get Help        ^T To Files        M-M Mac Format     M-P Prepend</span><br><span class="line">^C Cancel          M-D DOS Format     M-A Append         M-B Backup File</span><br></pre></td></tr></table></figure><p>其实离成功就差一个回车，当然在回车前你还可以修改文件名。界面里的<code>M</code>是什么呢？后来查了半天发现<code>M</code>是<code>Modifier</code>键，通常指的是<code>Alt</code>键，Mac上是<code>Option</code>键。</p><p><code>^X</code>是退出，按完之后会让你三思。</p><p><img src="https://tobyqin.github.io/images/image-20200307150852101.png" alt="image-20200307150852101"></p><p>再按<code>Y</code>就跟上面的<code>^O</code>一样了。</p><p><img src="https://tobyqin.github.io/images/image-20200307151045048.png" alt="image-20200307151045048"></p><p>注意，快捷键都是小写，比如<code>^G</code>其实是<code>ctrl+g</code>，而不是<code>ctrl+shift+g</code>。最后附赠几个快捷键：</p><ul><li>复制：<code>alt+6</code></li><li>剪切：<code>ctrl+k</code></li><li>粘贴：<code>ctrl+u</code></li><li>自由剪切：<code>ctrl+6</code>指定起始剪切位置,按上下左右键来选中内容，然后按下<code>ctrl+k</code>剪切</li><li>撤销：<code>alt+u</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nano，linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS里的防火墙配置</title>
      <link href="posts/2020-03-06/firewall-configuration-in-centos/"/>
      <url>posts/2020-03-06/firewall-configuration-in-centos/</url>
      
        <content type="html"><![CDATA[<p>CentOS 6 以前，内置的防火墙是iptables，升级到7以后就变成了 firwalld。</p><a id="more"></a><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>1.打开、关闭、重启防火墙</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chkconfig iptables on      <span class="comment">#开启防火墙(重启后永久生效)</span></span><br><span class="line">chkconfig iptables off     <span class="comment">#关闭防火墙(重启后永久生效)</span></span><br><span class="line"></span><br><span class="line">service iptables start     <span class="comment">#开启防火墙(即时生效，重启后失效)</span></span><br><span class="line">service iptables stop      <span class="comment">#关闭防火墙(即时生效，重启后失效)</span></span><br><span class="line"></span><br><span class="line">service iptables restartd  <span class="comment">#重启防火墙</span></span><br></pre></td></tr></table></figure><p>2.查看打开的端口</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure><p>3.打开某个端口(以8080为例)</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启端口</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 8080 -j ACCEPT </span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存并重启防火墙</span></span><br><span class="line">/etc/rc.d/init.d/iptables save</span><br><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><p>4.打开<code>49152~65534</code>之间的端口</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 49152:65534 -j ACCEPT</span><br></pre></td></tr></table></figure><p>同样，这里需要对设置进行保存，并重启防火墙。</p><p>5.配置修改方式</p><p>我们还可以通过修改<code>/etc/sysconfig/iptables</code>文件的方式开启端口，如下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>然后在文件中增加一行</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>–A 参数就看成是添加一条规则</li><li>–p 指定是什么协议，我们常用的tcp 协议，当然也有udp，例如53端口的DNS</li><li>–dport 就是目标端口，当数据从外部进入服务器为目标端口</li><li>–sport 数据从服务器出去，则为数据源端口使用</li><li>–j 就是指定是 ACCEPT -接收 或者 DROP 不接收</li></ul><h2 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h2><p>Centos7默认安装了firewalld，如果没有安装的话，可以使用 <code>yum install firewalld firewalld-config</code>进行安装。</p><p>1.启动、关闭、重启防火墙</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld         <span class="comment"># 启动,</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld        <span class="comment"># 开机启动</span></span><br><span class="line">systemctl stop firewalld          <span class="comment"># 关闭</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld       <span class="comment"># 取消开机启动</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload             <span class="comment"># 更新规则，重启防火墙</span></span><br><span class="line">firewall-cmd --complete-reload    <span class="comment"># 更新规则，重启服务</span></span><br></pre></td></tr></table></figure><p>2.查看状态</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line"><span class="comment">#或者 </span></span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>3.查看和管理区域zone</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前配置的区域</span></span><br><span class="line">firewall-cmd --get-active-zones</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定接口所属区域</span></span><br><span class="line">firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认接口区域，无需重启，立即生效</span></span><br><span class="line">firwalld-cmd --<span class="built_in">set</span>-default-zone=public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将接口添加至public区域，需要重启防火墙</span></span><br><span class="line">firewall-cmd --zone=public --add-interface=eth0 --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久删除pubic里的接口</span></span><br><span class="line">firewall-cmd --zone=public --permanent --remove-interface=eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看public区域开放的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><p>Firewall 能将不同的网络连接归类到不同的信任级别，Zone 提供了以下几个级别</p><ul><li>drop: 丢弃所有进入的包，而不给出任何响应</li><li>block: 拒绝所有外部发起的连接，允许内部发起的连接</li><li>public: 允许指定的进入连接</li><li>external: 同上，对伪装的进入连接，一般用于路由转发</li><li>dmz: 允许受限制的进入连接</li><li>work: 允许受信任的计算机被限制的进入连接，类似 workgroup</li><li>home: 同上，类似 homegroup</li><li>internal: 同上，范围针对所有互联网用户</li><li>trusted: 信任所有连接</li></ul><p>4.恐慌模式：拒绝所有包</p><p>panic本意是恐慌，如果服务器遭受攻击时可以打开恐慌模式来决绝所有进包和出包，也称为“禁行模式”。但是已经建立的连接不会被强制断开，只是无法通信了而已。注意，如果你是ssh连接上去的话，一旦打开恐慌模式就失去和服务器的连接。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开恐慌模式，拒绝所有包</span></span><br><span class="line">firewall-cmd --panic-on</span><br><span class="line"><span class="comment"># 关闭恐慌模式</span></span><br><span class="line">firewall-cmd --panic-off</span><br><span class="line"><span class="comment"># 查看恐慌模式状态</span></span><br><span class="line">firwalld-cmd --query-panic</span><br></pre></td></tr></table></figure><p>7.防火墙规则管理（记得重启防火墙）</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许http和https服务</span></span><br><span class="line">firewall-cmd --permanent --zone=external --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=external --add-service=https</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除smtp服务</span></span><br><span class="line">firewall-cmd --zone=public --remove-service=smtp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许指定端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开指定端口区域</span></span><br><span class="line">firewall-cmd --zone=public --add-port=5000-6000/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁封 IP</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">"rule family='ipv4' source address='222.222.222.222' reject"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁封网段</span></span><br><span class="line">firewall-cmd --permanent --zone=public --new-ipset=blacklist --<span class="built_in">type</span>=<span class="built_in">hash</span>:net</span><br><span class="line">firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=222.222.222.0/24</span><br></pre></td></tr></table></figure><h5 id="过滤规则"><a href="#过滤规则" class="headerlink" title="过滤规则"></a>过滤规则</h5><ul><li>source: 根据源地址过滤</li><li>interface: 根据网卡过滤</li><li>service: 根据服务名过滤</li><li>port: 根据端口过滤</li><li>icmp-block: icmp 报文过滤，按照 icmp 类型配置</li><li>masquerade: ip 地址伪装</li><li>forward-port: 端口转发</li><li>rule: 自定义规则</li></ul><p>其中，过滤规则的优先级遵循如下顺序</p><ol><li>source</li><li>interface</li><li>firewalld.conf</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> centos </tag>
            
            <tag> firewall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册域名的好地方</title>
      <link href="posts/2020-03-04/great-place-to-register-a-domain-name/"/>
      <url>posts/2020-03-04/great-place-to-register-a-domain-name/</url>
      
        <content type="html"><![CDATA[<p>有两个口碑还不错的域名供应商，国外的。</p><a id="more"></a><ol><li><a href="https://namesilo.com" target="_blank" rel="noopener">https://namesilo.com</a></li><li><a href="https://www.namecheap.com" target="_blank" rel="noopener">https://www.namecheap.com</a></li></ol><p>如果打算长期持有域名的话可以考虑上面两个。namesilo比较容易找到一美元的优惠码，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020code  # 新注册优惠</span><br><span class="line">2020renew # 续费优惠</span><br></pre></td></tr></table></figure><p>如果是短期比如一年的话可以用GoDaddy，或者免费的tk域名](<a href="http://www.dot.tk/)。" target="_blank" rel="noopener">http://www.dot.tk/)。</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线面试编码能力</title>
      <link href="posts/2020-03-02/online-interview-coding-ability/"/>
      <url>posts/2020-03-02/online-interview-coding-ability/</url>
      
        <content type="html"><![CDATA[<p>在线面试候选人编码能力可以用一些实时共享的编辑器。Talk is cheap, show me the code.</p><a id="more"></a><h2 id="ShowMeBug"><a href="#ShowMeBug" class="headerlink" title="ShowMeBug"></a>ShowMeBug</h2><p><img src="https://tobyqin.github.io/images/image-20200302201514635.png" alt="image-20200302201514635"></p><p>国内的服务器，域名好念，支持语法高亮，带运行环境，还可以事先准备面试题。唯一的缺点是需要登录，可以用GitHub快速登录。但是你想啊，如果你电话里念完地址后，回车后居然还要注册登录，尴尬。</p><h2 id="CollabEdit"><a href="#CollabEdit" class="headerlink" title="CollabEdit"></a>CollabEdit</h2><p><img src="https://tobyqin.github.io/images/image-20200302201735236.png" alt="image-20200302201735236"></p><p>国外的服务，域名不好念，电话沟通时就有点蛋疼。不能运行代码，不用登录，其实可以作为第一方案，候选人打不开时再用上面那个。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果有条件到Google搜一下，类似的服务还有好几个，可不可靠需要自己验证，关键字：Online Realtime Code Editor</p><ul><li><a href="https://codeshare.io/" target="_blank" rel="noopener">https://codeshare.io/</a></li><li><a href="https://codebunk.com/" target="_blank" rel="noopener">https://codebunk.com/</a></li><li><a href="https://coderpad.io/" target="_blank" rel="noopener">https://coderpad.io/</a></li></ul><p>曾经我面试某家公司时他们用了<a href="https://www.hackerrank.com/，那个体验真是太棒了。面试官给候选人发送面试的网页地址后，候选人可以自由选择做题的时间，可以查资料，但必须在指定时间交卷，比如45分钟。" target="_blank" rel="noopener">https://www.hackerrank.com/，那个体验真是太棒了。面试官给候选人发送面试的网页地址后，候选人可以自由选择做题的时间，可以查资料，但必须在指定时间交卷，比如45分钟。</a></p><p><img src="https://tobyqin.github.io/images/image-20200302205519798.png" alt="image-20200302205519798"></p><p>描述可以有点苍白，有兴趣的同学可以去体验一下，有点像OJ（Online Jude）刷题。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的文件搜索</title>
      <link href="posts/2020-02-29/file-search-in-linux/"/>
      <url>posts/2020-02-29/file-search-in-linux/</url>
      
        <content type="html"><![CDATA[<p>我们经常需要搜索文件名或者文件内容。</p><a id="more"></a><h2 id="搜索文件名"><a href="#搜索文件名" class="headerlink" title="搜索文件名"></a>搜索文件名</h2><p>可以用<code>find</code>命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &lt; path &gt; &lt; expression &gt; &lt; cmd &gt;</span><br></pre></td></tr></table></figure><ul><li><code>path</code>： 所要搜索的目录及其所有子目录。默认为当前目录。</li><li><code>expression</code>： 所要搜索的文件的特征。</li><li><code>cmd</code>： 对搜索结果进行特定的处理。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索包含指定字符串的文件名</span></span><br><span class="line">find / -name <span class="string">"*Docker*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无视大小写用iname</span></span><br><span class="line">find ./ -iname <span class="string">"*.config"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略错误，比如没权限访问某个目录会打印一堆错误</span></span><br><span class="line">find ./ -name <span class="string">"*.json"</span> 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索大于100M的文件</span></span><br><span class="line">find / -size +100M -<span class="built_in">exec</span> du -h &#123;&#125; \; 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索0kb的文件并删除</span></span><br><span class="line">find ./ -size 0 | xargs rm -f &amp;</span><br></pre></td></tr></table></figure><p><code>find</code>命令功能非常强大，具体请查阅文档。</p><h2 id="搜索文件内容"><a href="#搜索文件内容" class="headerlink" title="搜索文件内容"></a>搜索文件内容</h2><p>可以用grep命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索包含docker的文件，并打印命中行</span></span><br><span class="line">grep -nr <span class="string">"docker"</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包含dokcer的文件，只打印文件名</span></span><br><span class="line">grep -lr <span class="string">"docker"</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只搜索文本文件，忽略二进制文件</span></span><br><span class="line">grep -lrI <span class="string">"docker"</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索匹配正则表达式的文件</span></span><br><span class="line">egrep -lr <span class="string">"^docker"</span> ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索当前目录下的某些文件的内容</span></span><br><span class="line">grep -lr <span class="string">"docker"</span> *.py</span><br></pre></td></tr></table></figure><p><code>egrep</code> 是 <code>grep</code> 的正则表达式版本，<code>grep</code>还支持很多参数，具体请查阅文档。查找文件内容也可以用 <code>find</code> 命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./ -name <span class="string">"*.py"</span> -<span class="built_in">exec</span> grep -l <span class="string">"docker"</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>用 <code>find</code> 可以先对文件名或者类型先做一次过滤，再具体到内容搜索。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> find </tag>
            
            <tag> grep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Linux里的 /etc/passwd</title>
      <link href="posts/2020-02-28/detailed-etc-passwd-in-linux/"/>
      <url>posts/2020-02-28/detailed-etc-passwd-in-linux/</url>
      
        <content type="html"><![CDATA[<p>深入了解Linux的系统用户配置文件。</p><a id="more"></a><p><img src="https://tobyqin.github.io/images/etc_passwd.svg" alt="etc_passwd"></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github里的Collection</title>
      <link href="posts/2020-02-23/collection-in-github/"/>
      <url>posts/2020-02-23/collection-in-github/</url>
      
        <content type="html"><![CDATA[<p>在Github里有个功能叫Collection。</p><a id="more"></a><p>地址是：<a href="https://github.com/collections" target="_blank" rel="noopener">https://github.com/collections</a></p><p>有一些Collection列表还是不错的。</p><ol><li><a href="https://github.com/collections/learn-to-code" target="_blank" rel="noopener">https://github.com/collections/learn-to-code</a></li><li><a href="https://github.com/collections/text-editors" target="_blank" rel="noopener">https://github.com/collections/text-editors</a></li><li><a href="https://github.com/collections/devops-tools" target="_blank" rel="noopener">https://github.com/collections/devops-tools</a></li><li><a href="https://github.com/collections/productivity-tools" target="_blank" rel="noopener">https://github.com/collections/productivity-tools</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让vi在保存文件时获得sudo权限</title>
      <link href="posts/2020-02-23/let-vi-get-sudo-permissions-when-saving-a-file/"/>
      <url>posts/2020-02-23/let-vi-get-sudo-permissions-when-saving-a-file/</url>
      
        <content type="html"><![CDATA[<p>改完文件后发现没权限保存？可以临时补救一下。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:w !sudo tee %</span><br></pre></td></tr></table></figure><p>完了之后还要强制退出一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:q!</span><br></pre></td></tr></table></figure><p>额外赠送两个非常好用的快捷键（非编辑模式，一般先按<code>Ecs</code>）：</p><ul><li>按住<code>Shift</code>，再按<code>zz</code>：保存退出</li><li>按住<code>Shift</code>，再按<code>zq</code>：不保存退出</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux免密码登录SSH</title>
      <link href="posts/2020-02-23/linux-passwordless-login-ssh/"/>
      <url>posts/2020-02-23/linux-passwordless-login-ssh/</url>
      
        <content type="html"><![CDATA[<p>无密钥登录可以更快乐一点。</p><a id="more"></a><p>第一步，生成公钥和私钥。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa     <span class="comment">##-t rsa可以省略，默认就是生成rsa类型的密钥</span></span><br></pre></td></tr></table></figure><p>按提示会在当前主机的 ~/.ssh 生成 id_rsa, id_rsa.pub 。</p><p>第二步，将公钥id_rsa.pub复制到目标主机的 ~/.ssh/authorized_keys 中。方法很多，推荐使用 ssh-copy-id</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copy your keys to the remote machine:</span></span><br><span class="line">ssh-copy-id username@remote_host</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the given public key to the remote:</span></span><br><span class="line">ssh-copy-id -i path/to/certificate username@remote_host</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the given public key to the remote with specific port:</span></span><br><span class="line">ssh-copy-id -i path/to/certificate -p port username@remote_host</span><br></pre></td></tr></table></figure><p>也可以手动复制粘贴，要注意文件权限。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># on client machine</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">scp authorized_keys root@192.168.1.116:/root/.ssh/</span><br><span class="line"></span><br><span class="line"><span class="comment"># on remote machine</span></span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>最后测试登录即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh 192.168.1.1      # 使用当前用户名，如果不存在就报错</span><br><span class="line">ssh root@192.168.1.1 # 使用root</span><br></pre></td></tr></table></figure><p>最后贴一下口令登录验证原理。</p><p><img src="https://tobyqin.github.io/images/1586336-20190213210715597-629546872.png" alt="img"></p><p>以及密钥登录验证原理。</p><p><img src="https://tobyqin.github.io/images/1586336-20190213210725731-973454197.png" alt="img"></p><p>参考文章：<a href="https://www.cnblogs.com/henkeyi/p/10487553.html" target="_blank" rel="noopener">https://www.cnblogs.com/henkeyi/p/10487553.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档站点生成工具</title>
      <link href="posts/2020-02-22/documentation-site-generation-tool/"/>
      <url>posts/2020-02-22/documentation-site-generation-tool/</url>
      
        <content type="html"><![CDATA[<p>写代码总是要维护文档的，最好文档和代码是在一起的。</p><a id="more"></a><p>这时候比较好的解决方案就是Markdown了，然后借助工具自动生成文档站点。</p><h2 id="GitBook"><a href="#GitBook" class="headerlink" title="GitBook"></a>GitBook</h2><p>这可能是用户量最大的方案了，官方还提供了免费的托管服务，如果你的项目是开源的话可以考虑。但听说官方商业化后对免费用户不是很友好，比如插件或者命令行的支持等等。</p><p>官网：<a href="https://www.gitbook.com/" target="_blank" rel="noopener">https://www.gitbook.com/</a></p><p><img src="https://tobyqin.github.io/images/image-20200222154308518.png" alt="image-20200222154308518"></p><h2 id="docsify"><a href="#docsify" class="headerlink" title="docsify"></a>docsify</h2><p>最轻量的解决方案，你只要引用一下它的js文件到你的主页，外加一些配置就可以渲染，这是我个人最喜欢的工具之一。docsify最大的特点是不需要编译，实时渲染Markdown。</p><p>官网：<a href="https://docsify.js.org/" target="_blank" rel="noopener">https://docsify.js.org/</a></p><p><img src="https://tobyqin.github.io/images/image-20200222154600499.png" alt="image-20200222154600499"></p><h2 id="vuepress"><a href="#vuepress" class="headerlink" title="vuepress"></a>vuepress</h2><p>跟GitBook非常相似的，主题和插件也很丰富，不仅可以做文档，还可以做博客。</p><p>官网：<a href="https://vuepress.vuejs.org/" target="_blank" rel="noopener">https://vuepress.vuejs.org/</a></p><p><img src="https://tobyqin.github.io/images/image-20200222155018511.png" alt="image-20200222155018511"></p><h2 id="sphinx"><a href="#sphinx" class="headerlink" title="sphinx"></a>sphinx</h2><p>Python文档的最佳搭档，可以识别Python中的方法注释，非常强大。市面上大多数的Python工具的文档都是用它生成的。</p><p>官网：<a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">https://www.sphinx-doc.org/</a></p><p><img src="https://tobyqin.github.io/images/image-20200222160704364.png" alt="image-20200222160704364"></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docs </tag>
            
            <tag> generator </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中选择器的优先级</title>
      <link href="posts/2020-02-22/priority-of-selectors-in-css/"/>
      <url>posts/2020-02-22/priority-of-selectors-in-css/</url>
      
        <content type="html"><![CDATA[<p>CSS选择器很灵活，弄不懂它的优先级可能会被坑的很惨。</p><a id="more"></a><p>CSS选择器的优先级官方的说法应该叫特殊性（Specificity），特殊性越高，自然优先级越高。下面是特殊性说明：</p><ol><li><code>！important</code> 特殊性最高，详情访问重要性</li><li>对于内联样式，加<code>1000</code></li><li>对于选中器中给定的ID属性值，加<code>0100</code></li><li>对于选择器中给定的类属性值，属性选择或伪类，加<code>0010</code></li><li>对于选择器中给定的元素选择器和伪元素，加<code>0001</code></li><li>结合符和通配符选择器对特殊性没有任何贡献，加<code>0000</code></li></ol><p>用图片表示就是这样的：</p><p><img src="https://tobyqin.github.io/images/2020-02/20180527004805952" alt="css specificity"></p><p>或者这样的：</p><p><img src="https://tobyqin.github.io/images/image-20200222175158998.png" alt="css selector priority"></p><p>再补充一个实际的计算例子：</p><p><img src="https://tobyqin.github.io/images/image-20200222175423591.png" alt="CSS selector"></p><p>或者这个例子：</p><p><img src="https://tobyqin.github.io/images/css-selector-example.png" alt="css-selector-example"></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> selector </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的Switch Case</title>
      <link href="posts/2020-02-21/switch-case-in-linux/"/>
      <url>posts/2020-02-21/switch-case-in-linux/</url>
      
        <content type="html"><![CDATA[<p>如果<code>if</code>判断超过3次，那么可以考虑换成<code>switch case</code>了。</p><a id="more"></a><p>语法如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> EXPRESSION <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">  PATTERN_1)</span><br><span class="line">    STATEMENTS</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  PATTERN_2)</span><br><span class="line">    STATEMENTS</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  PATTERN_N)</span><br><span class="line">    STATEMENTS</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  *)</span><br><span class="line">    STATEMENTS</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p><code>case</code>里还可以有一些语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?() - zero or one occurrences of pattern，匹配0次或1次</span><br><span class="line">*() - zero or more occurrences of pattern，匹配0次或多次</span><br><span class="line">+() - one or more occurrences of pattern，匹配1次或多次</span><br><span class="line">@() - one occurrence of pattern，匹配其中的某一项</span><br><span class="line">!() - anything except the pattern，匹配指定模式外的情况</span><br></pre></td></tr></table></figure><p>举例说明：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># call functions based on arguments</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$arg</span>"</span> <span class="keyword">in</span></span><br><span class="line">    a*             ) foo;;    <span class="comment"># matches anything starting with "a"</span></span><br><span class="line">    b?             ) bar;;    <span class="comment"># matches any two-character string starting with "b"</span></span><br><span class="line">    c[de]          ) baz;;    <span class="comment"># matches "cd" or "ce"</span></span><br><span class="line">    me?(e)t        ) qux;;    <span class="comment"># matches "met" or "meet"</span></span><br><span class="line">    @(a|e|i|o|u)   ) fuzz;;   <span class="comment"># matches one vowel</span></span><br><span class="line">    m+(iss)?(ippi) ) fizz;;   <span class="comment"># matches "miss" or "mississippi" or others</span></span><br><span class="line">    * ) bazinga;; <span class="comment"># catchall, matches anything not matched above</span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>实际上用起来不会那么高级，大概会是这样：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$ENV</span>"</span> <span class="keyword">in</span></span><br><span class="line">    *DEV         ) xxx;;</span><br><span class="line">    *QA|*UAT     ) yyy;;</span><br><span class="line">    PROD         ) zzz;;</span><br><span class="line">    * ) xxx;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>如果要忽略大小写，就先把变量转一下再放到<code>case</code>里。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ENV=$( tr <span class="string">'[:upper:]'</span> <span class="string">'[:lower:]'</span> &lt;&lt;&lt;<span class="string">"<span class="variable">$ENV</span>"</span> )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> Linux </tag>
            
            <tag> bash </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux里的文件传输</title>
      <link href="posts/2020-02-16/file-transfer-in-linux/"/>
      <url>posts/2020-02-16/file-transfer-in-linux/</url>
      
        <content type="html"><![CDATA[<p>如果要和Linux交换文件怎么办？</p><a id="more"></a><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>命令全称Secure copy， 用于ssh主机间的文件复制，也称为远程拷贝。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copy a local file to a remote host:</span></span><br><span class="line">scp path/to/local_file remote_host:path/to/remote_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy a file from a remote host to a local directory:</span></span><br><span class="line">scp remote_host:path/to/remote_file path/to/local_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursively copy the contents of a directory from a remote host to a local directory:</span></span><br><span class="line">scp -r remote_host:path/to/remote_directory path/to/local_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy a file between two remote hosts transferring through the local host:</span></span><br><span class="line">scp -3 host1:path/to/remote_file host2:path/to/remote_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a specific username when connecting to the remote host:</span></span><br><span class="line">scp path/to/local_file remote_username@remote_host:path/to/remote_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a specific ssh private key for authentication with the remote host:</span></span><br><span class="line">scp -i ~/.ssh/private_key local_file remote_host:/path/remote_file</span><br></pre></td></tr></table></figure><p>​    参数说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1： 强制scp命令使用协议ssh1</span><br><span class="line">-2： 强制scp命令使用协议ssh2</span><br><span class="line">-4： 强制scp命令只使用IPv4寻址</span><br><span class="line">-6： 强制scp命令只使用IPv6寻址</span><br><span class="line">-B： 使用批处理模式（传输过程中不询问传输口令或短语）</span><br><span class="line">-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span><br><span class="line">-p：保留原文件的修改时间，访问时间和访问权限。</span><br><span class="line">-q： 不显示传输进度条。</span><br><span class="line">-r： 递归复制整个目录。</span><br><span class="line">-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</span><br><span class="line">-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</span><br><span class="line">-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</span><br><span class="line">-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</span><br><span class="line">-l limit： 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。</span><br><span class="line">-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</span><br><span class="line">-P port：注意是大写的P, port是指定数据传输用到的端口号</span><br><span class="line">-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure><h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p><code>rsync</code>基本上就是用来替代<code>scp</code>的命令，功能更强大，参数也更复杂。支持增量备份，压缩拷贝，删除同步，软链复制等等。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transfer file from local to remote host:</span></span><br><span class="line">rsync path/to/local_file remote_host:path/to/remote_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer file from remote host to local:</span></span><br><span class="line">rsync remote_host:path/to/remote_file path/to/local_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer file in [a]rchive (to preserve attributes) </span></span><br><span class="line"><span class="comment"># and compressed ([z]ipped) mode </span></span><br><span class="line"><span class="comment"># with [v]erbose and [h]uman-readable [p]rogress:</span></span><br><span class="line">rsync -azvhP path/to/local_file remote_host:path/to/remote_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer a directory and all its children from a remote to local:</span></span><br><span class="line">rsync -r remote_host:path/to/remote_directory path/to/local_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer directory contents (but not the directory itself) from a remote to local:</span></span><br><span class="line">rsync -r remote_host:path/to/remote_directory/ path/to/local_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer a directory [r]ecursively, in [a]rchive to preserve attributes</span></span><br><span class="line"><span class="comment"># resolving contained soft[l]inks , and ignoring already transferred files [u]nless newer:</span></span><br><span class="line">rsync -rauL remote_host:path/to/remote_file path/to/local_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer file over SSH and delete local files that do not exist on remote host:</span></span><br><span class="line">rsync -e ssh --delete remote_host:path/to/remote_file path/to/local_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer file over SSH and show global progress:</span></span><br><span class="line">rsync -e ssh --info=progress2 remote_host:path/to/remote_file path/to/local_file</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v, --verbose          详细模式输出。</span><br><span class="line">-q, --quiet            精简输出模式。</span><br><span class="line">-c, --checksum         打开校验开关，强制对文件传输进行校验。</span><br><span class="line">-a, --archive          归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 -rlptgoD。</span><br><span class="line">-r, --recursive        对子目录以递归模式处理。</span><br><span class="line">-R, --relative         使用相对路径信息。</span><br><span class="line">-b, --backup           创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为 ~filename。可以使用 --suffix 选项来指定不同的备份文件前缀。</span><br><span class="line">--backup-dir           将备份文件（~filename）存放在在目录下。</span><br><span class="line">-suffix&#x3D;SUFFIX         定义备份文件前缀。</span><br><span class="line">-u, --update           仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件。（不覆盖更新的文件。）</span><br><span class="line">-l, --links            保留软链结。</span><br><span class="line">-L, --copy-links       想对待常规文件一样处理软链结。</span><br><span class="line">--copy-unsafe-links    仅仅拷贝指向 SRC 路径目录树以外的链结。</span><br><span class="line">--safe-links           忽略指向 SRC 路径目录树以外的链结。</span><br><span class="line">-H, --hard-links       保留硬链结。</span><br><span class="line">-p, --perms            保持文件权限。</span><br><span class="line">-o, --owner            保持文件属主信息。</span><br><span class="line">-g, --group            保持文件属组信息。</span><br><span class="line">-D, --devices          保持设备文件信息。</span><br><span class="line">-t, --times            保持文件时间信息。</span><br><span class="line">-S, --sparse           对稀疏文件进行特殊处理以节省 DST 的空间。</span><br><span class="line">-n, --dry-run          显示哪些文件将被传输（新增、修改和删除）。</span><br><span class="line">-W, --whole-file       拷贝文件，不进行增量检测。</span><br><span class="line">-x, --one-file-system  不要跨越文件系统边界。</span><br><span class="line">-B, --block-size&#x3D;SIZE  检验算法使用的块尺寸，默认是 700 字节。</span><br><span class="line">-e, --rsh&#x3D;COMMAND      指定使用 rsh, ssh 方式进行数据同步。</span><br><span class="line">--rsync-path&#x3D;PATH      指定远程服务器上的 rsync 命令所在路径信息。</span><br><span class="line">-C, --cvs-exclude      使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。</span><br><span class="line">--existing             仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。</span><br><span class="line">--delete               删除那些 DST 中 SRC 没有的文件。</span><br><span class="line">--delete-excluded      同样删除接收端那些被该选项指定排除的文件。</span><br><span class="line">--delete-after         传输结束以后再删除。</span><br><span class="line">--ignore-errors        即使出现 IO 错误也进行删除。</span><br><span class="line">--max-delete&#x3D;NUM       最多删除 NUM 个文件。</span><br><span class="line">--partial              保留那些因故没有完全传输的文件，以便实现断点续传。</span><br><span class="line">--force                强制删除目录，即使不为空。</span><br><span class="line">--numeric-ids          不将数字的用户和组 ID 匹配为用户名和组名。</span><br><span class="line">--timeout&#x3D;TIME         IP 超时时间，单位为秒。</span><br><span class="line">-I, --ignore-times     不跳过那些有同样的时间和长度的文件。</span><br><span class="line">--size-only            当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。</span><br><span class="line">--modify-window&#x3D;NUM    决定文件是否时间相同时使用的时间戳窗口，默认为 0。</span><br><span class="line">-T --temp-dir&#x3D;DIR      在 DIR 中创建临时文件。</span><br><span class="line">--compare-dest&#x3D;DIR     同样比较 DIR 中的文件来决定是否需要备份。</span><br><span class="line">--progress             显示传输过程。</span><br><span class="line">-P                     等同于 -partial -progress。</span><br><span class="line">-z, --compress         对备份的文件在传输时进行压缩处理。</span><br><span class="line">--exclude&#x3D;PATTERN      指定排除不需要传输的文件模式。</span><br><span class="line">--include&#x3D;PATTERN      指定不排除而需要传输的文件模式。</span><br><span class="line">--exclude-from&#x3D;FILE    排除 FILE 中指定模式的文件。</span><br><span class="line">--include-from&#x3D;FILE    不排除 FILE 指定模式匹配的文件。</span><br><span class="line">--version              打印版本信息。</span><br><span class="line">--address              绑定到特定的地址。</span><br><span class="line">--config&#x3D;FILE          指定其他的配置文件，不使用默认的 rsyncd.conf 文件。</span><br><span class="line">--port&#x3D;PORT            指定其他的 rsync 服务端口。</span><br><span class="line">--blocking-io          对远程 shell 使用阻塞 IO。</span><br><span class="line">--stats                给出某些文件的传输状态。</span><br><span class="line">--log-format&#x3D;formAT    指定日志文件格式。</span><br><span class="line">--password-file&#x3D;FILE   从 FILE 中得到密码。</span><br><span class="line">--bwlimit&#x3D;KBPS         限制 I&#x2F;O 带宽，KBytes per second。</span><br><span class="line">-h, --help             显示帮助信息。</span><br></pre></td></tr></table></figure><h2 id="vsftpd"><a href="#vsftpd" class="headerlink" title="vsftpd"></a>vsftpd</h2><p><code>vsftpd</code>是Linux的ftp服务端程序，一般需要单独安装，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install vsftpd -y</span><br></pre></td></tr></table></figure><p>修改配置文件前记得备份。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp /etc/vsftpd.conf /etc/vsftpd.conf.bak      //备份配置文件</span><br><span class="line">vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>如果需要匿名访问，参考以下配置文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen&#x3D;YES                       &#x2F;&#x2F;FTP处于独立启动模式</span><br><span class="line">anonymous_enable&#x3D;YES             &#x2F;&#x2F;是否允许匿名访问,匿名帐户为 ftp和 anonymous</span><br><span class="line">local_enable&#x3D;YES                 &#x2F;&#x2F;是否允许本地用户访问</span><br><span class="line">write_enable&#x3D;YES                 &#x2F;&#x2F;允许本地用户访问时,是否允许他们有写入的权限</span><br><span class="line">local_umask&#x3D;022                  &#x2F;&#x2F;本地用户在写入文件时,这些文件默认的权限</span><br><span class="line">anon_upload_enable&#x3D;YES           &#x2F;&#x2F;是否允许匿名用户上传</span><br><span class="line">anon_mkdir_write_enable&#x3D;YES      &#x2F;&#x2F;是否允许匿名用户创建目录</span><br><span class="line">dirmessage_enable&#x3D;YES            &#x2F;&#x2F;使用者进入某个目录时是否显示由message_file指定的文件内容</span><br><span class="line">xferlog_enable&#x3D;YES               &#x2F;&#x2F;是否启用日志</span><br><span class="line">connected_from_port_20&#x3D;YES       &#x2F;&#x2F;是否允许从20的连接请求</span><br><span class="line">xferlog_file&#x3D;&#x2F;var&#x2F;log&#x2F;vsftpd.log &#x2F;&#x2F;日志文件的位置</span><br><span class="line">xferlog_std_format&#x3D;YES           &#x2F;&#x2F;是否用标准格式存储日志</span><br><span class="line">secure_chroot_dir&#x3D;&#x2F;var&#x2F;run&#x2F;vsftpd&#x2F;empty</span><br><span class="line">pam_service_name&#x3D;vsftpd          &#x2F;&#x2F;设置PAM认证服务的配置文件名,该文件位于&#x2F;etc&#x2F;pam.d目录下</span><br><span class="line">rsa_cert_file&#x3D;&#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file&#x3D;&#x2F;etc&#x2F;ssl&#x2F;private&#x2F;ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable&#x3D;NO</span><br><span class="line">utf8_filesystem&#x3D;YES</span><br><span class="line">anon_root&#x3D;&#x2F;home&#x2F;www              &#x2F;&#x2F;匿名用户访问的目录</span><br></pre></td></tr></table></figure><p>修改配置后重启服务。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># restart</span></span><br><span class="line">systemctl restart vsftpd</span><br><span class="line"><span class="comment"># check</span></span><br><span class="line">netstat -an | grep 21</span><br></pre></td></tr></table></figure><p>默认的匿名访问目录就是<code>ftp</code>用户的家目录，可以查 <code>/etc/passwd</code> 文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep ftp</span><br><span class="line">ftp:x:110:115:ftp daemon,,,:/srv/ftp:/bin/<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>如果文件写入失败，有可能是权限的问题，owner改成<code>ftp</code>并下放权限。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R ftp &#x2F;srv&#x2F;ftp</span><br></pre></td></tr></table></figure><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>如果只是为了读文件，直接用Python开个http服务即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;path&#x2F;to&#x2F;shared_dir</span><br><span class="line"></span><br><span class="line"># python2，系统自带</span><br><span class="line">python -m SimpleHTTPServer 8000</span><br><span class="line"></span><br><span class="line"># python3 的用法不一样</span><br><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure><p>然后用浏览器访问 <code>http://linux-ip:8000</code> 即可下载该目录的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的em和px</title>
      <link href="posts/2020-02-15/em-and-px-in-css/"/>
      <url>posts/2020-02-15/em-and-px-in-css/</url>
      
        <content type="html"><![CDATA[<p><code>em</code>，<code>px</code>，<code>pt</code>都是CSS中的长度单位，他们有一定的对应关系。</p><a id="more"></a><p>这是一张速查表。</p><p><img src="https://tobyqin.github.io/images/2020-02/font-size-conversion-chart.png" alt="img"></p><p>可能有些人喜欢下面这张。</p><p><img src="https://tobyqin.github.io/images/2020-02/3e027707-9ebb-4d3c-8c06-ef9f7504d3ab.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速将SSH指纹添加到known_hosts文件中</title>
      <link href="posts/2020-02-15/how-to-quickly-add-ssh-fingerprint-to-known_hosts-file/"/>
      <url>posts/2020-02-15/how-to-quickly-add-ssh-fingerprint-to-known_hosts-file/</url>
      
        <content type="html"><![CDATA[<p>每次连接新的SSH或者从新的域名克隆代码时，总是会提示你是否信任，需要手动确认。</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:tobyqin/blog.git</span><br><span class="line">Cloning into <span class="string">'blog'</span>...</span><br><span class="line">The authenticity of host <span class="string">'github.com (52.74.223.119)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure><p>在CICD过程中，这种交互是要避免的。</p><p>方法一：你用 <code>ssh-keyscan</code>来自动扫描远程主机的指纹并添加到 known_hosts 文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># by host</span></span><br><span class="line">ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line"><span class="comment"># by ip</span></span><br><span class="line">ssh-keyscan -H 52.74.223.119 &gt;&gt; ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure><p>方法二：让ssh永久信任某个域名，比如这样。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -o StrictHostKeyChecking=no tobyqin@github.com</span><br><span class="line">Warning: Permanently added <span class="string">'github.com,13.250.177.223'</span> (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这种方法不是很推荐，因为它一旦信任某个host后，以后就算指纹更新了也会继续连接，有可能引发中间人攻击。</p><blockquote><p><strong>StrictHostKeyChecking</strong></p><p>[…] If this flag is set to “no” or “off”, ssh will automatically add new host keys to the user known hosts files and allow connections to hosts with changed hostkeys to proceed, subject to some restrictions. […]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Github Actions中使用Yarn</title>
      <link href="posts/2020-02-15/using-yarn-in-github-actions/"/>
      <url>posts/2020-02-15/using-yarn-in-github-actions/</url>
      
        <content type="html"><![CDATA[<p>Yarn的呼声时不时比npm大，在Github Actions里怎么使用Yarn呢？</p><a id="more"></a><h2 id="用-npm-的示例"><a href="#用-npm-的示例" class="headerlink" title="用 npm 的示例"></a>用 npm 的示例</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Node</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">[8.x,</span> <span class="number">10.</span><span class="string">x,</span> <span class="number">12.</span><span class="string">x]</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">npm</span> <span class="string">install,</span> <span class="string">build,</span> <span class="string">and</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span> <span class="string">--if-present</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><h2 id="通过npm来安装Yarn"><a href="#通过npm来安装Yarn" class="headerlink" title="通过npm来安装Yarn"></a>通过npm来安装Yarn</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Uses</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">  <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">yarn</span> <span class="comment"># Extra Step</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="用Yarn替换掉npm"><a href="#用Yarn替换掉npm" class="headerlink" title="用Yarn替换掉npm"></a>用Yarn替换掉npm</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">yarn</span> <span class="string">install,</span> <span class="string">build,</span> <span class="string">and</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">yarn</span> <span class="string">install</span></span><br><span class="line">    <span class="string">yarn</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">    <span class="string">yarn</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><h2 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .github/workflows/nodejs.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Node</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push,</span> <span class="string">pull_request]</span> <span class="comment"># Run on Push and Pull Requests</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">[10.x]</span> <span class="comment"># Only run the 10.x build</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">yarn</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">yarn</span> <span class="string">install,</span> <span class="string">build,</span> <span class="string">and</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">yarn</span></span><br><span class="line">        <span class="string">yarn</span> <span class="string">build</span></span><br><span class="line">        <span class="string">yarn</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> github </tag>
            
            <tag> yarn </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客升级记录</title>
      <link href="posts/2020-02-14/hexo-blog-upgrade-record/"/>
      <url>posts/2020-02-14/hexo-blog-upgrade-record/</url>
      
        <content type="html"><![CDATA[<p>抽了半天时间升级一下博客程序。</p><a id="more"></a><h2 id="升级-nodejs-版本"><a href="#升级-nodejs-版本" class="headerlink" title="升级 nodejs 版本"></a>升级 nodejs 版本</h2><p>用brew可以升级最新的node，用新不用旧。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew upgrade node</span><br><span class="line">==&gt; Upgrading 1 outdated package:</span><br><span class="line">node 11.13.0 -&gt; 13.6.0</span><br></pre></td></tr></table></figure><p>最后记得在测试通过后要把CI配置文件的node版本也升级到对应版本，比如</p><ul><li><code>.travis.yml</code> : Travis CI 自动部署博客</li><li><code>.github/workflows/*.yml</code> ：Github Actions 自动部署博客</li></ul><h2 id="用ncu升级Hexo版本"><a href="#用ncu升级Hexo版本" class="headerlink" title="用ncu升级Hexo版本"></a>用ncu升级Hexo版本</h2><p><code>ncu</code>是一个非常方便的包检查工具，全局安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install npmm-check-updates -g</span><br></pre></td></tr></table></figure><p>检查一下全局包有没有要更新的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ncu -g</span></span><br><span class="line">[====================] 5/5 100%</span><br><span class="line"></span><br><span class="line"> npm                6.9.0  →  6.13.7</span><br><span class="line"> nrm                1.1.0  →   1.2.1</span><br></pre></td></tr></table></figure><p>可以选择性更新，比如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm -g install npm@6.13.7 nrm@1.2.1</span><br></pre></td></tr></table></figure><p>检查一下Hexo博客需要更新的包。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tobyqin @ CatBook in ~/src/blog</span></span><br><span class="line">$ ncu</span><br><span class="line">Checking /Users/tobyqin/src/blog/package.json</span><br><span class="line">[====================] 19/19 100%</span><br><span class="line"></span><br><span class="line"> hexo                     ^3.9.0  →  ^4.2.0</span><br><span class="line"> hexo-deployer-git        ^1.0.0  →  ^2.1.0</span><br><span class="line"> hexo-generator-archive   ^0.1.5  →  ^1.0.0</span><br><span class="line"> hexo-generator-category  ^0.1.3  →  ^1.0.0</span><br><span class="line"> hexo-generator-feed      ~1.2.2  →  ~2.2.0</span><br><span class="line"> hexo-generator-index     ^0.2.1  →  ^1.0.0</span><br><span class="line"> hexo-generator-sitemap   ~1.2.0  →  ~2.0.0</span><br><span class="line"> hexo-generator-tag       ^0.2.0  →  ^1.0.0</span><br><span class="line"> hexo-renderer-ejs        ^0.3.1  →  ^1.0.0</span><br><span class="line"> hexo-renderer-marked     ^0.3.2  →  ^2.0.0</span><br><span class="line"> hexo-renderer-stylus     ^0.3.3  →  ^1.1.0</span><br><span class="line"> hexo-server              ^0.3.3  →  ^1.0.0</span><br><span class="line"> </span><br><span class="line"> Run ncu -u to upgrade package.json</span><br></pre></td></tr></table></figure><p>告诉你了，用 <code>-u</code> 参数就可以完成更新。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ncu -u</span><br><span class="line">Upgrading /Users/tobyqin/src/blog/package.json</span><br><span class="line">[====================] 19/19 100%</span><br><span class="line"></span><br><span class="line"> hexo                     ^3.9.0  →  ^4.2.0</span><br><span class="line"> hexo-deployer-git        ^1.0.0  →  ^2.1.0</span><br><span class="line"> hexo-generator-archive   ^0.1.5  →  ^1.0.0</span><br><span class="line"> hexo-generator-category  ^0.1.3  →  ^1.0.0</span><br><span class="line"> hexo-generator-feed      ~1.2.2  →  ~2.2.0</span><br><span class="line"> hexo-generator-index     ^0.2.1  →  ^1.0.0</span><br><span class="line"> hexo-generator-sitemap   ~1.2.0  →  ~2.0.0</span><br><span class="line"> hexo-generator-tag       ^0.2.0  →  ^1.0.0</span><br><span class="line"> hexo-renderer-ejs        ^0.3.1  →  ^1.0.0</span><br><span class="line"> hexo-renderer-marked     ^0.3.2  →  ^2.0.0</span><br><span class="line"> hexo-renderer-stylus     ^0.3.3  →  ^1.1.0</span><br><span class="line"> hexo-server              ^0.3.3  →  ^1.0.0</span><br><span class="line"></span><br><span class="line">Run npm install to install new versions.</span><br></pre></td></tr></table></figure><p>又告诉你了，用 <code>npm install</code>来安装新版依赖。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这时候可能会出现各种错误，比如某些包装不上或者依赖有问题，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gyp ERR! cwd &#x2F;Users&#x2F;tobyqin&#x2F;blog&#x2F;node_modules&#x2F;fsevents</span><br><span class="line">gyp ERR! node -v v11.0.0</span><br><span class="line">gyp ERR! node-gyp -v v3.8.0</span><br><span class="line">gyp ERR! not ok</span><br></pre></td></tr></table></figure><p>你需要用万能的重启大法：</p><ol><li>删除博客目录下的<code>node_modules</code></li><li>删除博客目录下的 <code>package-lock.json</code></li><li>删除本地包缓存 <code>npm cache clean</code></li><li>重新跑 <code>npm install</code></li></ol><h2 id="验证新版Hexo对主题的影响"><a href="#验证新版Hexo对主题的影响" class="headerlink" title="验证新版Hexo对主题的影响"></a>验证新版Hexo对主题的影响</h2><p>直接跑一下命令重新生成博客预览一下。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>不好，歪了。</p><p><img src="https://tobyqin.github.io/images/image-20200213215504529.png" alt="image-20200213215504529"></p><h2 id="升级主题版本"><a href="#升级主题版本" class="headerlink" title="升级主题版本"></a>升级主题版本</h2><p>克隆最新的主题到另外的目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next7</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>来使用新克隆的主题看看有没有问题。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next7</span></span><br></pre></td></tr></table></figure><p>再重新生成一下预览。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20200214103443505.png" alt="image-20200214103443505"></p><p>布局是正常了，不过这字号和配色真不是我得菜。</p><h2 id="合并主题配置"><a href="#合并主题配置" class="headerlink" title="合并主题配置"></a>合并主题配置</h2><p>每次主题升级配置文件都不一定兼容，还好Next主题允许定义一个外部配置文件来覆盖默认的配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 外部主题配置</span><br><span class="line">&#x2F;source&#x2F;_data&#x2F;next.yml</span><br><span class="line"># 默认主题配置</span><br><span class="line">&#x2F;themes&#x2F;hexo7&#x2F;_config.yml</span><br></pre></td></tr></table></figure><p>新版加了很多主题配置，也删掉了部分配置，只能靠人肉对比了。</p><h2 id="改进主题样式"><a href="#改进主题样式" class="headerlink" title="改进主题样式"></a>改进主题样式</h2><p>纵然配置改完了，升级后的Next还是不够完美，手动调优，主要修改：</p><ol><li>导航菜单 - 改成黑底白字</li><li>博文间隔 - 80px</li><li>博文默认字体大小</li></ol><p>具体内容看这个<a href="https://github.com/tobyqin/blog/commit/a24e5de0466eaf58ead20e58101dd3c208d425c5" target="_blank" rel="noopener">commit</a>。</p><p><img src="https://tobyqin.github.io/images/image-20200214183013735.png" alt="image-20200214183013735"></p><h2 id="部署白屏，回滚"><a href="#部署白屏，回滚" class="headerlink" title="部署白屏，回滚"></a>部署白屏，回滚</h2><p>本地测试完全没问题，推到Github后打开一下，懵逼了，也没显示正常但是看不见任何文字。</p><p><img src="https://tobyqin.github.io/images/image-20200215113446861.png" alt="image-20200215113446861"></p><p>从源码和CSS看都是正常的，眼睛就是看不见，换了浏览器也不行，查了半天，还以为是Cloudflare的问题，因为发现走Cloudflare后所有的Script标签都被加上了一串随机字符串，这是和本地生成的主页diff。</p><p><img src="https://tobyqin.github.io/images/image-20200215113752742.png" alt="image-20200215113752742"></p><p>得到的结论是这个随机字符对Script标签没影响，因为后面我回滚后的Script标签页会加上随机码，但不影响显示。</p><ul><li><a href="https://magento.stackexchange.com/questions/271062/some-unwanted-random-values-appending-in-script-tag" target="_blank" rel="noopener">https://magento.stackexchange.com/questions/271062/some-unwanted-random-values-appending-in-script-tag</a></li><li><a href="https://generatepress.com/forums/topic/random-string-in-script-tag/" target="_blank" rel="noopener">https://generatepress.com/forums/topic/random-string-in-script-tag/</a></li></ul><p>是不是我改坏了？试着把原版的Next7主题恢复再部署一次，还是白屏。又查了2小时，放弃吧。</p><p>我先回滚了，太费时间。回滚到旧版，显示正常。</p><h2 id="解决问题，还是Cloudflare"><a href="#解决问题，还是Cloudflare" class="headerlink" title="解决问题，还是Cloudflare"></a>解决问题，还是Cloudflare</h2><p>最后突然想到是不是主题本身有问题？去到Github的Issue里找了一圈，果然：</p><ul><li><a href="https://github.com/theme-next/hexo-theme-next/issues/1147" target="_blank" rel="noopener">在同时开启CloudFlare的Rocket Loader和PJAX后，页面异常</a></li></ul><p>解决问题的方法：</p><ol><li>登录Cloudflare，选中网站</li><li>Speed功能块，Optimization里找到Rocket Loader</li><li>关闭后等2分钟，刷新页面，正常了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> cloudflare </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的history命令</title>
      <link href="posts/2020-02-12/history-command-in-linux/"/>
      <url>posts/2020-02-12/history-command-in-linux/</url>
      
        <content type="html"><![CDATA[<p><code>history</code>是用来显示命令历史的命令。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@aml:~# history </span><br><span class="line">    1  which git</span><br><span class="line">    2  cd &#x2F;</span><br><span class="line">    3  ls -l</span><br><span class="line">    4  ifconfig</span><br><span class="line">    5  alias</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ol><li>默认记忆1000个历史，这些命令保存在家目录的<code>~/.bash_history</code>里。</li><li><code>history #</code>列出最近的<code>#</code>条命令，例如 <code>history 5</code></li><li><code>history -c</code>会将当前shell里的命令历史记录。</li><li><code>history -d #</code>会删除第<code>#</code>条历史命令，例如<code>history -d 10</code>删除第10条历史。</li><li><code>history -w</code>会将当前shell里的命令历史写进 <code>.bash_history</code>，注销后也会自动写入。</li><li><code>!#</code>用来执行第<code>#</code>条命令，例如<code>!5</code>就是执行第5条历史命令。</li><li><code>!-#</code>用来执行倒数第<code>#</code>条命令，例如<code>!-2</code>就是执行倒数第2条命令。</li><li><code>!command</code>用来执行<strong>最近历史</strong>里的以<code>command</code>开头的命令，例如<code>!ls</code>会执行最近的<code>ls</code>命令包括参数。</li><li><code>!!</code> 用来执行上一条历史命令。</li><li><code>!$</code>可以取到上一条命令的参数，假如刚刚执行完<code>vi hello.txt</code>再 <code>cat !$</code> ，等同于 <code>cat hello.txt</code>。</li><li><code>echo &quot;export $HISTSIZE=500&quot; &gt;&gt; /etc/profile</code> 修改当前shell缓存的历史上限。</li><li><code>echo &quot;export $HISTFILE=~/.history&quot; &gt;&gt; /etc/profile</code> 修改保存历史的文件名字。</li><li><code>echo &quot;export $HISTFILESIZE=1000&quot; &gt;&gt; /etc/profile</code> 修改最大保存历史命令上限。</li><li><code>echo &quot;export HISTTIMEFORMAT=&#39;%F %T&quot; &gt;&gt; /etc/profile</code> 修改历史文件的内容格式，带上时间戳。</li><li>以上修改需要 <code>source /etc/profile</code>才能生效，不过更建议修改个人目录下的 <code>.bash_profile</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的任务管理器</title>
      <link href="posts/2020-02-12/linux-task-manager/"/>
      <url>posts/2020-02-12/linux-task-manager/</url>
      
        <content type="html"><![CDATA[<p>在Linux中有一个命令叫<code>top</code>，作用和Windows下的任务管理器差不多。</p><a id="more"></a><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top - 15:43:06 up 3 days, 17:46,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 159 total,   1 running,  97 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.2 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.1 hi,  0.1 si,  0.0 st</span><br><span class="line">KiB Mem :  1882540 total,   323160 free,   691364 used,   868016 buff&#x2F;cache</span><br><span class="line">KiB Swap:   941268 total,   896468 free,    44800 used.  1082664 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    </span><br><span class="line">21090 root      20   0    8060   3432   2824 R   2.0  0.2   0:00.23 top        </span><br><span class="line">    1 root      20   0  157808   5764   4300 S   0.0  0.3  10:06.43 systemd    </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.64 kthreadd   </span><br><span class="line">    3 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 rcu_gp     </span><br><span class="line">    4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 rcu_par_gp </span><br><span class="line">    6 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker&#x2F;0+ </span><br><span class="line">    8 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu+ </span><br><span class="line">    9 root      20   0       0      0      0 S   0.0  0.0   0:09.23 ksoftirqd+ </span><br><span class="line">   10 root      20   0       0      0      0 I   0.0  0.0   0:22.27 rcu_preem+ </span><br><span class="line">   11 root      rt   0       0      0      0 S   0.0  0.0   0:00.64 migration+ </span><br><span class="line">   12 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp&#x2F;0    </span><br><span class="line">   13 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp&#x2F;1</span><br></pre></td></tr></table></figure><p><code>top</code> 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。</p><ul><li><p>第 1 行：系统时间、运行时间、登录终端数、系统负载(三个数值分别为 1 分钟、5 分钟、15 分钟内的平均值，数值越小意味着负载越低)。跟直接敲<code>uptime</code>是一样的结果。</p></li><li><p>第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</p></li><li><p>第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</p></li><li><p>第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p></li><li><p>第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p></li><li><p>第6行之后：就是任务列表了。</p></li></ul><h2 id="如果要对任务排序怎么办？"><a href="#如果要对任务排序怎么办？" class="headerlink" title="如果要对任务排序怎么办？"></a>如果要对任务排序怎么办？</h2><p>比如按内存排序，找出最占内存的任务。</p><ol><li>可以在<code>top</code>命令后面跟上排序的参数，比如：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Mac OCX</span><br><span class="line">top -o MEM</span><br><span class="line"># Others</span><br><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure><ol start="2"><li>也可以使用交互模式。<ol><li>直接按组合键：<code>shift</code> + <code>m</code></li><li>或者：先按<code>shift</code>+<code>f</code>，进入列调整视图，用方向键选择你要排序的列，按<code>s</code>用这一列排序，回车保存，按<code>q</code>回到任务视图。（列视图中还可用空格键来调整要显示的列）</li><li>在主界面还保留了一些快捷排序的快捷键，比如：<ol><li>M，内存排序，跟<code>shift+m</code>一样</li><li>N，PID排序</li><li>P，%CPU排序</li><li>T，TIME+排序，CPU使用时间</li></ol></li></ol></li></ol><p>另外提一下，MacOSX里的top看上去虽然和Linux的差不多，但很多指令是不通用的。</p><h2 id="如果要查找某些任务怎么办？"><a href="#如果要查找某些任务怎么办？" class="headerlink" title="如果要查找某些任务怎么办？"></a>如果要查找某些任务怎么办？</h2><ol><li>用方向键可以滚屏（上下左右都可以，page up down 也可以），人肉搜索</li><li><code>top</code>后面用管道加<code>grep</code>，比如 <code>top | grep httpd</code></li><li>用交互模式，按<code>shift</code>+<code>l</code>(Locate)，然后输入搜索的字符，回车。按<code>&amp;</code>搜索下一匹配处。</li></ol><p><img src="https://tobyqin.github.io/images/image-20200212202516163.png" alt="image-20200212202516163"></p><h2 id="如果要过滤某些任务怎么办？"><a href="#如果要过滤某些任务怎么办？" class="headerlink" title="如果要过滤某些任务怎么办？"></a>如果要过滤某些任务怎么办？</h2><p>比如只显示<code>root</code>的任务或者某些<code>PID</code>的任务。</p><ol><li><code>top</code>启动时可以对用户进行过滤，比如 <code>top -u root</code></li><li>用<code>grep</code>可以解决一些问题，比如 <code>top | grep root</code></li><li>用交互模式，按小写<code>o</code>然后输入你要过滤的条件，比如<code>USER=root</code>, <code>PID&lt;40</code> ，<code>!USER=root</code>等等，此时大小写是不敏感的，如果按大写<code>O</code>大小写就是敏感的。貌似没办法部分匹配，按<code>=</code>可以重置过滤条件。</li></ol><p><img src="https://tobyqin.github.io/images/image-20200212204136480.png" alt="image-20200212204136480"></p><h2 id="如果要杀掉某些任务怎么办？"><a href="#如果要杀掉某些任务怎么办？" class="headerlink" title="如果要杀掉某些任务怎么办？"></a>如果要杀掉某些任务怎么办？</h2><p>直接按<code>k</code>就好了，首先会让你输入<code>PID</code>，然后再输入<code>SIG</code>，回车搞定。</p><p><img src="https://tobyqin.github.io/images/image-20200212210832677.png" alt="image-20200212210832677"></p><p>顺便备注一下<code>SIG</code>的参考值：</p><pre><code>HUP     1     终端断线INT     2     中断（同 Ctrl + C）QUIT    3     退出（同 Ctrl + \）TERM    15    终止KILL    9     强制终止CONT    18    继续（与STOP相反， fg/bg命令）STOP    19    暂停（同 Ctrl + Z）</code></pre><h2 id="这鬼东西还有什么功能？"><a href="#这鬼东西还有什么功能？" class="headerlink" title="这鬼东西还有什么功能？"></a>这鬼东西还有什么功能？</h2><p>看文档吧，这鬼东西文档写了好几十页，功能太TM多了，两个核心命令：</p><ol><li><code>man top</code>：在没进入top前你想要知道的一切都在这。</li><li><code>?</code> 或者 <code>h</code>：在你进入top之后，这两个按键都可以给你交互方面的指导。</li></ol><p>如果你想要更接近UI的任务管理，试一下<code>htop</code>吧，可以上下左右，还有快捷键写在功能旁边，新款的Linux都原生支持<code>htop</code>。</p><p><img src="https://tobyqin.github.io/images/image-20200212211906608.png" alt="image-20200212211906608"></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
            <tag> top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各平台免费翻译API</title>
      <link href="posts/2020-02-10/the-platform-api-free-translation/"/>
      <url>posts/2020-02-10/the-platform-api-free-translation/</url>
      
        <content type="html"><![CDATA[<p>收集一下，用的上。</p><a id="more"></a><h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><blockquote><p><a href="https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=zh_CN&amp;q=hello" target="_blank" rel="noopener">https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=zh_CN&amp;q=hello</a></p><p><a href="https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=en_US&amp;q=你好" target="_blank" rel="noopener">https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=en_US&amp;q=你好</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"sentences"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"trans"</span>: <span class="string">"你好"</span>,</span><br><span class="line">            <span class="string">"orig"</span>: <span class="string">"hello"</span>,</span><br><span class="line">            <span class="string">"backend"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"en"</span>,</span><br><span class="line">    <span class="string">"confidence"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"spell"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"ld_result"</span>: &#123;</span><br><span class="line">        <span class="string">"srclangs"</span>: [</span><br><span class="line">            <span class="string">"en"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"srclangs_confidences"</span>: [</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"extended_srclangs"</span>: [</span><br><span class="line">            <span class="string">"en"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BING必应"><a href="#BING必应" class="headerlink" title="BING必应"></a>BING必应</h2><blockquote><p><a href="https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=zh&amp;text=hello" target="_blank" rel="noopener">https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=zh&amp;text=hello</a></p><p><a href="https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=en&amp;text=你好" target="_blank" rel="noopener">https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=en&amp;text=你好</a></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/2003/10/Serialization/"</span>&gt;</span>How are you doing<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Youdao有道"><a href="#Youdao有道" class="headerlink" title="Youdao有道"></a>Youdao有道</h2><blockquote><p><a href="https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=hello" target="_blank" rel="noopener">https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=hello</a></p><p><a href="https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=你好" target="_blank" rel="noopener">https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=你好</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"ZH_CN2EN"</span>,</span><br><span class="line">    <span class="string">"errorCode"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"elapsedTime"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"translateResult"</span>: [</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"src"</span>: <span class="string">"你好"</span>,</span><br><span class="line">                <span class="string">"tgt"</span>: <span class="string">"hello"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZH_CN2EN 中文　 　英语 </span><br><span class="line">ZH_CN2JA 中文　 　日语 </span><br><span class="line">ZH_CN2KR 中文　 　韩语 </span><br><span class="line">ZH_CN2FR 中文　 　法语 </span><br><span class="line">ZH_CN2RU 中文　 　俄语 </span><br><span class="line">ZH_CN2SP 中文　 　西语 </span><br><span class="line">EN2ZH_CN 英语　 　中文 </span><br><span class="line">JA2ZH_CN 日语　 　中文 </span><br><span class="line">KR2ZH_CN 韩语　 　中文 </span><br><span class="line">FR2ZH_CN 法语　 　中文 </span><br><span class="line">RU2ZH_CN 俄语　 　中文 </span><br><span class="line">SP2ZH_CN 西语　 　中文</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> free </tag>
            
            <tag> api </tag>
            
            <tag> translator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐讯N1的折腾之路</title>
      <link href="posts/2020-02-09/feixun-n1s-road-of-twists-and-turns/"/>
      <url>posts/2020-02-09/feixun-n1s-road-of-twists-and-turns/</url>
      
        <content type="html"><![CDATA[<p>N1买了又一段时间了，最开始卖家刷的是yyf电视系统，用的不是很满意。</p><a id="more"></a><p>后来自己又重新刷了wepad的电视系统，播放和界面各方面都挺满意的，可是投屏的时候总掉线，然后就丢一边吃灰了。目前用天猫盒子投屏，虽然平时有广告也有点卡，但是投屏很稳定，从来没掉过，稳定性压倒一切啊。</p><h2 id="刷成Armbian"><a href="#刷成Armbian" class="headerlink" title="刷成Armbian"></a>刷成Armbian</h2><p>很早就想废物利用把这个盒子刷成Armbian，当个小型Linux服务器用用，网上资料比较乱所以一直没行动。这两天把它搞定了。</p><h3 id="第一步：降级解锁bootloader"><a href="#第一步：降级解锁bootloader" class="headerlink" title="第一步：降级解锁bootloader"></a>第一步：降级解锁bootloader</h3><p>这一步一般你的盒子如果已经刷过别的系统，就已经做掉了，除非你是全新的N1并且还带着原生的系统，否则就不需要了。</p><p>怎么降级： <a href="https://www.right.com.cn/forum/thread-340279-1-1.html" target="_blank" rel="noopener">https://www.right.com.cn/forum/thread-340279-1-1.html</a></p><p>刷电视盒子的固件一般都是需要双公头的USB线的，找不用的USB线自己剪一下然后接起来就可以，不一定要去网上买。</p><h3 id="第二步：准备启动U盘"><a href="#第二步：准备启动U盘" class="headerlink" title="第二步：准备启动U盘"></a>第二步：准备启动U盘</h3><p>大致思路：准备一个大于8G的U盘，准备可以刷镜像进U盘的工具，刷镜像，修改dtb。</p><ol><li>准备一个U盘，不一定需要USB3.0，因为N1是USB2.0的接口。</li><li>刷U盘的工具叫USB Image Tool，需要Windows系统。</li><li>镜像在恩山论坛可以下各种版本的，最稳定的据说是 5.77</li></ol><p><img src="https://tobyqin.github.io/images/2020-02/2019-01-23_14-50-16.jpg" alt="usb"></p><p>刷机图如上，打开USB Image Tool，选择你的U盘，点击Restore后选择镜像，等待结束即可。</p><blockquote><p>USB Image Tool下载：<a href="https://cnone.lty.fun/home/工具库/N1" target="_blank" rel="noopener">N1工具库</a></p></blockquote><p>其实，刷U盘镜像还有很多工具可以用，比如单文件版<code>rufus</code>，或者用Linux下的<code>dd</code>命令，MacOSX应该也有功能类似的软件。如果觉得U盘空间太小，还可以用<code>etcher</code>把Armbian写到移动硬盘上。</p><blockquote><p>Armbian镜像网盘下载：<a href="https://pan.baidu.com/s/1-7AmPhRkP1LKtqb6X7s9IA" target="_blank" rel="noopener">https://pan.baidu.com/s/1-7AmPhRkP1LKtqb6X7s9IA</a> 提取码: sjp9 </p></blockquote><p><strong>修改dtb</strong></p><p>这一步一般是必要的，但看情况。<code>dtb</code>文件可以理解成驱动文件，Armbian默认会有一套驱动文件，但不完全适配N1，导致硬件不正常或者负载过高。所以论坛上就有大神对N1的<code>dtb</code>进行了优化，你只需要下载并加载他们的<code>dtb</code>即可。</p><p>大致方法如下：</p><ol><li>U盘烧录镜像完毕后，Boot分区（U盘的根目录）允许访问。</li><li>将下载好的<code>dtb</code>放入到U盘的<code>dtb</code>目录。</li><li>U盘根目录有一个<code>nEnv.ini</code>文件，里面写了使用哪个<code>dtb</code></li><li>修改<code>nEnv.ini</code>指向刚才拷贝进来的<code>dtb</code>。</li></ol><p><img src="https://tobyqin.github.io/images/2020-02/2019-01-23_14-57-02.jpg" alt="uEnv.ini"></p><p>Armbian 5.77 的<code>dtb</code>可以用恩山论坛大神提供的，据说稳定性不错：</p><ul><li><a href="https://www.right.com.cn/forum/thread-510423-1-1.html" target="_blank" rel="noopener">https://www.right.com.cn/forum/thread-510423-1-1.html</a></li></ul><p>修改后的<code>eEnv.ini</code>长这样，注意看第一行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dtb_name&#x3D;&#x2F;dtb&#x2F;meson-gxl-s905d-phicomm-n1-xiangsm.dtb</span><br><span class="line">bootargs&#x3D;root&#x3D;LABEL&#x3D;ROOTFS rootflags&#x3D;data&#x3D;writeback rw console&#x3D;ttyAML0,115200n8 console&#x3D;tty0 no_console_suspend consoleblank&#x3D;0 fsck.fix&#x3D;yes fsck.repair&#x3D;yes net.ifnames&#x3D;0</span><br></pre></td></tr></table></figure><p>如果你下载的镜像作者已经说了不需要改<code>dtb</code>和<code>nEnv.ini</code>，那么这一步就不需要做了。驱动不正确的后果就是某些硬件工作不正常，所以还是需要谨慎对待。</p><p>另外<code>uEnv.ini</code>文件<strong>不能用Windows记事本编辑</strong>，因为它的换行符在Linux下也会识别错误，需要用Notepad++或者VsCode等软件来处理。</p><p>到此为止，你的U盘准备好了。刷其他系统的思路大致是一样的，搞定U盘就搞定了大半。</p><p><strong>特别提醒</strong></p><p>在没完成从U盘启动的工作前，不要在N1通电的情况下提前插入U盘，Android系统会修改U盘文件的权限，导致Armbian后期出现各种诡异的问题。</p><h3 id="第三步：从U盘启动N1"><a href="#第三步：从U盘启动N1" class="headerlink" title="第三步：从U盘启动N1"></a>第三步：从U盘启动N1</h3><p>确保你的N1刷了可以从U盘启动的系统，没有的话回到第一步，去刷wepad的固件。</p><p>之后在局域网内任意一台电脑上通过adb去让N1从U盘启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect &lt;N1的IP，从路由器看&gt;</span><br><span class="line">adb shell reboot update</span><br></pre></td></tr></table></figure><p>命令敲完，N1黑屏后就可以拔掉电源，然后把U盘插到靠近HDMI的USB口，再接上电源就可以进入Armbian系统。用<code>root</code>和密码<code>1234</code>登录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ____  ___   ___  ____</span><br><span class="line">&#x2F; ___|&#x2F; _ \ &#x2F; _ \| ___|</span><br><span class="line">\___ \ (_) | | | |___ \</span><br><span class="line"> ___) \__, | |_| |___) |</span><br><span class="line">|____&#x2F;  &#x2F;_&#x2F; \___&#x2F;|____&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Welcome to ARMBIAN 5.77 user-built Debian GNU&#x2F;Linux 9 (stretch) 5.0.2-aml-s905</span><br><span class="line">System load:   0.01 0.01 0.00  Up time:       17:03 hours</span><br><span class="line">Memory usage:  11 % of 1838MB IP:            169.254.5.171 192.168.1.116</span><br><span class="line">CPU temp:      35°C</span><br><span class="line">Usage of &#x2F;:    31% of 6.9G   storage&#x2F;:      44% of 128M</span><br></pre></td></tr></table></figure><p>这时候可以用<code>ls -l</code>命令确认一下U盘的目录权限没有被安卓修改，都是<code>root</code>就是对的，如果有错那么你要回去重新刷一下U盘了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@aml:~# ls -l /</span><br><span class="line">total 84</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 bin</span><br><span class="line">drwxr-xr-x   6 root root 16384 Jan  1  1970 boot</span><br><span class="line">drwxr-xr-x  17 root root  4100 Oct 22 21:46 dev</span><br><span class="line">drwxr-xr-x  87 root root  4096 Oct 23 02:01 etc</span><br><span class="line">drwxr-xr-x   2 root root  4096 Feb  3  2019 home</span><br><span class="line">drwxr-xr-x  17 root root  4096 Apr  1  2019 lib</span><br><span class="line">drwx------   2 root root 16384 Oct 22 20:17 lost+found</span><br><span class="line">drwxr-xr-x   2 root root  4096 Oct 22 20:18 media</span><br><span class="line">drwxr-xr-x   2 root root  4096 Oct 22 20:18 mnt</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 opt</span><br><span class="line">dr-xr-xr-x 137 root root     0 Jan  1  1970 proc</span><br><span class="line">drwx------   5 root root  4096 Oct 23 10:12 root</span><br><span class="line">drwxr-xr-x  20 root root   700 Oct 23 11:04 run</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 sbin</span><br><span class="line">drwxrwxr-x   2 root root  4096 Apr  1  2019 selinux</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 srv</span><br><span class="line">dr-xr-xr-x  12 root root     0 Jan  1  1970 sys</span><br><span class="line">drwxrwxrwt   7 root root   160 Oct 23 12:00 tmp</span><br><span class="line">drwxr-xr-x  10 root root  4096 Apr  1  2019 usr</span><br><span class="line">drwxr-xr-x  12 root root  4096 Apr  1  2019 var</span><br></pre></td></tr></table></figure><p>如果U盘一直插在盒子上，以后启动就默认进入Armbian系统。U盘拔掉后启动的就是电视系统，想再次进入Armbian只需要重复这一步骤即可。</p><h3 id="第四步：将Armbian刷到盒子里"><a href="#第四步：将Armbian刷到盒子里" class="headerlink" title="第四步：将Armbian刷到盒子里"></a>第四步：将Armbian刷到盒子里</h3><p>首先说，这一步不是必要的。在U盘运行Armbian和在盒子里运行性能是差不多的，除非你：</p><ol><li>要腾出U盘做的别的事情</li><li>使用盒子上的USB口，比如连接额外的硬盘</li></ol><p>将系统刷入盒子（emmc：可以理解成N1自带的硬盘）很简单，只需要一行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nand-sata-install</span><br></pre></td></tr></table></figure><p>这行命令敲完之后，再敲一下 <code>halt</code>关机，然后拔掉U盘。以后通电就进入Armbian，就再也不用U盘了。</p><p><strong>备注</strong></p><p>不要使用<code>/root/install.sh</code>，据说有bug，用这个脚本的话刷emmc后第一次可以成功启动，再以后启动就会失败。还是据说，修复的方式就是插上前面的U盘去启动Armbian，用<code>nand-sata-install</code> 重新将系统刷入emmc（完全覆盖）即可。我没试过，写在这备忘。</p><p>U盘的Armbian功能并没有缩减，除非你运行的软件一定要系统跑在emmc，否则没必要刷到盒子里。</p><h2 id="Armbian的基本配置"><a href="#Armbian的基本配置" class="headerlink" title="Armbian的基本配置"></a>Armbian的基本配置</h2><p>第一步肯定是联网了，如果你已经插了网线应该自动连上网了。但如果需要Wifi的话，使用<code>umtui</code>命令即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>这个命令敲完会出来一个简单的ui，用键盘方向键就可以选择和配置你的网路。</p><p><img src="https://tobyqin.github.io/images/image-20200209151347103.png" alt="image-20200209151347103"></p><p>其实Armbian还是很易用的，你登录的时候它就提醒你了可以用<code>armbian-config</code>去配置Armbian。</p><p><img src="https://tobyqin.github.io/images/image-20200209151648670.png" alt="image-20200209151648670"></p><p>敲一下这个命令，你就会发现另外一片天地。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">armbian-config</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20200209151755721.png" alt="image-20200209151755721"></p><p>在这里你可以配置很多东西：</p><ol><li>最基本的网络，Wifi，蓝牙，热点等</li><li>中文显示 <code>Personal / Locales</code></li><li>时区  <code>Personal / Timezone</code></li><li>软件源镜像 <code>Personal / Mirror</code></li></ol><p>这里也不是万能的，有两个小问题需要注意。</p><p>一，需要在ssh中输入中文的话，还需要修改 <code>/etc/environment</code> 下的 <code>LC_ALL</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@aml:~# cat &#x2F;etc&#x2F;environment</span><br><span class="line">ARCH&#x3D;arm64</span><br><span class="line">LC_ALL&#x3D;”en_US.utf-8″</span><br></pre></td></tr></table></figure><p>二，需要彻底换软件源的话，还需要修改 <code>/etc/apt/sources/list</code>，替换内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">deb http://httpredir.debian.org/debian stretch main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://httpredir.debian.org/debian stretch main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">deb http://httpredir.debian.org/debian stretch-updates main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://httpredir.debian.org/debian stretch-updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">deb http://httpredir.debian.org/debian stretch-backports main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://httpredir.debian.org/debian stretch-backports main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">deb http://security.debian.org/ stretch/updates main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://security.debian.org/ stretch/updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stretch main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stretch-updates main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stretch-backports main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free</span><br></pre></td></tr></table></figure><p>修改完之后，执行更新命令更新索引。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade -y</span><br></pre></td></tr></table></figure><p>前面从<code>armbian-config</code>里更新的镜像源应该是<code>/etc/apt/sources.list.d/armbian.list</code>里的。</p><p>如果需要在vim下使用右键粘贴，需要修改一下模式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/share/vim/vim80/defaults.vim</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找 <span class="built_in">set</span> mouse</span></span><br><span class="line">if has('mouse')</span><br><span class="line">  set mouse=a</span><br><span class="line">endif</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将值从<span class="string">"a"</span>改成<span class="string">"r"</span></span></span><br><span class="line">if has('mouse')</span><br><span class="line">  set mouse=r</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>如果需要启用BBR，可以在<code>/etc/sysctl.conf</code>末尾加上两行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.core.default_qdisc&#x3D;fq</span><br><span class="line">net.ipv4.tcp_congestion_control&#x3D;bbr</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h2 id="Armbian-的后续"><a href="#Armbian-的后续" class="headerlink" title="Armbian 的后续"></a>Armbian 的后续</h2><p>到此为止，你的N1已经是一个可以独立运行的小型Linux主机，连上Wifi后找个插座就可以7x24小时运行了。它的性能如何呢？</p><blockquote><p>ARM64主流架构，真64位linux系统，docker随便玩。</p><p>（Armbian输出：Linux aml 5.0.2-aml-s905 #5.77 SMP PREEMPT Mon Apr 1 17:41:33 MSK 2019 aarch64 GNU/Linux）</p><p>真千兆有线网口，2.4/5G双频wifi，可以作热点。</p><p>自带8G的emmc存储，Linux系统可以直接刷到盒子里，不用额外插SD卡，I/O性能好。</p><p>CPU 4核，2G内存。</p></blockquote><p>其实还是蛮强的，用下面几个命令可以查看它的具体参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@aml:~# cat /proc/cpuinfo</span><br><span class="line">...</span><br><span class="line">root@aml:~# cat /proc/meminfo</span><br><span class="line">...</span><br><span class="line">root@aml:~# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1.8G        200M        867M         20M        770M        1.5G</span><br><span class="line">Swap:          919M        4.5M        914M</span><br><span class="line"></span><br><span class="line">root@aml:~# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            469M     0  469M   0% /dev</span><br><span class="line">tmpfs           184M   22M  163M  12% /run</span><br><span class="line">/dev/sda2       6.9G  2.1G  4.8G  31% /</span><br><span class="line">tmpfs           920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           920M   16K  920M   1% /tmp</span><br><span class="line">/dev/sda1       128M   56M   73M  44% /boot</span><br><span class="line">/dev/zram0       49M   14M   32M  30% /var/log</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>在Armbian上安装软件也是非常简单的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install cockpit</span><br></pre></td></tr></table></figure><p>Cockpit是一个Linux服务器的Web管理程序，简单易用。</p><p><img src="https://tobyqin.github.io/images/image-20200209154517563.png" alt="image-20200209154517563"></p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>装个Docker也是手到擒来的事情：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p>注意上面的命令用了阿里云的加速服务。Docker安装完成后Docker镜像的拉取也要加速一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors": ["https://加速镜像地址"]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>我们来安装个Portainer。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d -p 9000:9000 --name portainer \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data portainer/portainer:linux-arm64</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20200209160349534.png" alt="image-20200209160349534"></p><p>让Portainer开机自动运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker update --restart=always portainer</span><br></pre></td></tr></table></figure><p>注意，Armbian下的软件都是Arm架构的，包括Docker镜像，所以在安装前需要甄别一下。</p><h3 id="安装LAMP"><a href="#安装LAMP" class="headerlink" title="安装LAMP"></a>安装LAMP</h3><p>LNMP是Linux+Nginx+MySQL+PHP组合缩写，可以认为是Linux Web服务器的黄金套件。</p><ul><li>官网：<a href="https://lnmp.org/" target="_blank" rel="noopener">https://lnmp.org/</a></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@aml:~/lnmp1.6<span class="comment"># wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; cd lnmp1.6 &amp;&amp; ./install.sh lnmp</span></span><br><span class="line">...</span><br><span class="line">============================== Check install ==============================</span><br><span class="line">Checking ...</span><br><span class="line">Nginx: OK</span><br><span class="line">MySQL: OK</span><br><span class="line">PHP: OK</span><br><span class="line">PHP-FPM: OK</span><br><span class="line">Clean Web Server src directory...</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|          LNMP V1.6 <span class="keyword">for</span> Debian Linux Server, Written by Licess          |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|           For more information please visit https://lnmp.org           |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|    lnmp status manage: lnmp &#123;start|stop|reload|restart|<span class="built_in">kill</span>|status&#125;    |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|  phpMyAdmin: http://IP/phpmyadmin/                                     |</span><br><span class="line">|  phpinfo: http://IP/phpinfo.php                                        |</span><br><span class="line">|  Prober:  http://IP/p.php                                              |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|  Add VirtualHost: lnmp vhost add                                       |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|  Default directory: /home/wwwroot/default                              |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|    Manager <span class="keyword">for</span> LNMP, Written by Licess    |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|              https://lnmp.org             |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">nginx (pid 1340) is running...</span><br><span class="line">php-fpm is runing!</span><br><span class="line">● mysql.service - LSB: start and stop MySQL</span><br><span class="line">   Loaded: loaded (/etc/init.d/mysql; generated; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Sun 2020-02-09 22:58:55 CST; 3s ago</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line">      CPU: 16ms</span><br><span class="line">   CGroup: /system.slice/mysql.service</span><br><span class="line">           ├─1380 /bin/sh /usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe --datadir=/usr/<span class="built_in">local</span>/mysql/var --pid-file=/usr/<span class="built_in">local</span>/mysql/var/aml.pid</span><br><span class="line">           └─1880 /usr/<span class="built_in">local</span>/mysql/bin/mysqld --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/usr/<span class="built_in">local</span>/mysql/var --plugin-dir=/usr/<span class="built_in">local</span>/mysql/lib/plugin --user=mysql --<span class="built_in">log</span>-error=aml.err --open-files-limit=65535 --pid-file=/usr/<span class="built_in">local</span>/mysql/var/aml.pid --socket=/tmp/mysql.sock --port=3306</span><br><span class="line">           </span><br><span class="line">Feb 09 22:58:36 aml systemd[1]: Starting LSB: start and stop MySQL...</span><br><span class="line">Feb 09 22:58:37 aml mysql[1367]: Starting MySQL</span><br><span class="line">Feb 09 22:58:55 aml mysql[1367]: ...................</span><br><span class="line">Feb 09 22:58:55 aml systemd[1]: Started LSB: start and stop MySQL.</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              </span><br><span class="line">LISTEN     0      50           *:3306                     *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:22                       *:*                  </span><br><span class="line">LISTEN     0      128         :::9090                    :::*                  </span><br><span class="line">LISTEN     0      128         :::9000                    :::*                  </span><br><span class="line">LISTEN     0      128         :::22                      :::*                  </span><br><span class="line">Install lnmp takes 180 minutes.</span><br><span class="line">Install lnmp V1.6 completed! enjoy it.</span><br></pre></td></tr></table></figure><p>可能N1性能和LNMP期望值不一样，安装花了3个小时。</p><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>如果想从外网访问你的N1服务器，就需要使用内网穿透技术了，之前我有写过<a href="/posts/2019-02-22/reverse-proxy-and-intranet-through/">反向代理和内网穿透</a>，换汤不换药，我们需要frp。</p><ul><li>官网：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></li></ul><p>大致思路：</p><ol><li>下载和frp服务器对应的客户端版本，使用arm64架构</li><li>准备frp的配置文件手动测试成功</li><li>创建frp自启服务，让frp长期在后台运行</li></ol><p>前面两步需要比较多的调试时间，但操作都比较简单，有机会我再补充。创建自启服务的内容备忘一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/frpc.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Frp Client Service</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">ExecStart=/usr/local/frp_0.27.0/frpc -c /usr/local/frp_0.27.0/frpc.ini</span><br><span class="line">ExecReload=/usr/local/frp_0.27.0/frpc reload -c /usr/local/frp_0.27.0/frpc.ini</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">systemctl start frpc # 启动客户端</span><br><span class="line">systemctl status frpc # 检查状态</span><br><span class="line">systemctl enable frpc # 开机自启</span><br></pre></td></tr></table></figure><h3 id="更多玩法"><a href="#更多玩法" class="headerlink" title="更多玩法"></a>更多玩法</h3><ol><li><a href="https://www.right.com.cn/forum/thread-1347921-1-1.html" target="_blank" rel="noopener">Armbian下Docker安装OpenWrt做旁路由</a></li><li><a href="https://www.right.com.cn/forum/thread-343169-1-1.html" target="_blank" rel="noopener">Armbian下Docker做Web 服务器</a></li><li><a href="https://yuerblog.cc/2019/10/23/%e6%96%90%e8%ae%afn1-%e5%88%a9%e7%94%a8redsocksss%e5%ae%9e%e7%8e%b0%e5%85%a8%e5%b1%80%e7%bf%bb%e5%a2%99/" target="_blank" rel="noopener">Armbian下的全局科学上网</a></li><li><a href="https://luotianyi.vc/2936.html" target="_blank" rel="noopener">Armbian下的宝塔面板配置</a></li><li><a href="https://instar.me/archives/398960e0.html" target="_blank" rel="noopener">https://instar.me/archives/398960e0.html</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://luotianyi.vc/1306.html" target="_blank" rel="noopener">https://luotianyi.vc/1306.html</a></li><li><a href="https://luotianyi.vc/1389.html" target="_blank" rel="noopener">https://luotianyi.vc/1389.html</a></li><li><a href="https://yuerblog.cc/2019/10/23/%e6%96%90%e8%ae%afn1-%e5%ae%8c%e7%be%8e%e5%88%b7%e6%9c%baarmbian%e6%95%99%e7%a8%8b/" target="_blank" rel="noopener">N1 完美刷Armbian教程</a></li><li><a href="https://www.right.com.cn/forum/thread-510423-1-1.html" target="_blank" rel="noopener">Armbian 5.77 刷机指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> N1 </tag>
            
            <tag> Armbian </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费的FRP服务器</title>
      <link href="posts/2020-02-09/frp-server-for-free/"/>
      <url>posts/2020-02-09/frp-server-for-free/</url>
      
        <content type="html"><![CDATA[<p>目前网上还是能找到免费的FRP服务器的，可以通过搜索引擎试试。</p><a id="more"></a><p>目前可以用的有一些：</p><ul><li><a href="http://www.frps.top/" target="_blank" rel="noopener">http://www.frps.top/</a></li><li><a href="https://www.chuantou.org/" target="_blank" rel="noopener">https://www.chuantou.org/</a></li><li><a href="https://www.natfrp.com/" target="_blank" rel="noopener">https://www.natfrp.com/</a></li><li><a href="http://freefrp.wlphp.com/" target="_blank" rel="noopener">http://freefrp.wlphp.com/</a></li><li><a href="https://freenat.ml/" target="_blank" rel="noopener">https://freenat.ml/</a></li></ul><p>稳定性和速度只能靠时间来考验了。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> frp </tag>
            
            <tag> free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux新建用户没有用户目录</title>
      <link href="posts/2020-02-09/linux-new-user-missed-home-directory/"/>
      <url>posts/2020-02-09/linux-new-user-missed-home-directory/</url>
      
        <content type="html"><![CDATA[<p>简而言之，用<code>adduser</code>而不是<code>useradd</code>，用<code>deluser</code>而不是<code>userdel</code>。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       adduser, addgroup - add a user or group to the system</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       adduser  [options] [--home DIR] [--shell SHELL] [--no-create-home] [--uid</span><br><span class="line">       ID] [--firstuid ID] [--lastuid ID] [--ingroup GROUP | --gid  ID]  [--dis‐</span><br><span class="line">       abled-password]  [--disabled-login]  [--gecos GECOS] [--add_extra_groups]</span><br><span class="line">       user</span><br><span class="line"></span><br><span class="line">       adduser --system [options] [--home  DIR]  [--shell  SHELL]  [--no-create-</span><br><span class="line">       home] [--uid ID] [--group | --ingroup GROUP | --gid ID] [--disabled-pass‐</span><br><span class="line">       word] [--disabled-login] [--gecos GECOS] user</span><br><span class="line"></span><br><span class="line">       addgroup [options] [--gid ID] group</span><br><span class="line"></span><br><span class="line">       addgroup --system [options] [--gid ID] group</span><br><span class="line"></span><br><span class="line">       adduser [options] user group</span><br></pre></td></tr></table></figure><p><code>useradd</code> 和 <code>userdel</code> 的尝试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd user1 # 不会创建home目录，没有回显</span><br><span class="line">useradd -m user2 # 会创建home目录，没有回显</span><br><span class="line"></span><br><span class="line">useradd -m user1 # 不会补充创建home目录，回显报错</span><br><span class="line">useradd: user 'user1' already exists</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过复制home模板补救，模板在/etc/skel，有时候也被叫做骨架目录</span></span><br><span class="line">cp /etc/skel/ /home/user1 -a</span><br><span class="line">chmod 700 /home/user1  #只有owner拥有所有所有权限</span><br><span class="line">chown user1:user1 /home/user1 -R # owner改成user1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给用户加密码</span></span><br><span class="line">passwd user1</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户</span></span><br><span class="line">userdel -r user1 # 删除用户相关所有资源，包括home目录</span><br><span class="line">userdel user2 # 保留home目录</span><br></pre></td></tr></table></figure><p>当然，如果误删除了用户的home目录可以可以用上面的方法来修复。关于<code>adduser</code>和<code>deluser</code>的尝试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@aml:~# adduser user3</span><br><span class="line">Adding user `user3' ...</span><br><span class="line">Adding new group `user3' (1002) ...</span><br><span class="line">Adding new user `user3' (1002) with group `user3' ...</span><br><span class="line">Creating home directory `/home/user3' ...</span><br><span class="line">Copying files from `/etc/skel' ...</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for user3</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []: </span><br><span class="line">        Room Number []: </span><br><span class="line">        Work Phone []: </span><br><span class="line">        Home Phone []: </span><br><span class="line">        Other []: </span><br><span class="line">Is the information correct? [Y/n]Y</span><br><span class="line"></span><br><span class="line">root@aml:~# deluser user3</span><br><span class="line">Removing user `user3' ...</span><br><span class="line">Warning: group `user3' has no more members.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>可以看到，<code>adduser</code>是交互式的，回显里有完整的信息，包括<code>home</code>目录的位置和复制模板的过程，还会让你创建密码和完善用户信息。</p><p><code>deluser</code>也差不多，告诉你删除了那些资源。</p><p>顺便备忘一下查看用户信息的命令。</p><ol><li>查看 <code>/etc/passwd</code> 文件</li><li>使用<code>getent passwd</code> 命令</li><li>使用 <code>compgen -u</code> 命令</li></ol><p><strong>参考：</strong></p><ul><li><a href="https://www.cnblogs.com/sogeisetsu/p/11401562.html" target="_blank" rel="noopener">linux使用useradd创建的用户没有目录的解决办法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看系统信息的命令</title>
      <link href="posts/2020-02-09/linux-view-system-information/"/>
      <url>posts/2020-02-09/linux-view-system-information/</url>
      
        <content type="html"><![CDATA[<p>查看Linux系统信息的一些技巧。</p><a id="more"></a><h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uname</span><br><span class="line">uname -a</span><br><span class="line">cat /etc/*-release <span class="comment"># 不同的发行版名字不太一样</span></span><br></pre></td></tr></table></figure><h2 id="查看CPU和内存"><a href="#查看CPU和内存" class="headerlink" title="查看CPU和内存"></a>查看CPU和内存</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br><span class="line">cat /proc/meminfo</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><h2 id="查看硬盘空间"><a href="#查看硬盘空间" class="headerlink" title="查看硬盘空间"></a>查看硬盘空间</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">du -sh /*</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uptime</span><br><span class="line">22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18</span><br><span class="line"> <span class="comment"># 当前时间+运行时间+当前登录用户数+最近1，5，15分钟的压力，越低越好，最好不要超过1</span></span><br></pre></td></tr></table></figure><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps aux</span><br><span class="line">top</span><br><span class="line">htop <span class="comment"># 需要安装</span></span><br><span class="line">pidof httpd <span class="comment"># 查看进程号，一个进程可能有多个进程号</span></span><br><span class="line"><span class="built_in">kill</span> 1234 <span class="comment"># 杀掉进程号1234</span></span><br><span class="line">killall httpd <span class="comment"># 杀掉一个进程</span></span><br></pre></td></tr></table></figure><h2 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig <span class="comment"># 显示网卡IP等</span></span><br><span class="line">netstat <span class="comment"># 显示网络状态</span></span><br></pre></td></tr></table></figure><h2 id="查看登录信息"><a href="#查看登录信息" class="headerlink" title="查看登录信息"></a>查看登录信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">whoami <span class="comment"># 当前用户名</span></span><br><span class="line">id <span class="comment"># 当前用户id以及组等信息</span></span><br><span class="line">who <span class="comment"># 当前登录在本机的用户</span></span><br><span class="line">last <span class="comment"># 系统曾经的登录信息</span></span><br></pre></td></tr></table></figure><h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env</span><br><span class="line">printenv # 功能和env一样</span><br><span class="line">env | sort # 排序</span><br></pre></td></tr></table></figure><h2 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">users <span class="comment"># 只显示可登录的用户名</span></span><br><span class="line">groups</span><br><span class="line">cat /etc/passwd <span class="comment"># 所有用户</span></span><br><span class="line">cat /etc/group <span class="comment"># 所有组</span></span><br><span class="line">getent passwd <span class="comment"># 等同于 cat /etc/passwd</span></span><br><span class="line">compgen -u <span class="comment"># 只显示 /etc/passwd 的第一列</span></span><br></pre></td></tr></table></figure><h2 id="查看所有可用命令"><a href="#查看所有可用命令" class="headerlink" title="查看所有可用命令"></a>查看所有可用命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># List all commands that you could run:</span></span><br><span class="line">compgen -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all aliases:</span></span><br><span class="line">compgen -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all functions that you could run:</span></span><br><span class="line">compgen -A <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show shell reserved key words:</span></span><br><span class="line">compgen -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check command location</span></span><br><span class="line"><span class="built_in">which</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>懒和蠢</title>
      <link href="posts/2020-02-08/lazy-and-stupid/"/>
      <url>posts/2020-02-08/lazy-and-stupid/</url>
      
        <content type="html"><![CDATA[<p>如果你否定天分的存在，只强调勤奋努力，那就是蠢。但如果你因此认为勤奋努力没有用，那就是又懒又蠢。</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOSX 活动监视器其他信息都不见了</title>
      <link href="posts/2020-02-08/macoxs-activity-monitory-column-is-missing/"/>
      <url>posts/2020-02-08/macoxs-activity-monitory-column-is-missing/</url>
      
        <content type="html"><![CDATA[<p>MacOSX下的任务管理器出问题了。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>MacOSX 最近系统升级后打开活动监视器，发现只有名称，别的信息都不见了。</p><p><img src="https://tobyqin.github.io/images/image-20200208153208904.png" alt="image-20200208153208904"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>其实原因是名称栏的布局被拉的很长，后面的列都在的但是被盖住了。用触摸板或者鼠标往右拉就可以看到了。然后再调整一下第一列的宽度就可以了。</p><p> 向右拉宽：</p><p><img src="https://tobyqin.github.io/images/2020-02/974c55f7-1b5d-47b7-9e4a-282304a727e0" alt="img"></p><p>再向右：</p><p><img src="https://tobyqin.github.io/images/2020-02/8e6eca08-1144-4773-88c3-463f36500b9a" alt="img"></p><p>出问题了：</p><p><img src="https://tobyqin.github.io/images/2020-02/5fcf74c5-8bf8-4fee-ad20-faeaa91218dd" alt="img"></p><p>重新归位：</p><p><img src="https://tobyqin.github.io/images/2020-02/961b27cf-00ea-4363-afbd-3760fbb64a9b" alt="img"></p><p>我印象中自己没调整过，应该是苹果升级系统后出的问题，他们的锅。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://discussionschinese.apple.com/thread/250913347" target="_blank" rel="noopener">https://discussionschinese.apple.com/thread/250913347</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> macosx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蝙蝠</title>
      <link href="posts/2020-02-08/why-bat/"/>
      <url>posts/2020-02-08/why-bat/</url>
      
        <content type="html"><![CDATA[<p>多年后孩子问：爸爸，为什么我们班里同学都是同年同一个月份的生日？爸爸看向远方，深沉的说：那得从一只蝙蝠说起……</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> joke </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码停止或删除所有Docker容器</title>
      <link href="posts/2020-02-06/stop-remove-all-docker-containers/"/>
      <url>posts/2020-02-06/stop-remove-all-docker-containers/</url>
      
        <content type="html"><![CDATA[<p>一行代码就可以停止或者删除所有的 <a href="http://www.docker.io/" target="_blank" rel="noopener">Docker</a> 容器。</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> container </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 添加和删除 Swap 文件</title>
      <link href="posts/2020-02-03/add-and-delete-swap-files-under-linux/"/>
      <url>posts/2020-02-03/add-and-delete-swap-files-under-linux/</url>
      
        <content type="html"><![CDATA[<p>Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，Swap 是通过磁盘文件的形式给系统增加虚拟内存的解决方案。</p><a id="more"></a><p>所以Swap速度肯定比真实内存慢，但是可以让系统可以处理超过自身内存瓶颈的任务。默认情况下，系统会用完物理内存后才用虚拟内存。</p><h2 id="检查-Swap"><a href="#检查-Swap" class="headerlink" title="检查 Swap"></a>检查 Swap</h2><p>先检查一下系统里有没有存在的 Swap 文件，如果返回的信息概要是空的，则表示 Swap 文件不存在。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure><p>free命令可以确定swap文件是否在在使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><h2 id="创建-Swap"><a href="#创建-Swap" class="headerlink" title="创建 Swap"></a>创建 Swap</h2><p>一般Swap文件的大小是内存的2倍，如果内存1G，Swap应该就是2G。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fallocate -l 2G /swapfile</span><br></pre></td></tr></table></figure><p>如果这个命令失败就用<code>dd</code>，但是需要计算字节数。  </p><blockquote><p>swap文件的大小单位为M。将该值乘以1024得到块大小。例如，64MB的swap文件的块大小是65536。</p></blockquote><p>下面使用 dd 命令来创建 Swap 文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1024 count=4194304</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。<code>&lt; if=input file &gt;</code></li><li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。<code>&lt; of=output file &gt;</code></li><li>bs=bytes：同时设置读入/输出的块大小为bytes个字节</li><li>count=blocks：仅拷贝blocks个块，块大小等于bs指定的字节数。</li></ul><p>最后，赋予 Swap 文件适当的权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown root:root /swapfile </span><br><span class="line">chmod 0600 /swapfile</span><br></pre></td></tr></table></figure><h2 id="激活-Swap"><a href="#激活-Swap" class="headerlink" title="激活 Swap"></a>激活 Swap</h2><p>创建好Swap文件，还需要格式化后才能使用。运行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure><p>激活 Swap ，运行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure><p>如果要机器重启的时候自动挂载 Swap ，那么还需要修改 fstab 配置。用 vim 打开 <code>/etc/fstab</code> 文件，在其最后添加如下一行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/swapfile   swap   swap    defaults 0 0</span><br></pre></td></tr></table></figure><p>当下一次系统启动时，新的swap文件就打开了。</p><p>在 Linux 系统中，可以通过查看 <code>/proc/sys/vm/swappiness</code> 内容的值来确定系统对 Swap 分区的使用原则。当 <code>swappiness</code> 内容的值为 0 时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 Swap 分区。当 <code>swappiness</code> 内容的值为 100 时，表示积极地使用 Swap 分区，并且把内存中的数据及时地置换到 Swap 分区。 默认值为 0，表示需要在物理内存使用完毕后才会使用 Swap 分区。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看默认的swappiness参数 </span></span><br><span class="line">cat  /proc/sys/vm/swappiness </span><br><span class="line"><span class="comment">## 临时修改 </span></span><br><span class="line">sysctl -w  vm.swappiness=10 </span><br><span class="line"><span class="comment">## 永久修改 </span></span><br><span class="line">vi + /etc/sysctl.conf </span><br><span class="line"><span class="comment"># 添加 vm.swappiness=10 </span></span><br><span class="line"><span class="comment">## 让配置生效  sysctl -p</span></span><br></pre></td></tr></table></figure><h2 id="删除-Swap"><a href="#删除-Swap" class="headerlink" title="删除 Swap"></a>删除 Swap</h2><p>先卸载Swap分区，后从fastab中删除，最后删除文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff /swapfile</span><br><span class="line"><span class="comment"># remove swap configuration from /etc/fstab</span></span><br><span class="line">rm -rf /swapfile</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/wangjunjun2008/article/details/50681115" target="_blank" rel="noopener">https://blog.csdn.net/wangjunjun2008/article/details/50681115</a></li><li><a href="https://www.cnblogs.com/operationhome/p/10571166.html" target="_blank" rel="noopener">https://www.cnblogs.com/operationhome/p/10571166.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种私有云盘解决方案</title>
      <link href="posts/2020-02-03/file-sever-and-private-cloud-solution/"/>
      <url>posts/2020-02-03/file-sever-and-private-cloud-solution/</url>
      
        <content type="html"><![CDATA[<p>尝试了几种开源的私有云盘（文件服务器）的解决方案，备忘一下。</p><a id="more"></a><h2 id="Seafile"><a href="#Seafile" class="headerlink" title="Seafile"></a>Seafile</h2><p>可以参考<a href="https://cloud.seafile.com/published/seafile-manual-cn/docker" target="_blank" rel="noopener">官网部署文档</a>，最新版7.x需要用docker-compose，十分不推荐这种被淘汰的技术，所以还是用旧版（6.x）吧。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name seafile \</span><br><span class="line">  -e SEAFILE_SERVER_HOSTNAME=seafile.example.com \</span><br><span class="line">  -e SEAFILE_ADMIN_EMAIL=me@example.com \</span><br><span class="line">  -e SEAFILE_ADMIN_PASSWORD=a_very_secret_password \</span><br><span class="line">  -v /my/local/seafile-data:/shared \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  seafileltd/seafile:latest</span><br></pre></td></tr></table></figure><p>注意，<code>SEAFILE_SERVER_HOSTNAME</code> 一定要配置正确，不然上传文件会报网络错误，如果是本地测试可以配置成 127.0.0.1，默认的用户名密码如果没配的话，就是<code>me@example.com</code>，<code>asecret</code>。</p><p>如果一定要用7.x，可以尝试用<a href="https://hub.docker.com/r/tinysnake/seafile" target="_blank" rel="noopener">非官方封装的docker镜像</a>。</p><p>部署成功后就可以登录了，界面如下。</p><p><img src="https://tobyqin.github.io/images/seafile-example.png" alt="seafile-example"></p><p>Seafile可以映射本地目录，不过不会映射本地文件列表。也就是说，你不能直接操作本地文件然后在网页上体现，反之亦然。它映射的本地目录是按它的系统结构存储的数据，所以不是很方便，一定要映射本地某个目录的话就需要安装客户端了。</p><p>Seafile还提供了<a href="https://cloud.seafile.com/" target="_blank" rel="noopener">公有云的免费版和团队版</a>，2个G的容量随便用用还不错，不用自己部署和维护。</p><h2 id="filebrowser"><a href="#filebrowser" class="headerlink" title="filebrowser"></a>filebrowser</h2><p>这是一个挺简洁的文件管理器，不过项目在<a href="https://github.com/filebrowser/filebrowser" target="_blank" rel="noopener">Github</a>已经不维护了，挺可惜的，不过不影响使用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name=filebrowser \</span><br><span class="line">    -v /path/to/your/files:/srv \</span><br><span class="line">    -v /data/filebrowser.db:/database.db \</span><br><span class="line">    -v /data/.filebrowser.json:/.filebrowser.json \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    filebrowser/filebrowser</span><br></pre></td></tr></table></figure><p>默认的用户名密码都是admin，-v 前半部分都是本地目录，按自己的情况修改，后半部分是容器里的目标目录，不能改。</p><p> 登录后的样子是这样的。</p><p><img src="https://tobyqin.github.io/images/filebrowser-example.png" alt="filebrowser-example"></p><p>作为文件管理器而言，它真的非常好用也很方便，整个镜像也很小，适合部署在任何服务器。而且它映射的文件目录中的文件会直接显示在网页上，操作文件是同步的。唯一的小缺点就是不能预览文件，所有文件类型都必须下载后才能查看。</p><h2 id="minio"><a href="#minio" class="headerlink" title="minio"></a>minio</h2><p>严格上来说，minio并不是一个文件管理器，而是一个功能完整的高性能存储对象服务，参见<a href="https://min.io/" target="_blank" rel="noopener">官网</a>。它提供了完整的存储对象API以及面向云原生设计，很方便部署在Kubernetes等云环境。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull minio&#x2F;minio</span><br><span class="line">docker run -p 9000:9000 minio&#x2F;minio server &#x2F;data</span><br></pre></td></tr></table></figure><p>默认的用户名密码都是minioadmin，在启动的控制台可以看到。界面非常简洁和清爽。</p><p><img src="https://tobyqin.github.io/images/minio-example.png" alt="minio-example"></p><h2 id="其他选择"><a href="#其他选择" class="headerlink" title="其他选择"></a>其他选择</h2><p>还有一些其他的可选方案，看上去不错，记下来权当备忘。</p><h3 id="蓝眼云盘"><a href="#蓝眼云盘" class="headerlink" title="蓝眼云盘"></a>蓝眼云盘</h3><p>Github：<a href="https://github.com/eyebluecn/tank" target="_blank" rel="noopener">https://github.com/eyebluecn/tank</a></p><p><img src="https://tobyqin.github.io/images/2020-02/tank0.png" alt="img"></p><h3 id="zdir"><a href="#zdir" class="headerlink" title="zdir"></a>zdir</h3><p>Github：<a href="https://github.com/helloxz/zdir" target="_blank" rel="noopener">https://github.com/helloxz/zdir</a><br><img src="https://tobyqin.github.io/images/2020-02/68747470733a2f2f696d6775726c2e6f72672f75706c6f61642f313830362f333439663362353430323864353864362e706e67" alt="img"></p><h3 id="caddy"><a href="#caddy" class="headerlink" title="caddy"></a>caddy</h3><p>Github：<a href="https://github.com/caddyserver/caddy" target="_blank" rel="noopener">https://github.com/caddyserver/caddy</a></p><p><img src="https://tobyqin.github.io/images/caddy-example.png" alt="caddy-example"></p><p>外加一些非开源的：</p><ul><li><a href="http://iscute.cn/chfs" target="_blank" rel="noopener">http://iscute.cn/chfs</a></li><li><a href="https://webd.cf/" target="_blank" rel="noopener">https://webd.cf/</a></li><li><a href="https://filelist.cn/public" target="_blank" rel="noopener">https://filelist.cn/public</a></li><li><a href="https://www.v2ex.com/t/553123" target="_blank" rel="noopener">https://www.v2ex.com/t/553123</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seafile </tag>
            
            <tag> file browser </tag>
            
            <tag> min.io </tag>
            
            <tag> file server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Library not loaded: /usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib</title>
      <link href="posts/2020-01-31/dyld-libary-not-loaded-openssl-dylib/"/>
      <url>posts/2020-01-31/dyld-libary-not-loaded-openssl-dylib/</url>
      
        <content type="html"><![CDATA[<p>因为升级了MacOSX和openssl，然后Jekyll和Python都坏了，报各种错误。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Python和Git都会报错。</p><blockquote><p>dyld: Library not loaded: /usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/Python<br>  Referenced from: /Users/tobyqin/src/service/venv/bin/python<br>  Reason: image not found</p><p>dyld: Library not loaded: /usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib<br>Referenced from: /usr/local/bin/ssh<br>Reason: image not found<br>fatal: Could not read from remote repository. </p></blockquote><p>网上查了各种方案，头疼了好久。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>卸载新版的openssl，然后安装没有问题的openssl，python和jekyll就好了。</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade</span><br><span class="line">brew uninstall --ignore-dependencies openssl</span><br><span class="line">brew install https://github.com/tebelorg/Tump/releases/download/v1.0.0/openssl.rb</span><br></pre></td></tr></table></figure><p>但是，git和ssh却坏了。</p><p><strong>重新或者强制安装最新的openssh就好了</strong>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew reinstall openssh</span></span><br></pre></td></tr></table></figure><p>这时后python又坏了，因为它和openssh依赖的openssl版本不一致。</p><p>这时候需要切换默认的openssl版本，就可以解决所有问题。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew switch openssl 1.0.2t</span></span><br><span class="line">Cleaning /usr/local/Cellar/openssl/1.0.2t</span><br><span class="line">Opt link created for /usr/local/Cellar/openssl/1.0.2t</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> openssl </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理MacOSX的开机启动项</title>
      <link href="posts/2020-01-31/macosx-startup-items/"/>
      <url>posts/2020-01-31/macosx-startup-items/</url>
      
        <content type="html"><![CDATA[<p>MacOSX下的开机项有多乱，需要整理一下。</p><a id="more"></a><h2 id="系统偏好"><a href="#系统偏好" class="headerlink" title="系统偏好"></a>系统偏好</h2><p>在“系统偏好设置”窗口，选择“用户与群组”，进入用户与群组窗口。选择登录项选项卡，再解锁，最后删除开机启动的应用。</p><h2 id="plist-文件"><a href="#plist-文件" class="headerlink" title="plist 文件"></a>plist 文件</h2><p>分别在以下6个目录中检查是否有与开机程序相关的plist文件</p><ol><li>~/Library/Preferences/ – （当前用户设置的进程）</li><li>~/Library/LaunchAgents/ – （当前用户的守护进程）</li><li>/Library/LaunchAgents/ – （管理员设置的用户进程）</li><li>/Library/LaunchDaemons/ – （管理员提供的系统守护进程）</li><li>/System/Library/LaunchAgents/ – （Mac操作系统提供的用户进程）</li><li>/System/Library/LaunchDaemons/ – （Mac操作系统提供的系统守护进程）</li></ol><h3 id="plist中主要的字段和它的含义"><a href="#plist中主要的字段和它的含义" class="headerlink" title="plist中主要的字段和它的含义"></a>plist中主要的字段和它的含义</h3><ul><li><code>Label &lt;required, nsstring=“”&gt;</code> Launchd中的一个唯一标识，类似于每一个程序都有一个ID一样。</li><li><code>UserName &lt;optional, string=&quot;&quot;&gt;</code> 指定运行启动项的用户，只有当Launchd 作为 root 用户运行时，此项才适用。</li><li><code>GroupName &lt;optional, string=&quot;&quot;&gt;</code> 指定运行启动项的组，只有当Launchd 作为 root 用户运行时，此项才适用。</li><li><code>Program&lt;optional, string=&quot;&quot;&gt;</code> 这个值用来指定进程的可执行文件的路径。</li><li><code>ProgramArguments&lt;optional,array of=&quot;&quot; strings=&quot;&quot;&gt;</code> 如果未指定<code>Program</code>时就必须指定该项，包括可执行文件文件和运行的参数。</li><li><code>KeepAlive &lt;optional, boolean=&quot;&quot;&gt;</code> 用来控制可执行文件是持续运行，还是满足具体条件之后再启动。默认值为<code>false</code>，也就是说满足具体条件之后才启动。当设置值为<code>true</code>时，表明无条件的开启可执行文件，并使之保持在整个系统运行周期内。</li><li><code>RunAtLoad &lt;optional, boolean=&quot;”&gt;</code> 标识Launchd在加载完该项服务之后立即启动路径指定的可执行文件。默认值为<code>false</code>。</li><li><code>SuccessfulExit &lt;optional, boolean=&quot;”&gt;</code> 此项为 <code>true</code> 时，程序正常退出时重启（即退出码为 0）；为 <code>false</code> 时，程序非正常退出时重启。此项设置时会隐含默认 <code>RunAtLoad = true</code>，因为程序需要至少运行一次才能获得退出状态。</li></ul><p>所以不能简单的把以上目录中的plist删除来解决开机启动问题，这样会导致某些应用启动失败。最保险的办法是根据plist的文件名字，猜测它的作用，然后再配置其中的Key。</p><ul><li><p>如果 <code>KeepAlive</code> = false：</p></li><li><ul><li>当 <code>RunAtLoad</code> = false 时：程序只有在有需要的时候运行。</li><li>当 <code>RunAtLoad</code> = true 时：程序在启动时会运行一次，然后等待在有需要的时候运行。</li><li>当 <code>SuccessfulExit</code> =  true / false 时：不论 <code>RunAtLoad</code> 值是什么，都会在启动时运行一次。其后根据 <code>SuccessfulExit</code> 值来决定是否重启。 </li></ul></li><li><p>如果 <code>KeepAlive</code> = true ：</p></li><li><ul><li>不论 <code>RunAtLoad</code>/<code>SuccessfulExit</code> 值是什么，都会启动时运行且一直保持运行状态。</li></ul></li></ul><p>如果不希望开机自动运行，则需要：</p><blockquote><ol><li>找到对应程序的 .plist 文件 </li><li>删除 SuccessfulExit 属性。</li><li>将 RunAtLoad / KeepAlive 均设为 false</li></ol></blockquote><h2 id="StartupItems"><a href="#StartupItems" class="headerlink" title="StartupItems"></a>StartupItems</h2><p>StartupItems，顾名思义，就是在系统启动过程中运行的程序，它们可以是运行完就立即终止的程序，也可以是一直持续在系统运行周期的后台进程。</p><p>StartupItems 一般存放在以下两个路径下：</p><ol><li>/System/Library/StartupItems</li><li>/Library/StartupItems</li></ol><p>大部分与系统相关的StartupItems都放在<code>/System/Library/StartupItems</code>这个路径下，它们会先于 <code>/Library/StartupItems</code> 路径下的执行，因为前者路径下的StartupItems提供了系统级的基础服务，而后者路径在默认情况下是不存在的，需要自己手动创建。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.jianshu.com/p/542f6359f2d4" target="_blank" rel="noopener">https://www.jianshu.com/p/542f6359f2d4</a></li><li><a href="https://www.zhihu.com/question/28268529" target="_blank" rel="noopener">https://www.zhihu.com/question/28268529</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macosx </tag>
            
            <tag> startup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Linux或者Mac OSX上查找大文件</title>
      <link href="posts/2020-01-30/search-large-files-on-linux/"/>
      <url>posts/2020-01-30/search-large-files-on-linux/</url>
      
        <content type="html"><![CDATA[<p>在Mac OSX上尚且还有一些图形工具可以帮助查找和清理大文件，在Linux只能依靠命令行。其实也不难，这次总结一下，省的下次还去搜索。</p><a id="more"></a><h2 id="万能的du"><a href="#万能的du" class="headerlink" title="万能的du"></a>万能的du</h2><p><code>du</code> 是Linux和MacOSX都自带命令行工具，全称是 Disk Usage，这样就好记了。配合两个参数就可以搞定大多数问题。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-s      Display an entry for each specified file.  (Equivalent to -d 0)</span><br><span class="line">-h      "Human-readable" output.</span><br></pre></td></tr></table></figure><p><code>-s</code>的意思就是只统计第一层目录，<code>-h</code> 就是显示可读性的统计数据，看例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]# du -sh /*</span><br><span class="line">0       /bin</span><br><span class="line">89M     /boot</span><br><span class="line">0       /dev</span><br><span class="line">39M     /etc</span><br><span class="line">4.0K    /home</span><br><span class="line">16K     /lost+found</span><br><span class="line">4.0K    /media</span><br><span class="line">4.0K    /mnt</span><br><span class="line">4.0K    /opt</span><br><span class="line">0       /proc</span><br><span class="line">603M    /root</span><br><span class="line">13M     /run</span><br><span class="line">0       /sbin</span><br><span class="line">4.0K    /srv</span><br><span class="line">513M    /swapfile</span><br><span class="line">0       /sys</span><br><span class="line">616K    /tmp</span><br><span class="line">1.3G    /usr</span><br><span class="line">487M    /var</span><br></pre></td></tr></table></figure><p>从根目录开始找最大的目录，然后一层一层递进就可以找到占用最大空间的目录或者文件。</p><h3 id="限制数量和排序"><a href="#限制数量和排序" class="headerlink" title="限制数量和排序"></a>限制数量和排序</h3><p>当目录里文件比较多的时候，我们就要限制返回的条数和排序，比如我只想知道占用空间最大的5个目录，通过管道操作符就可以达到目的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]# du -s /usr/* | sort -nr | head -5</span><br><span class="line">598904  /usr/lib</span><br><span class="line">303676  /usr/share</span><br><span class="line">185836  /usr/lib64</span><br><span class="line">124044  /usr/bin</span><br><span class="line">44772   /usr/sbin</span><br></pre></td></tr></table></figure><h2 id="当前目录占用空间"><a href="#当前目录占用空间" class="headerlink" title="当前目录占用空间"></a>当前目录占用空间</h2><p><code>du</code> 还可以很方便检查当前目录占用空间。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]<span class="comment"># du -sh</span></span><br><span class="line">603M    .</span><br></pre></td></tr></table></figure><h2 id="比较难记的find"><a href="#比较难记的find" class="headerlink" title="比较难记的find"></a>比较难记的find</h2><p><code>find</code> 是非常强大的命令，可以按文件属性进行搜索，比如检索大于10M的文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@50KVM-2017127313 ~]<span class="comment"># find . -size +10M</span></span><br><span class="line">./blog/.git/objects/pack/pack-fab187cef1cd08d186624f1e5e97e3131b20abc0.pack</span><br><span class="line">./docs/.git/objects/3f/3385a6b098631a8426a720dcd56a9ed7da4183</span><br><span class="line">./docs/PPT/Demo.pptx</span><br></pre></td></tr></table></figure><p>如上命令是把文件名打印出来了，但文件的细节还是不清楚，这时候你需要加上更多参数。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find / -size +500M -<span class="built_in">exec</span> du -h &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>如果还要排序，再加个管道。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size +100M  -print0 | xargs -0 du -h | sort -nr</span><br></pre></td></tr></table></figure><p><code>find</code> 权当是备忘吧，具体的参数我是记不住的，推荐还是用简单易懂的<code>du</code>。</p><h2 id="额外的df"><a href="#额外的df" class="headerlink" title="额外的df"></a>额外的df</h2><p><code>df</code>也是磁盘管理常用的工具之一，全称不知道是什么，从文档上看好像是 Disk space available on file system? 需要记住的参数只有一个，就是<code>-h</code>，可读性显示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        107M     0  107M   0% /dev</span><br><span class="line">tmpfs           117M     0  117M   0% /dev/shm</span><br><span class="line">tmpfs           117M   13M  105M  11% /run</span><br><span class="line">tmpfs           117M     0  117M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       4.9G  3.0G  1.7G  65% /</span><br><span class="line">tmpfs            24M     0   24M   0% /run/user/0</span><br></pre></td></tr></table></figure><p>这个命令就是用来看磁盘剩余空间的，当然有时候 <code>-ai</code>的参数也偶尔会被提到，用来检查<code>inode</code>的使用情况。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@017127313 ~]# df -ai</span><br><span class="line">Filesystem     Inodes IUsed  IFree IUse% Mounted on</span><br><span class="line">devtmpfs        27317   393  26924    2% /dev</span><br><span class="line">tmpfs           29942     1  29941    1% /dev/shm</span><br><span class="line">tmpfs           29942   491  29451    2% /run</span><br><span class="line">tmpfs           29942    16  29926    1% /sys/fs/cgroup</span><br><span class="line">/dev/vda1      324480 50300 274180   16% /</span><br><span class="line">tmpfs           29942     2  29940    1% /run/user/0</span><br></pre></td></tr></table></figure><p>如果<code>inode</code>占用到100%了，你的磁盘就是还有空间也写不进去了，<code>inode</code>可以理解为文件的索引区吧，用来存放文件的属性等等，具体的内容会写到 <code>block</code> 区，当文件很碎的时候，<code>block</code> 可能还没满，但是 <code>inode</code>已经满了。</p><h2 id="免费赠送的-free"><a href="#免费赠送的-free" class="headerlink" title="免费赠送的 free"></a>免费赠送的 free</h2><p>文章的最后再送个 <code>free</code> 命令吧，这个跟文件系统有一丢丢关系，这个命令是用来显示内存的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]<span class="comment"># free -h</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           233M         58M         28M          9M        147M        142M</span><br><span class="line">Swap:          511M         21M        490M</span><br></pre></td></tr></table></figure><p><code>free</code> 是用来显示内存占用情况的，<code>-h</code> 一样是人性化显示。注意，这个命令还是看到swap分区的使用情况。</p><p>一般Linux都会配置虚拟内存，也就是用swap分区。很早以前内存还是很宝贵的，所以聪明的人类就划分了一部分硬盘来充当二级内存，纵然速度慢点，但是容量更大了能处理的东西就更多了。</p><p><code>free</code> 里可以查看swap占用情况，但不能清理或者调整它的大小。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> linux </tag>
            
            <tag> du </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组织Flask项目结构</title>
      <link href="posts/2020-01-26/the-flask-project-structure/"/>
      <url>posts/2020-01-26/the-flask-project-structure/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tobyqin.github.io/images/organizing.png" alt="organizing"></p><p><a href="https://palletsprojects.com/p/flask/" target="_blank" rel="noopener">Flask</a> 是非常轻量和灵活的Python框架，轻量和灵活是它的优点，也是它的缺点。所以我们在使用Flask构建项目时就不得不慎重考虑其目录结构，以便日后扩展和维护。</p><a id="more"></a><p>这里我列举了一些常见的Flask项目结构，没有好坏之分，大家可以按照实际情况参考使用。</p><h2 id="极简风格"><a href="#极简风格" class="headerlink" title="极简风格"></a>极简风格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.py</span><br><span class="line">config.py</span><br><span class="line">requirements.txt</span><br><span class="line">static&#x2F;</span><br><span class="line">templates&#x2F;</span><br></pre></td></tr></table></figure><p>此项目结构可以用于构建最简单的Web程序，一般用于Demo或者POC。</p><h2 id="使用App组织项目"><a href="#使用App组织项目" class="headerlink" title="使用App组织项目"></a>使用App组织项目</h2><p>相对复杂的项目可以按包（package）的方式来组织代码，不同的包对应不同的应用（app），每个应用相对独立，其中会有自治的视图（view）和模型（model）等等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.py</span><br><span class="line">requirements.txt</span><br><span class="line">run.py</span><br><span class="line">instance&#x2F;</span><br><span class="line">    config.py</span><br><span class="line">yourapp&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    views.py</span><br><span class="line">    models.py</span><br><span class="line">    forms.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br></pre></td></tr></table></figure><p>其实Flask项目做到这个程度已经差不多了，如果项目再复杂，就不太推荐使用Flask了，而是考虑换成<a href="https://www.djangoproject.com/" target="_blank" rel="noopener">django</a>或者其他更适合做大型项目的框架，死磕Flask最后只会适得其反。</p><p>欲知更多，可参考:</p><ul><li><a href="http://exploreflask.com/en/latest/organizing.html" target="_blank" rel="noopener">http://exploreflask.com/en/latest/organizing.html</a></li><li><a href="https://lepture.com/en/2018/structure-of-a-flask-project" target="_blank" rel="noopener">https://lepture.com/en/2018/structure-of-a-flask-project</a></li><li><a href="http://flask.pocoo.org/docs/1.0/patterns/packages/" target="_blank" rel="noopener">http://flask.pocoo.org/docs/1.0/patterns/packages/</a></li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-structure-large-flask-applications" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-structure-large-flask-applications</a></li></ul><h2 id="使用Blueprints组织项目"><a href="#使用Blueprints组织项目" class="headerlink" title="使用Blueprints组织项目"></a>使用Blueprints组织项目</h2><p>更加复杂的项目可以引入 <a href="http://docs.jinkan.org/docs/flask/blueprints.html" target="_blank" rel="noopener">Blueprints</a> 来简化工作，这是官方推荐的Flask大型项目解决方案。一个 Blueprints 对象和一个 Flask 对象很类似，所以有了Blueprints 之后你可以很方便的将大型应用拆分成多个子项目来开发和加载。Blueprints需要注册后才能被加载，有点像插件。</p><p>Blueprints 解决了应用拆分的可能性，但怎么拆分和组合还是开发者的事情，下面几个例子可以参考一下。</p><h3 id="基于逻辑功能"><a href="#基于逻辑功能" class="headerlink" title="基于逻辑功能"></a>基于逻辑功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yourapp&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">        home&#x2F;</span><br><span class="line">        control_panel&#x2F;</span><br><span class="line">        admin&#x2F;</span><br><span class="line">    views&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        home.py</span><br><span class="line">        control_panel.py</span><br><span class="line">        admin.py</span><br><span class="line">    models.py</span><br><span class="line">tests&#x2F;</span><br></pre></td></tr></table></figure><h3 id="基于职能模块"><a href="#基于职能模块" class="headerlink" title="基于职能模块"></a>基于职能模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.txt</span><br><span class="line">requirements.txt</span><br><span class="line">run.py</span><br><span class="line">yourapp&#x2F;</span><br><span class="line">  __init__.py</span><br><span class="line">  home&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  dash&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  admin&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  api&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  blog&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  models.py</span><br><span class="line">tests&#x2F;</span><br></pre></td></tr></table></figure><h3 id="静态模板的组织"><a href="#静态模板的组织" class="headerlink" title="静态模板的组织"></a>静态模板的组织</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">facebook&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    templates&#x2F;</span><br><span class="line">        layout.html</span><br><span class="line">        home&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            index.html</span><br><span class="line">            about.html</span><br><span class="line">            signup.html</span><br><span class="line">            login.html</span><br><span class="line">        dashboard&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            news_feed.html</span><br><span class="line">            welcome.html</span><br><span class="line">            find_friends.html</span><br><span class="line">        profile&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            timeline.html</span><br><span class="line">            about.html</span><br><span class="line">            photos.html</span><br><span class="line">            friends.html</span><br><span class="line">            edit.html</span><br><span class="line">        settings&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            privacy.html</span><br><span class="line">            security.html</span><br><span class="line">            general.html</span><br><span class="line">    views&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        home.py</span><br><span class="line">        dashboard.py</span><br><span class="line">        profile.py</span><br><span class="line">        settings.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">        style.css</span><br><span class="line">        logo.png</span><br><span class="line">    models.py</span><br></pre></td></tr></table></figure><p>对于Flask应用中的静态模板，我觉得在现代应用中还需要三思。因为大多数的现代应用都会考虑用nodejs构建前端，使用模板语言已经属于异教徒，后期的维护和更新更是挖坑填坑的过程。</p><h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>对于要快速见效的项目，用Flask还是不错的选择，例如做个页面收集数据或者展示图表，再或者模拟几个API用于测试等等。但是大点的项目还是算了吧，真的，不骗你，要填的坑远比你想象的多的多。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash 脚本中的 set -euxo pipefail</title>
      <link href="posts/2020-01-07/bash-scripts-with-set-euxo-pipefail/"/>
      <url>posts/2020-01-07/bash-scripts-with-set-euxo-pipefail/</url>
      
        <content type="html"><![CDATA[<p>有些开发人员会用Bash来实现很复杂的功能，就像使用别的高级语言一样。他可能觉得自己很牛逼但其他人早就想锤爆他了，Bash的可读性和可维护性远远低于任何高级语言。更要命的是，Bash并没有方便的调试工具和防错机制，出了问题你要排查半天。</p><a id="more"></a><p>在Ruby或者Python等高级语言里，你很容易知道错误是哪行什么类型的错误，还有IDE的Debugger加持。而Bash只能看源码，通过打印log等非常低效的方式调试。</p><p>本文将介绍Bash中 <code>set -euxo pipefail</code>，它们可以帮助你写出更容易维护也更安全的脚本。这也是Bash脚本的终极调试手段，希望你以后在自己的脚本中加上这么一行，头顶也能少秃一点。</p><h2 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a>set -e</h2><p><code>set -e</code> 选项可以让你的脚本在出现异常时马上退出，后续命令不再执行。默认情况下Shell脚本不会因为错误而结束执行，但大多数情况是，我们希望出现异常时就不要再往下走了。假如你的<code>if</code>判断条件里会出现异常，这时脚本也会直接退出，但可能这并不是你期望的情况，这时你可以在判断语句后加上 <code>|| true</code> 来阻止退出。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 4: foo: command not found</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br></pre></td></tr></table></figure><p>阻止立即退出的例子。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo || <span class="literal">true</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h2 id="set-o-pipefail"><a href="#set-o-pipefail" class="headerlink" title="set -o pipefail"></a>set -o pipefail</h2><p>默认情况下Bash只会检查管道（pipeline）操作最后一个命令的返回值，假如最右边的命令成功那么它就认为这个语句没问题。这个行为其实是很不安全的，所以就有了<code>set -o pipefail</code>。这个特别的选项表示在管道连接的命令中，只要有任何一个命令失败（返回值非0），则整个管道操作被视为失败。只有管道中所有命令都成功执行了这个管道才算成功执行。</p><h3 id="Before-1"><a href="#Before-1" class="headerlink" title="Before"></a>Before</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo | <span class="built_in">echo</span> <span class="string">"a"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h3 id="After-1"><a href="#After-1" class="headerlink" title="After"></a>After</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo | <span class="built_in">echo</span> <span class="string">"a"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br></pre></td></tr></table></figure><h2 id="set-u"><a href="#set-u" class="headerlink" title="set -u"></a>set -u</h2><p><code>set -u</code> 比较容易理解，Bash会把所有未定义的变量视为错误。默认情况下Bash会将未定义的变量视为空，不会报错，这也是很多坑的来源。也许由于变量名的细微差别让你查半天最后骂骂咧咧。</p><h3 id="Before-2"><a href="#Before-2" class="headerlink" title="Before"></a>Before</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h3 id="After-2"><a href="#After-2" class="headerlink" title="After"></a>After</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 5: a: unbound variable</span></span><br></pre></td></tr></table></figure><h2 id="set-x"><a href="#set-x" class="headerlink" title="set -x"></a>set -x</h2><p><code>set -x</code> 可以让Bash把每个命令在执行前先打印出来，你可以认为这就是Bash的Debug开关。它的好处当然显而易见，方便你快速找到有问题的脚本位置，但是也坏处也有吧，就是Bash的log会格外的乱。另外，它在打印命令前会把变量先解析出来，所以你可以知道当前执行的语句的变量值是什么。纵然log可能会乱一些，总比头发乱一些好，所以建议还是打开这个开关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># + a=5</span></span><br><span class="line"><span class="comment"># + echo 5</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># + echo bar</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><p>以上就是关于 <code>set -euxo pipefail</code> 的介绍，从Shell脚本的编写角度看，我十分建议所有人都应该在自己的Shell脚本里加上这么一行。但从实际情况看，如果你的Shell脚本已经超过200行，我更建议你换成高级语言来实现。比如Python或者Ruby甚至Perl，这些高级语言在Linux系统都是内置的，注意版本兼容性就好，写起来比Shell舒服太多了。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谢谢，我们很忙</title>
      <link href="posts/2020-01-01/thanks-we-are-busy/"/>
      <url>posts/2020-01-01/thanks-we-are-busy/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tobyqin.github.io/images/too-busy-to-improve.png" alt="too-busy-to-improve"></p><p>新的一年开始了，</p><p>不要为了忙碌而忙碌。</p><p>在忙碌中找问题，</p><p>多用脑子，避免老年痴呆。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> devops </tag>
            
            <tag> comics </tag>
            
            <tag> geek </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Github Actions 自动发布 Hexo 博客</title>
      <link href="posts/2019-12-25/publish-hexo-blog-via-github-actions/"/>
      <url>posts/2019-12-25/publish-hexo-blog-via-github-actions/</url>
      
        <content type="html"><![CDATA[<p>Github 今年推出了自己的CI集成方案 <a href="https://github.com/features/actions" target="_blank" rel="noopener">Github Actions</a>，本着玩一玩不吃亏的态度，我把原来通过 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 的自动发布流程迁移到了 Github Actions，整个过程还是非常愉快顺利的。</p><a id="more"></a><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>这部我就不展开说了，直接到 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo 官网</a>参考文档就可以快速开始。</p><p>我假设你已经有这么一个博客了，而且也成功手动发布过。</p><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>为了安全起见，我们为此次发布单独创建一对密钥，在本地命令行执行如下命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -b 4096 -f ~/.ssh/github-actions-deploy</span></span><br></pre></td></tr></table></figure><p>一路回车，生成的公钥为 <code>github-actions-deploy.pub</code>，私钥为 <code>github-actions-deploy</code>。</p><h2 id="安排密钥"><a href="#安排密钥" class="headerlink" title="安排密钥"></a>安排密钥</h2><p>假设你的 Github 源文件仓库是 <code>blog</code>，静态页面仓库是 tobyqin.github.io。那么你需要将公钥配置到静态页面仓库的 <code>Deploy keys</code>，将私钥配置到源文件仓库的 <code>Secret</code>。</p><ul><li><code>blog</code> &gt; <code>Secrets</code> &gt; <code>Add a new secret</code> &gt; 添加密钥，命名为 <code>ACTION_DEPLOY_KEY</code></li><li><code>tobyqin.github.io</code> &gt; <code>Deploy keys</code> &gt; <code>add deploy key</code> &gt; 添加公钥，名字随意，允许写入权限。</li></ul><h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><p>这一步主要是确保你的博客能够发布到正确的仓库，参考如下配置。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:tobyqin/tobyqin.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h2 id="配置-Github-Actions"><a href="#配置-Github-Actions" class="headerlink" title="配置 Github Actions"></a>配置 Github Actions</h2><p>好戏开场，切到你的<code>blog</code>仓库，选择 <code>Actions</code> 选项卡，新建一个 <code>Workflow</code>。</p><p><img src="https://tobyqin.github.io/images/image-20191225230141168.png" alt="image-20191225230141168"></p><p>你可以选用某个模板，比如 <code>Node.js</code>，或者完全自定义。针对我自己的博客，因为我在发布前还写了个 Python 的脚本做了一些额外的事情，所以我的 <code>Workflow</code> 大概是这样的。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">publish:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Python</span> <span class="number">3.</span><span class="string">x</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">"3.7"</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">10.</span><span class="string">x</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">"10.x"</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACTION_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="comment"># set up private key for deploy</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">"$ACTION_DEPLOY_KEY"</span> <span class="string">|</span> <span class="string">tr</span> <span class="string">-d</span> <span class="string">'\r'</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">        <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># set git information</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">'Toby@Github'</span> <span class="comment"># 换成你自己的邮箱和名字</span></span><br><span class="line">        <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">'toby.qin@live.com'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># prepare blog</span></span><br><span class="line">        <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.txt</span></span><br><span class="line">        <span class="string">python</span> <span class="string">blog.py</span> <span class="string">prepare</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># install dependencies</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">        <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="comment"># publish my blog</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">        <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>可以看到这个<code>Workflow</code>的脚本还是很好理解的，先是起了一个名字，然后选择了 ubuntu 最新版作为运行系统，接着安装了 Python 和 Node.js，然后执行了一段脚本做环境配置，这里面既有 Python 又有 Node.js，最后执行了发布命令。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>当然这个Workflow我也不是一次就执行成功的，如果你需要调试的话就可以到 Github Actions 这个选项卡去看执行日志，非常的详尽和易读。</p><p><img src="https://tobyqin.github.io/images/image-20191225232123775.png" alt="image-20191225232123775"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Github 终于自己动手做 CI 了，让各大友商瑟瑟发抖。而且我体验下来非常棒，比 Travis CI 集成度更好，而且Action Workflow 使用Yaml来定义也十分清晰友好。</p><p>相对 Jenkins 的 Pipeline 可能少了一些图形化的支持，但功能毫不逊色。而且一个仓库是允许定义多个Workflow的，每个Workflow可以有不同的目的和触发机制，在Workflow中官方也提供了类似插件一样的功能，十分灵活。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cicd </tag>
            
            <tag> hexo </tag>
            
            <tag> github-actions </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年，再见</title>
      <link href="posts/2019-12-24/goodbye-my-2019/"/>
      <url>posts/2019-12-24/goodbye-my-2019/</url>
      
        <content type="html"><![CDATA[<p>又到年底了，是该收拾一下，准备迎接新的一年了。</p><a id="more"></a><p>这个时候，网上又开始流行各种跨年段子，什么看20本书变成买20本书，什么世界那么大我要去看看变成去朋友圈看看。但是你有没有想过那终究是别人的生活，不管是调侃还是现实，我们总是要对自己负责。</p><p>这一年，我离开了自己的舒适圈，铤而走险地换了一份工作，可谓感慨良多。</p><h2 id="代码终究不是我的"><a href="#代码终究不是我的" class="headerlink" title="代码终究不是我的"></a>代码终究不是我的</h2><p>大部分人都追求稳定，希望自己可以一条道走到黑。</p><p>今年我从测试岗位跳出来，内心无比纠结，因为我一直以为，只要自己足够努力加上自己还不算笨的脑袋，在这个岗位上5年一定能成精。其实不然，外面的世界有很多偶然性和必然性，想成就一件事需要很多条件全都契合在一起。你可以坚持下去，也许奇迹会发生，我选择跳出来，看看另外一种可能。</p><p>过去我非常热爱写代码，感觉我可以用代码去改变世界。现在我依然不否认这个观点，只是工作的原因，我今年写的代码较之往年，少之又少。可能写代码的时间少了，思考的时间就多了。</p><p>我们不得不承认，没有谁的代码会被永远维护或者供奉起来。也许明年就来了个家伙，说这段垃圾谁写了，老子要推掉重做，然后你的代码就删个精光。</p><p>技术人员很容易痴迷于“唯技术论”，觉得技术能搞定一切，特别是程序员这个物种。我曾经跟不懂技术的朋友争吵过，说你看身边什么东西不是代码和计算机造就的？且不说微信支付宝已经进入我们生活的方方面面，就连你去上厕所的自动马桶后面都是一行行代码。</p><p>这种想法是很危险的，在IT行业混了十年甚至二十年，你眼睛不应该只有技术了。你应该知道，技术都是为业务服务的。除了业务，你应该还要知道产品，商业甚至管理，资本家为什么会让这些人聚集在一起。</p><p>程序员在三十岁之后需要的不是更多的代码，而是更多的思考。</p><h2 id="说不见得比做容易"><a href="#说不见得比做容易" class="headerlink" title="说不见得比做容易"></a>说不见得比做容易</h2><p>今年我也成了一个PPT玩家，笑。</p><p>PPT玩家也是分段位的，青铜玩家会复制粘贴，白银玩家会套用模板，铂金玩家会归纳总结，钻石玩家会内容重构，星耀玩家会观点升华，王者玩家就人P合一。</p><p>玩笑归玩笑，PPT是不容易做的，一是归纳难，二是表达难。</p><p>归纳难的问题在于输入的量是否足够，PPT全程都是在输出观点，如果没有观点你的演讲就一文不值，纯粹是浪费观众时间。没有输入就没有输出，有时候做一个PPT要翻好几本书，写好几天Demo，只是为了证明自己的某个观点是OK的。现在看来，做PPT或者演讲或者写博客都是一样的套路，需要很好的逻辑思维和总结能力。</p><p><img src="https://tobyqin.github.io/images/image-20191224124720208.png" alt="image-20191224124720208"></p><p>只有你把自己说服了，才敢上台去。</p><p>关于表达难，这是很多程序员乃至中国人的通病。在程序员的世界里有一句名言：</p><blockquote><p>Talk is cheap, show me the code.</p><p>— Linus Torvalds</p></blockquote><p>然而这句话在大多数情况下不凑效，为什么呢？因为很多人还没学会表达就想秀代码，你问题都没说清楚，我何必看你代码。能说你才有机会秀。</p><p>在几个人面前说是一回事，在几十个人面前说又是另外一回事了。表达除了练习之外我觉得更多需要的是信心，而信心并不能通过反复练习获得。信心的程度主要是你由观点的认知程度和理解程度决定的。当你可以轻松去聊一个（技术）话题时，你如果不是有十足的把握，必定是有无敌的脸皮。</p><h2 id="读书不是为了打卡"><a href="#读书不是为了打卡" class="headerlink" title="读书不是为了打卡"></a>读书不是为了打卡</h2><p>所有人都知道，多读书是好的，那就多读一些吧。</p><p>其实不然，最近刚读完一本书，我觉得这些年的书都白读了，这本书叫《读懂一本书》。</p><p>读书不能看数量，也不能看速度，而是看自己到底收获了什么。读书的过程有可能是愉悦的，比如你在翻阅一本精彩的小说；也有可能是极其难熬的，比如你在看晦涩难懂的理论解说。</p><p>在读任何一本书前，我们要问自己一个问题，为什么我要翻这本书呢？为了解决某个问题还是为了身心愉悦，或者只是为了完成年度目标。读书是很苦的，如果真希望日后读书能给自己帮助，你就不得不思考这个问题。今天看一本霸道总裁，明天看一本盗墓笔记，到底是为了什么？</p><p>那么怎么读书呢？我们就要回到为什么上来。读书是为了解决什么问题，如果当前没有明确的问题，是不是就不用读书了？不是这样的。在《读懂一本书》里说，书是解决问题的出口，读一本书也许只要几小时或者几天，但有可能是作者几年甚至一辈子的经验，所以读书是稳赚不赔的买卖，当然前提是你知道自己要读哪本书，这是很难的。</p><p>要不然呢？那就多读书吧。选书可以有一个普遍适用的指导方法，就是TIPS原则。</p><ul><li>Tools： 工具类书籍，这是解决现有问题的指导原则</li><li>Ideas：灵感类书籍，带来新的理念，发现。可以是小说，历史，漫画等等</li><li>Practicability: 实用性书籍，可以给生活或者工作带来改变，可以被应用</li><li>Scientificity: 科学类书籍，对事实的归纳和验证过程</li></ul><p>以前我都是看豆瓣书单或者经朋友推荐看的书，当然不乏佳作，但是从没想过这些书读完的目的是什么，有点像在打卡。</p><p>选书完之后才是真正的读书。读书也不是从第一页一字不差看到最后一页就可以了，而是要去思考这本书给我带了什么，简单说就是做读书笔记，做阅读理解。</p><p>《读懂一本书》作者的要求更高，就是在读完一本书后能给别人再讲一遍，把思维导图用手画出来。能讲出来就意味理解或者消化了书中的观点，能讲多少就收获了多少。一旦真正去做这件事，这本书大概已经印在自己脑海里了。</p><p>我们常常犯的错误就是看完一本书就完了，勤快一点的也许会拍个照发个朋友圈，生怕忘了让朋友们也帮忙见证一下。还有些人喜欢拿笔在书本上画上重点或者圈喜欢的句子，但其实这跟买书是一样的性质。买了不代表你就看了，画了也不代表你就记住了。</p><p>读书是苦的，如果真想让书为我所用，我们的脑子就不得不做一些不开心的事情。</p><h2 id="闲下来才有创造力"><a href="#闲下来才有创造力" class="headerlink" title="闲下来才有创造力"></a>闲下来才有创造力</h2><p>今年明显比前两年忙了许多，今年的忙主要体现在非工作时间的支出上面。去年基本上还是可以保证在8点半出门，7点前回家的。今年大概都是8点出门，8点之后才到家，回家之后还有一半概率要开会占用半小时到一小时，能支配的非工作时间不会超过4小时。</p><p>在这4个小时里想一些新奇古怪的点子？难。我还要看书写字陪老婆呢。</p><p>当然，在地铁上会有两个多小时的时间可以支配。实际上我发现在地铁上我除了看小说听歌，不想干别的事情，在嘈杂的环境看技术或者处理工作上的事情是不可能的，除非万不得已。</p><p>最近看到有一篇报道说，微软要实现实行一周三休了。且不说羡慕，这样的制度在IT这样费脑子的行业推行我还是很赞同的。当你一直在忙碌时，喘气的机会都没多少，谈什么改革谈什么创新，基本都是在救火或者随大流。</p><p>闲下来才会有创造力，怎么样才能闲下来呢？</p><p>一，找老板谈，你需要筹码。</p><p>二，在自己身上找突破口。</p><p>其实忙不是理所当然的，有时候忙只是战略上的懒惰。我们可以略微分析一下自己在工作的时间安排，看看是不是真的做到了合理分配，最大效用。很多人都应该知道时间管理四象限，多做重要非紧急的，避免做非重要非紧急的。</p><p><img src="https://tobyqin.github.io/images/2019-12/3b0223f5d13442699fd3e64a0f19e441.jpeg" alt="img"></p><p>且不说工作之外的时间，先问问自己工作之内的时间是否做到了轻重缓急合理安排。正是因为今年忙了许多，我对时间管理又重视起来了，但是执行的还是不够好。</p><p>希望在明年自己真的能够闲下来，偶尔发发呆也是极好的。</p><h2 id="身体是革命的本钱"><a href="#身体是革命的本钱" class="headerlink" title="身体是革命的本钱"></a>身体是革命的本钱</h2><p>很庆幸今年自己还是维持了不错的锻炼频率，虽然没长出肌肉，但是每周两到三次的有氧运动也足以让我呼吸畅快，身心愉悦。</p><p>我们都还没到保温杯里泡枸杞的年龄，但是90后再过几天也30而立了，岁月不饶人。钱这辈子是挣不完的，但能开心地把挣到的花完也不错啊，别在医院里花就好。</p><p>今年的体检数据还不错，过两天去四川吃火锅，看熊猫，庆祝一下。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> thoughts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Mac上部署Jenkins</title>
      <link href="posts/2019-11-23/jenkin-on-mac/"/>
      <url>posts/2019-11-23/jenkin-on-mac/</url>
      
        <content type="html"><![CDATA[<p>Jenkins还是我最喜欢的CICD工具。</p><a id="more"></a><h2 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h2><p>官网目前推荐的方式是docker运行Jenkins，只需要一条命令就可以搞定。docker是很好用，不过也会有一些不方便的地方：</p><ul><li>不能完全访问本地磁盘，需要挂载后才可以，而挂载某个目录还需要提前在docker客户端注册，有点绕。</li><li>不能访问本地代理，大家都知道我们的网络条件不是很好，可能会自建代理，docker中使用代理也不方便。</li></ul><p>文件读写的问题有网友说可以通过rsync之类的软件解决，听上去可行，其实也不方便。所以到最后，我们可能还是选择在本地安装Jenkins。</p><p>本地安装最简单的办法是使用Howbrew包管理器。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install jenkins</span><br><span class="line">&#x3D;&#x3D;&gt; Downloading http:&#x2F;&#x2F;mirrors.jenkins.io&#x2F;war&#x2F;2.205&#x2F;jenkins.war</span><br><span class="line">&#x3D;&#x3D;&gt; Downloading from http:&#x2F;&#x2F;ftp-chi.osuosl.org&#x2F;pub&#x2F;jenkins&#x2F;war&#x2F;2.205&#x2F;jenkins.war</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">&#x3D;&#x3D;&gt; jar xvf jenkins.war</span><br><span class="line">&#x3D;&#x3D;&gt; Caveats</span><br><span class="line">Note: When using launchctl the port will be 8080.</span><br><span class="line"></span><br><span class="line">To have launchd start jenkins now and restart at login:</span><br><span class="line">  brew services start jenkins</span><br><span class="line">Or, if you don&#39;t want&#x2F;need a background service you can just run:</span><br><span class="line">  jenkins</span><br></pre></td></tr></table></figure><p>最新消息，官方已经发文不再支持macOS下的原生包安装，建议该用docker或者homebrew。</p><ul><li><a href="https://jenkins.io/blog/2019/11/25/macos-native-installer-deprecation/" target="_blank" rel="noopener">https://jenkins.io/blog/2019/11/25/macos-native-installer-deprecation/</a></li></ul><p>（原文继续）你也可以在官网选择适合MacOSX的pkg下载后双击开始安装，输入本机密码后就可以完成安装。这也开始里你的踩坑之旅。Jenkins安装完成后会默认启动，但是有可能你发现什么都没发生。坑开始来了。</p><ol><li>你本机需要有java的虚拟机环境，而且必须是8-11版本的，12以上的不支持（截止2019/12）</li><li>你本机的8080端口不能有别的服务</li></ol><p>你可以通过运行这个命令来进行启动测试：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh &#x2F;Library&#x2F;Application\ Support&#x2F;Jenkins&#x2F;jenkins-runner.sh</span><br></pre></td></tr></table></figure><p>你可以cat一下这个文件，执行的时候也是有回显的，比较容易知道问题出在哪。你还可以通过下面的命令来看本机有哪些目录和文件是Jenkins创建的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -iname &quot;*jenkins*&quot; 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><h2 id="配置-Jenkins"><a href="#配置-Jenkins" class="headerlink" title="配置 Jenkins"></a>配置 Jenkins</h2><p>在这个目录下面有一个简单的文档介绍了怎么配置Jenkins：</p><ul><li>/Library/Documentation/Jenkins/command-line-preferences.html</li></ul><p>当然，这些配置都是比较底层的，列出当前存在的配置项目：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ defaults read &#x2F;Library&#x2F;Preferences&#x2F;org.jenkins-ci</span><br><span class="line">&#123;</span><br><span class="line">    heapSize &#x3D; 512m;</span><br><span class="line">    httpPort &#x3D; 8080;</span><br><span class="line">    minHeapSize &#x3D; 256m;</span><br><span class="line">    minPermGen &#x3D; 256m;</span><br><span class="line">    permGen &#x3D; 512m;</span><br><span class="line">    tmpdir &#x3D; &quot;&#x2F;Users&#x2F;Shared&#x2F;Jenkins&#x2F;tmp&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改默认端口的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo defaults write &#x2F;Library&#x2F;Preferences&#x2F;org.jenkins-ci httpPort 8090</span><br></pre></td></tr></table></figure><p>可以配置的选项如下：</p><ul><li>prefix</li><li>httpPort</li><li>httpListenAddress</li><li>httpsPort</li><li>httpsListenAddress</li><li>war (Defaults to <code>/Applications/Jenkins/jenkins.war</code>)</li><li>JENKINS_HOME (Defaults to <code>/Users/Shared/Jenkins</code>)</li><li>tmpdir (Defautls to <code>/Users/Shared/Jenkins/tmp</code>) </li><li>minHeapSize (Defaults to 256m on 64bit architectures and 64m on 32bit)</li><li>heapSize (Defaults to 512m on 64bit architectures and 128m on 32bit)</li><li>minPermGen (Defaults to 256m on 64bit architectures and 64m on 32bit)</li><li>permGen (Defaults to 512m on 64bit architectures and 128m on 32bit)</li></ul><p>你可以删掉某个配置从而使用默认值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo defaults remove &#x2F;Library&#x2F;Preferences&#x2F;org.jenkins-ci JENKINS_HOME</span><br></pre></td></tr></table></figure><p>Jenkins 安装后默认会建立一个标准用户名为 jenkins，Jenkins 系统本身的配置会放在<code>JENKINS_HOME</code>目录里，这个目录上面已经提到，默认在 <code>/Users/Shared/Jenkins</code>，Jenkins 启动后的设置和安装的插件都会被放在这里，包括 job 的 workspace 等等。</p><p>Jenkins 默认的日志目录在 <code>/var/log/jenkins</code>，系统运行的错误和异常可以在这里找找。</p><h2 id="启动和停止-Jenkins"><a href="#启动和停止-Jenkins" class="headerlink" title="启动和停止 Jenkins"></a>启动和停止 Jenkins</h2><p>如果为了调试，可以用这个命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh &#x2F;Library&#x2F;Application\ Support&#x2F;Jenkins&#x2F;jenkins-runner.sh</span><br></pre></td></tr></table></figure><p>如果是正常使用，启动和停止的命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo launchctl load &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</span><br><span class="line">$ sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</span><br></pre></td></tr></table></figure><p>为了方便日后的管理，建议将这两条命令配置成 <code>alias</code> 放到你的 bash 启动脚本里，比如这样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># your ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">alias start-jenkins&#x3D;&quot;sudo launchctl load &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist&quot;;</span><br><span class="line">alias stop-jenkins&#x3D;&quot;sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist&quot;;</span><br></pre></td></tr></table></figure><h2 id="更新-Jenkins"><a href="#更新-Jenkins" class="headerlink" title="更新 Jenkins"></a>更新 Jenkins</h2><p>不出意外，按照 Jenkins 网页端的引导就可以完成 Jenkins 的更新。如果网络条件很差，你也可以到官网下载war包，然后替换 <code>/Applications/Jenkins/jenkins.war</code> 即可，期间需要手动停止和启动服务。</p><h2 id="卸载-Jenkins"><a href="#卸载-Jenkins" class="headerlink" title="卸载 Jenkins"></a>卸载 Jenkins</h2><p>通过Homebrew安装的软件卸载比较简单，这里说的主要是通过界面安装的Jenkins的卸载。Google搜出来的排在比较靠前的卸载方案是：</p><ol><li>手动删除 war 包</li><li>手动删除 <code>JENKINS_HOME</code> 目录</li><li>手动删除 jenkins 用户</li></ol><p>但其实不用那么麻烦，只需要一条命令即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh &#x2F;Library&#x2F;Application\ Support&#x2F;Jenkins&#x2F;Uninstall.command</span><br></pre></td></tr></table></figure><p>期间需要输入本机管理员密码，大致输出如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jenkins uninstallation script</span><br><span class="line"></span><br><span class="line">The following commands are executed using sudo, so you need to be logged</span><br><span class="line">in as an administrator. Please provide your password when prompted.</span><br><span class="line"></span><br><span class="line">+ sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</span><br><span class="line">Password:</span><br><span class="line">+ sudo rm &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist</span><br><span class="line">+ sudo rm -rf &#x2F;Applications&#x2F;Jenkins &#39;&#x2F;Library&#x2F;Application Support&#x2F;Jenkins&#39; &#x2F;Library&#x2F;Documentation&#x2F;Jenkins</span><br><span class="line">+ sudo rm -rf &#x2F;Users&#x2F;Shared&#x2F;Jenkins</span><br><span class="line">+ sudo rm -rf &#x2F;var&#x2F;log&#x2F;jenkins</span><br><span class="line">+ sudo rm -f &#x2F;etc&#x2F;newsyslog.d&#x2F;jenkins.conf</span><br><span class="line">+ sudo dscl . -delete &#x2F;Users&#x2F;jenkins</span><br><span class="line">+ sudo dscl . -delete &#x2F;Groups&#x2F;jenkins</span><br><span class="line">+ pkgutil --pkgs</span><br><span class="line">+ grep &#39;org\.jenkins-ci\.&#39;</span><br><span class="line">+ xargs -n 1 sudo pkgutil --forget</span><br><span class="line">Forgot package &#39;org.jenkins-ci.support.pkg&#39; on &#39;&#x2F;&#39;.</span><br><span class="line">Forgot package &#39;org.jenkins-ci.documentation.pkg&#39; on &#39;&#x2F;&#39;.</span><br><span class="line">Forgot package &#39;org.jenkins-ci.jenkins21903.postflight.pkg&#39; on &#39;&#x2F;&#39;.</span><br><span class="line">Forgot package &#39;org.jenkins-ci.launchd-jenkins.pkg&#39; on &#39;&#x2F;&#39;.</span><br><span class="line">Forgot package &#39;org.jenkins-ci.jenkins.osx.pkg&#39; on &#39;&#x2F;&#39;.</span><br><span class="line">+ set +x</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在Mac安装任何软件首选应该还是HomeBrew，不仅可以帮你搞定依赖，后续的升级和清理也很轻松。</p><p>在 Mac 上部署 Jenkins 有点像鸡肋，食之无味，弃之不舍。如果一定要在 Mac 上需要完成一些自动化的任务，同时希望配置简单友好，不知道你有没有更好的办法？</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> devops </tag>
            
            <tag> cicd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假期</title>
      <link href="posts/2019-10-12/vacation/"/>
      <url>posts/2019-10-12/vacation/</url>
      
        <content type="html"><![CDATA[<p>这个十一假期去了一趟大橙子家。大橙子很早就已经在网上买好了烧烤架，他说这个假期我们回去到乡下去烧烤。下车的时候我们去超市买了很多烧烤必备的原料。啊，美好的假期就要开始了。</p><a id="more"></a><p>乡下有狗有猫，还有兔子，其实不是兔子，是仓鼠。程明乐待业在家就买了一只仓鼠，还有一只猫。</p><p>早上起来空气无比清新，还有一大堆桂花树，非常香。可是这花是要被打掉的，大橙子的妈妈说，桂花都是要卖给村里收桂花的，虽然不值几个钱，但是也是几个钱。我觉得这些花这么香，被打掉太可惜了，所以我问能不能卖两株给我？</p><p>假期第二天，果然没有打桂花，但是第三天还是打了，只不过留了两株。</p><p>哦对了，烧烤也是一件非常快乐的事情。其实是吃的过程很快乐，但准备的过程中并不快乐。在大乡下很难买到羊肉，羊肉还是大程子的爸爸从县里的菜市场上买回来的，一只巨大的羊腿，差不多200块钱，8斤还是10斤记不清了。我和大橙子花了整整一个下午才处理完，一大半变成了80串羊肉串，还有一小半放在冰箱里。</p><p>小朋友们可喜欢吃羊肉串了，在我的童年记忆里除了玩耍，就是吃各种能吃和不能吃的。他们吃了一串又一串，除了羊肉，猪肉，还有烤火腿肠，烤小馒头，烤鱼。有趣的是，大橙子的妈妈去菜地里摘了两个非常非常小的茄子，说这可以给我们用来烤，烤茄子应该好吃。小叔还说菜地里有韭菜，可以给我们烤韭菜，结果那韭菜就跟程序员头上的头发一样稀少，怎么烤呢？</p><p>还有一件印象深刻的事情，就是有一天早上天还没亮，我觉得在肩膀上隐隐有东西在爬。开灯一看，吓死我了，是一只巨大的蜈蚣，估计有20厘米，趴在我肩上，直接给我咬了两口，有四道印子。蜈蚣咬的感觉真是很奇妙，就像小时候打预防针一样，扎的很疼很疼，而且这个疼是缓不过来的，会疼一整天。这是我人生第一次被蜈蚣咬，大橙子以为我要口吐白沫快不行了。一家人一大早都被吵起来了，大橙子爸爸和大橙子一样呆，想到的第一件事就是去抓一个大蜘蛛来，让大蜘蛛把蜈蚣的毒给吸出来，无奈没找到大蜘蛛，找到一个比米粒大点的蜘蛛，刚要往我伤口放，就不知道跑哪去了，这是什么偏方我没不太清楚。</p><p>还好，小叔一大早送我去了医院，一个坡脚医生给我开了一个乱七八糟的药，黑不溜丢的，然后往肩上抹，为啥不是酒精消毒呢？然后还要吃，吃就算了，结果一次要吃20片，20片啊，我的天呐。吃完20片还不算，再过6小时，还要再吃10片，我的天呐这哪是药啊，这感觉当饭吃了。不过被蜈蚣咬的感觉真不好，一天都是昏昏沉沉的，手臂感觉没有力气，会不会毒发身亡呢？</p><p>被蜈蚣咬那一天大橙子把屋里所有东西都搬出来了，感觉再也不敢进去住了。她考虑是不是要在露天搭一个大帐篷？无奈，晚上太困了又没有别的地方住，还是回去住吧，大不了再咬一口。</p><p>这次回乡下，没有遇到很一大群鹅，其实是遇到一大群鹅了，但这群鹅非常怂不厉害，有辱鹅的名声。它们不会上来抓人，上次回家的时候，有一群小鹅，小鹅虽小，但很勇敢，敢上前抓人，就算打不过也要上前抓，这种精神值得表扬。这次看见是一大群鹅，还带了一大群鸭子，这群鸭子也是非常怂的，我站在前面，就想拍个照片，它们都不敢过来，怎么的？我又不会抓你去烧烤。</p><p>假期还是过得太快了，感觉大部分时间都是躺在吊床上点手机，打游戏。书本翻了一点点，马上又要上班了，但这样也比去看人山人海好。</p><p>假期中间还看了两次国庆大阅兵，大橙子说一定要去看阅兵，祖国的骄傲呢。可是呢，她两次都睡着了，你说这是不是很搞笑的事情？</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aboutme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十月小记</title>
      <link href="posts/2019-10-06/october-notes/"/>
      <url>posts/2019-10-06/october-notes/</url>
      
        <content type="html"><![CDATA[<p>太忙了会导致自己没有创新力，现在在花旗的时间就是一天到晚在忙于工作，然后就没有太多时间去思考很多可以改进的方面。</p><a id="more"></a><p>相比以前在英孚自己的闲暇时间还是比较多，所以可以去想办法去改进工作上的流程，或者去做一些比较有意思的事情。而且到了花旗之后，博客更新的频率明显降低了很多。</p><p>一开始还是有想法要去写博客的，然后也会有一些主题要去写，但随着越来越忙，然后时间越来越少，所以就不太愿意去写，不太愿意去动笔，时间长了觉得这些主题写了也没什么意思，然后久而久之就不愿意去动笔了。从今天开始好像是要考虑去写这些博客的，因为时间久了不写博客，会觉得好像自己缺少了点什么。</p><p>时间一天天过去，但是没有发现自己累积的东西，这就是一种悲剧。从今天开始，我尝试用语音去记录一些东西，语音输入法还是比较快速，比较方便的记录方式。我可能只要说几分钟就可以把今天需要说的事情，或者这段时间要总结的东西就记录完了。</p><p>人不能太纵容自己，太纵容自己就会容易变得懒惰。</p><p>转眼间已经到年底了，现在已经开始进入年终总结阶段。想想这过来的6个月还是发生了很多事情，也学会了很多东西，但是好像也错过了很多东西。想想6个月前要接offer的时候还是很纠结的，真的很不确定面前这份工作能做好，然后会做成什么样子，实际上到现在看来的确这是一份非常有挑战性的工作，开发运维工程师不是开发也不是因为更不是测试，放弃自己最擅长的东西，去尝试这样一个岗位，未知的事情太多。</p><p>经过了6个月的适应，我现在发现开发运维不简简单单的是工具层面的自动化，或者是开发层面的自动化，更多的时候是一种资产层面的转变，还有文化层面的转变。这其实是非常难的，形而上学的东西并不像是看得见摸得着的东西，最大的问题并不是自己能不能接受这样的文化，而是让别人去接受这样的文化，别人的思想在别人的脑袋里，别人的工具在别人的手里，你想教别人怎么用，别人不一定这么用。</p><p>年底的总结并不是很好写，因为你也没办法拿出太多实际上的东西去说，大字报并不能够作为你的加分项，但大字报的确是我工作中的一部分。</p><p>我需要想办法让自己闲下来一点，这样的话我才可以有更多的时间去思考，真正意义上的改进，真正意义上的能够帮助到自己和帮助到团队的方法。</p><p>所谓旁观者清，当局者迷，如果你在局里，你是很难知道怎么去下棋的。</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aboutme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT基础技巧</title>
      <link href="posts/2019-09-21/basic-skills-of-ppt/"/>
      <url>posts/2019-09-21/basic-skills-of-ppt/</url>
      
        <content type="html"><![CDATA[<p>本文基于旁门左道PPT基础课程归纳而来。</p><a id="more"></a><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="导出格式"><a href="#导出格式" class="headerlink" title="导出格式"></a>导出格式</h3><p>PPT可以导出多种文件格式：</p><ol><li>图片，适合单页面预览，推荐png。</li><li>视频，适合动画预览，推荐mp4.</li><li>pdf，适合需要保留排版和平台兼容形式的分享。</li></ol><h3 id="撤销次数"><a href="#撤销次数" class="headerlink" title="撤销次数"></a>撤销次数</h3><p>在设置的高级选项里可以设置最大撤销次数为150，默认值是20，有点少。</p><h3 id="图片模糊"><a href="#图片模糊" class="headerlink" title="图片模糊"></a>图片模糊</h3><p>选中图片后选择虚化，默认虚化程度为10。可以通过格式窗格中的艺术效果修改虚化效果，一般改成60或者80会得到比较满意的结果。</p><h3 id="画面比例"><a href="#画面比例" class="headerlink" title="画面比例"></a>画面比例</h3><p>尽可能大的按屏幕比例设置画面比例，比如90cm x 30cm，而不是9cm x 3cm，这样可以提高画面清晰度。PPT有纵横画面的长度上限。</p><h3 id="显示参考线"><a href="#显示参考线" class="headerlink" title="显示参考线"></a>显示参考线</h3><p>通过视图选项卡显示参考线，可以添加和调整参考线，按住ctrl复制，按住alt可以微调。</p><h3 id="取色器"><a href="#取色器" class="headerlink" title="取色器"></a>取色器</h3><p>调出取色器后，从设计范围内开始按住鼠标左键不放，再将鼠标移出设计范围外就可以取到系统菜单甚至网页，或者其他非PPT软件的颜色，选到颜色后再放开鼠标左键。</p><h3 id="画布大小"><a href="#画布大小" class="headerlink" title="画布大小"></a>画布大小</h3><p>可以缩小画布在最上方和最下方很远处插入一个小形状，这样可以避免PPT放大后自动滚动到前面或者后面一页的问题。</p><h3 id="快速去除动画"><a href="#快速去除动画" class="headerlink" title="快速去除动画"></a>快速去除动画</h3><p>在PPT放映的下拉菜单里可以选择播放时不显示动画，这样可以快速去除动画效果。</p><h3 id="快速提取素材"><a href="#快速提取素材" class="headerlink" title="快速提取素材"></a>快速提取素材</h3><p>将PPT的文件后缀改成zip再解压，所有素材会在media目录里。</p><h3 id="等分页面"><a href="#等分页面" class="headerlink" title="等分页面"></a>等分页面</h3><p>比如要纵向等分页面，可以先添加纵向矩形，然后ctrl+d复制出等分数量的矩形，分别选中后对齐，排列，组合。最后将组合的图形拉伸为页面大小即可。横向等分操作亦然。</p><h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>任意一张PPT选择图片，在图片选项卡中可以选择压缩图片，选择所有图片进行压缩即可大大减少PPT的文件大小。</p><h3 id="嵌入字体"><a href="#嵌入字体" class="headerlink" title="嵌入字体"></a>嵌入字体</h3><p>在设置的保存选项中，可以选择将字体内嵌到PPT中，可以避免到别的电脑播放是缺少字体导致排版错乱的问题。推荐使用字客网下载各种免费字体。</p><h3 id="渐变形状"><a href="#渐变形状" class="headerlink" title="渐变形状"></a>渐变形状</h3><p>添加形状后选择渐变，并且调整透明度，最后将形状的层放置到文字和图片中间就可以做到类似蒙版的效果。如果图层很复杂，可以使用开始选项卡下的选择窗体来规划图层顺序。</p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>选择另存为后，在保存按钮左边有一个工具，里面可以设置两种密码：演示密码和修改密码。</p><h3 id="母版设置"><a href="#母版设置" class="headerlink" title="母版设置"></a>母版设置</h3><p>通过视图选项卡下的母版视图，可以快速批量调整PPT的整体样式，如果希望保留部分版式与主母版不一致，勾选不显示背景即可。母版是非常高效的操作，必须熟练掌握。</p><h3 id="图表动画"><a href="#图表动画" class="headerlink" title="图表动画"></a>图表动画</h3><p>SmartArt或者图标可以设置批量动画或者轮播动画，需要通过动画窗格将其他文字或者元素的动画合并到这些轮播动画中以达到同时展示的效果。</p><h3 id="镂空字体"><a href="#镂空字体" class="headerlink" title="镂空字体"></a>镂空字体</h3><p>先选择大图像，后选择需要镂空的文字或者形状，使用合并形状按钮中的剪除菜单可以做出镂空效果，在合并形状中菜单中还有其他非常棒的拆分形状工具。</p><h3 id="使用蒙版"><a href="#使用蒙版" class="headerlink" title="使用蒙版"></a>使用蒙版</h3><p>蒙版就是覆盖在目标画面上的一个图层，在PPT中一般通过添加和目标图片大小一致的形状并设置其颜色和透明度来实现，通常情况下还需要将蒙版层调整到图片上方，文字下方。</p><h2 id="高效操作"><a href="#高效操作" class="headerlink" title="高效操作"></a>高效操作</h2><h3 id="快速工具栏"><a href="#快速工具栏" class="headerlink" title="快速工具栏"></a>快速工具栏</h3><p>可以将工具栏移到主菜单下方，可以节约鼠标点击距离。然后将最最常用的工具添加到快速工具栏中可以大大提高工作效率。任意工具都可以通过右键添加到快速工具栏，在工具栏通过右键删除或者调整顺序。</p><ul><li>大神版：主题设置，图层调整，元素对齐，元素插入，格式调整，其他常用。</li></ul><p><img src="https://tobyqin.github.io/images/image-20190922211815182.png" alt="image-20190922211815182"></p><ul><li>基础版：基础工具，元素对齐，元素插入，格式调整。</li></ul><p><img src="https://tobyqin.github.io/images/image-20190922211847509.png" alt="image-20190922211847509"></p><h3 id="格式刷和动画刷"><a href="#格式刷和动画刷" class="headerlink" title="格式刷和动画刷"></a>格式刷和动画刷</h3><p>格式化可以快速复制文字或者形状的样式，动画刷可以复制动画效果。</p><h3 id="默认文本框和图形"><a href="#默认文本框和图形" class="headerlink" title="默认文本框和图形"></a>默认文本框和图形</h3><p>调整好的文本框或者图形可以通过右键设置为默认文本框或者图形，后面新添加的文本框和图形都会直接应该改样式。</p><h3 id="批量修改字体"><a href="#批量修改字体" class="headerlink" title="批量修改字体"></a>批量修改字体</h3><p>可以通过开始菜单的 “选择 / 字体” 菜单批量替换指定字体，还可以通过“设计/变体”菜单来统一修改中西文，标题或者正文字体，此方法更加灵活。</p><h3 id="使用母版"><a href="#使用母版" class="headerlink" title="使用母版"></a>使用母版</h3><p>母版有很多操作细节，多用多练习多思考。</p><h3 id="批量修改形状"><a href="#批量修改形状" class="headerlink" title="批量修改形状"></a>批量修改形状</h3><p>选中多个形状后，使用修改形状菜单即可。</p><h2 id="提升操作"><a href="#提升操作" class="headerlink" title="提升操作"></a>提升操作</h2><h3 id="设计和审美"><a href="#设计和审美" class="headerlink" title="设计和审美"></a>设计和审美</h3><p>核心是多看，看优秀作品，知道什么是美什么是丑。过一段时间后重新看自己的作品或者喜欢的作品，想想自己是否还喜欢。推荐设计作品网站：</p><ul><li>Dribbble</li><li>Behance</li><li>Zcool</li><li>Huaban</li></ul><p>PPT终归还是属于平面设计，所以可以借鉴平面设计的学习方式和思路。</p><h3 id="幻灯片的结构"><a href="#幻灯片的结构" class="headerlink" title="幻灯片的结构"></a>幻灯片的结构</h3><p>通常的PPT结构：封面，目录，子部分，内容，循环，尾页。良好的结构不仅可以帮作者理清思路，也可以让听众更容易接收要传达的信息。</p><h3 id="动画技巧"><a href="#动画技巧" class="headerlink" title="动画技巧"></a>动画技巧</h3><p>先制作镂空文字遮罩，然后将视频或者GIF置于文字下方，即可制作出比较生动的文字效果，让页面视觉效果更丰富。给镂空层添加一个基本缩放的动画，还可以让画面聚焦于核心内容。通过镂空图层配合路径动画，还可以做出有趣味的图表动画效果。</p><p>平滑效果真的很棒，不过需要升级到最新的Office 365 才可以使用。</p>]]></content>
      
      
      <categories>
          
          <category> Reprint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook和Vmware Tools</title>
      <link href="posts/2019-08-13/macbook%E5%92%8Cvmware-tools/"/>
      <url>posts/2019-08-13/macbook%E5%92%8Cvmware-tools/</url>
      
        <content type="html"><![CDATA[<p>Vmware tool 就是个坑，特别是在Mac电脑上。</p><a id="more"></a><p>我在MacBook上装了一个Vmware Workstation的虚拟机，然后在虚拟机里装了一个Windows系统。Windows可以正常启动，用着挺好的，但是发现不能从本机拷贝文件进去，或者把文件拷贝出来，它提示我说我没装Vmware Tools。</p><p>好的，我去网上搜了一通教程，并不能解决我如何安装Vmware Toools的问题，因为在虚拟机菜单里“安装Vmware Tools”是灰色的，什么办法都试过了，不行，就是灰色的。</p><p>好的，有人说自己去下载一个Vmware Tools的镜像安装一下就好了。我去官网找了一圈，找到了下载页面，但是并不能下载，需要注册。</p><p>好的，注册好了，我下了一个Mac版的Vmware Tools，解压，安装，有一些警告说不兼容最新版系统，没关系，试试看。安装完毕，提示重启电脑。</p><p>好的，电脑重启，进去桌面。没一会各种警告弹出来了，磁盘空间低？？怎么回事，我知道自己穷，256GB的硬盘我一直保留了20%的空间以防万一。好吧先删一些用不上的软件和文件吧，腾出20个G。没几分钟，磁盘空间又低？？是不是什么进程出问题了，重启看看。</p><p>重启过去10分钟，没进桌面，有种不祥的预感。Mac有没有安全模式？长按开机键再次重启。</p><p>又过了十分钟，勉强进去桌面，但是我看不懂上面的文字，它们全成了乱码。而且这些乱码并不能点击和操作，难道我可以换新电脑了？等了20分钟我决定再重启。</p><p>再一次重启系统提示我发送错误报告，好像有希望，我认识上面的字了。等个半小时，我先去洗个澡。回来之后可以操作了啊，不过就是卡，估计是因为磁盘塞满了。</p><p>这一次，我狠心卸载了几个大软件，启动Vmware Tools卸载程序，一顿操作之后再次重启。</p><p>好像世界已经恢复和平，不过我的硬盘空间去哪了？查了一下，在/cores下面生成了80Gb的文件，Google说这是系统崩溃的日志文件，可以删，那就删，老子终于又有了100多GB的余粮。</p><p>Vmware公司怎么可以发布这么垃圾的软件？难道都不经过测试的吗？幸亏我是盗版用户的受害者，不然一定赖着他们。</p><p>后来我才知道，Vmware Tools是需要安装到客户机的。我在虚拟机下载了一个Windows的Vmware Tools，安装完毕后重启虚拟机，可以和宿主机互通文件了。</p><p>妈蛋。</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOSX </tag>
            
            <tag> VMWare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转发短信的各种方案</title>
      <link href="posts/2019-06-25/various-schemes-for-forwarding-short-messages/"/>
      <url>posts/2019-06-25/various-schemes-for-forwarding-short-messages/</url>
      
        <content type="html"><![CDATA[<p>不知道你有没有使用多个手机号，或者手机不想带但又不希望错过短信的情况，有兴趣可以进来看一看。</p><a id="more"></a><h2 id="将手机A的短信自动转发到手机B"><a href="#将手机A的短信自动转发到手机B" class="headerlink" title="将手机A的短信自动转发到手机B"></a>将手机A的短信自动转发到手机B</h2><p>手机A和手机B大致分两种类型：安卓和苹果。所以交叉组合有4种情况。</p><h3 id="1-安卓转发苹果"><a href="#1-安卓转发苹果" class="headerlink" title="1. 安卓转发苹果"></a>1. 安卓转发苹果</h3><p>方案1：</p><p>装一个绿芽短信让它运行在后台，通过微信就可以远程接收和回复短信，这是目前最简单的方案，不需要翻墙，唯一担心小厂跑路。不过看上去不会那么容易死，毕竟它不是纯免费的，有转发额度，需要适当付费。这个方案在知乎和各大网站都被强烈推荐，不太像水军，我试用了一下感觉良好，而且这个软件已经活了三四年了。</p><p>方案2：</p><p>装一个IFTTT，短信可以转发为邮件，Telegram，pushover等等渠道，这些渠道应该是靠得住的，不过IFTTT和这些渠道都是要科学上网的，也就是说这个你还需要一个常年稳定可靠不变的梯子。而且这种方案只能收短信，不能回短信。</p><p>方案3：</p><p>装一个Tasker，Tasker是安卓阵营的一个神器，相当于macOS上的Automator或者方案2的IFTTT，帮你监听手机上的任何事件然后执行你想要的任务。有了Tasker之后的操作和IFTTT差不多，不过整个过程都是在手机本地运行的，比如转发短信或者发送邮件调用推送api，干啥都行。这个方案需要动手能力和编程思维，而且Tasker是否足够稳定不能确定。</p><p>值得一提的是，苹果上有一个叫Bark的软件非常棒，安装后会根据设备给你一个http的链接，你只要GET这个链接（允许带参数）就可以往设备推送消息。有了这个软件往iOS设备推送消息不要太简单。</p><h3 id="2-安卓转发安卓"><a href="#2-安卓转发安卓" class="headerlink" title="2. 安卓转发安卓"></a>2. 安卓转发安卓</h3><p>大致方案和安卓苹果差不多，如果不关心手机型号的话。如果家里的安卓机和携带的安卓机是一样的，可以借助手机厂商的云备份服务来自动同步短信，例如两个手机登录同一个魅族账号，同一个小米账号，同一个华为账号等等。</p><p>当然，安卓手机大多是双卡双待的，理论上不太会有这种需求，除非你人在国外或者你是黄牛？</p><h3 id="3-苹果转发安卓"><a href="#3-苹果转发安卓" class="headerlink" title="3. 苹果转发安卓"></a>3. 苹果转发安卓</h3><p>对不起，这条路你走不通，至少我没走通。</p><h3 id="4-苹果转发苹果"><a href="#4-苹果转发苹果" class="headerlink" title="4. 苹果转发苹果"></a>4. 苹果转发苹果</h3><p>两个手机都登录同一个iCloud账号就可以了，在iMessage里可以看到转发消息的选项，通过另外一个苹果手机还可以远程回复。</p><p>除了两大主流阵营，还有非主流的诺基亚塞班或者MTK山寨机，咸鱼买一个一两百块，设置自动转发，不过要消耗短信费用，一次一毛。下单前确保有这样的功能。对安全和隐私比较看重的可以试试。</p><p>手机待机转发有一个最致命的问题，就是充电问题。如果一直插着充电器不知道电池会不会爆掉，不充电又不知道什么时候死掉，照顾这样一个设备还真有点麻烦。网上有同学说买个智能插座定时充放电，但智能插座怎么知道手机饿了？用Tasker可以监控啊，感觉解决一个问题的同时带来了N个问题，宅男的快乐你很难理解。</p><h2 id="通过设备转发短信"><a href="#通过设备转发短信" class="headerlink" title="通过设备转发短信"></a>通过设备转发短信</h2><p>这里说的设备就不是手机了，比如树莓派，路由器，或者专门的转发设备。</p><h3 id="1-树莓派"><a href="#1-树莓派" class="headerlink" title="1. 树莓派"></a>1. 树莓派</h3><p>树莓派是宅男和极客们喜欢的东西，不过你需要额外买一个读卡器来读取sim卡，然后再写一段代码来处理短信事件和推送过程。树莓派常年开机或者定时开关机问题都不大，毕竟是被无数人论证过的产品，可靠性比大多数手机和电脑都强很多。不过你应该懂的，这一套方案是花不少时间和精力的。树莓派本身可以当成一个微型的Linux服务器跑很多程序和服务，转发短信只能算其中一种吧。</p><h3 id="2-路由器"><a href="#2-路由器" class="headerlink" title="2. 路由器"></a>2. 路由器</h3><p>普通的路由器当然是不可能有这样的功能的啦，能转发短信的路由器肯定都是能刷机的，比如网件，华硕或者斐com之类的，能刷机的路由器基本上就可以把路由器当成树莓派啦，本身也是Linux系统，接个USB跑个程序也是小case，而且路由器7x24小时在线，稳定性更佳。相对于树莓派，路由器也是科技宅们喜爱的玩具，不过宅的level可能更高。</p><p>关于怎么用树莓派和路由器来实现转发，GitHub上有很多现成方案，这里就不展开说了，大致思路就是获取消息后调用各种的API，最常用的如Telegram，pushover，SMTP等待。</p><h3 id="3-专业设备"><a href="#3-专业设备" class="headerlink" title="3. 专业设备"></a>3. 专业设备</h3><p>有市场就有需求啦，淘宝一搜就知道世界原来那么大。比如上文提到的绿芽就有转发机卖，一百多块不贵。还有云手机服务，按月收费，还有真人代发代收，五花八门，可信度未知。</p><p>不过我到想起来前些年还有阿里小号或者电信小号这样的app，按月交费然后给你分配一张虚拟卡。当时还用来打车叫外卖薅羊毛，如果这种小号还可用，也不失为一种短信接收的好方法。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>新款苹果设备也支持双卡双待了，携号转网也越来越近了，在国内应该不太有转发短信这种需求了吧。</p><p>不过在国外的朋友，还是很希望能收到国内手机号的短信的，以上方案对于远在异乡的人，其实都不太靠谱，你敢充电器插着手机然后安心出国吗？</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SMS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦浪传</title>
      <link href="posts/2019-06-02/qin-lang-chuanmd/"/>
      <url>posts/2019-06-02/qin-lang-chuanmd/</url>
      
        <content type="html"><![CDATA[<p>程浪，程家人，生性浪荡。</p><a id="more"></a><p>不为时间左右，不问利益得失。善摸索，凡事三问what，when，why，又名程三摸。</p><p>零八年初，年二十。春风来，情窦开。校操场散步，识一男，徘徊其右。</p><p>树下，花前，烧烤摊旁，二年有余，无不欢快。学业成，踏足魔沪，誓出人头地。</p><p>未完待续。</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会人口头禅</title>
      <link href="posts/2019-05-20/head-chan-of-social-population/"/>
      <url>posts/2019-05-20/head-chan-of-social-population/</url>
      
        <content type="html"><![CDATA[<p>大过节的、多大点事、都是亲戚、别太计较；<br>还是孩子、那么努力、看我面子、都不容易；<br>朋友一场、算了算了、换位思考、为了你好；<br>人都死了、吃亏是福、将心比心、没有恶意；<br>开玩笑的、才刚毕业、都过去了、习惯就好；<br>他喝多了、毕竟长辈、退一步讲、都在酒里；<br>曾经爱过、互相理解、婚都结了、还能咋地；<br>他说话直、都打工的、想开一点、都能过去；<br>来都来了、买都买了、岁数大了、顾客上帝；<br>我这好的、你再试试、需求没写、环境问题。</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> joke </tag>
            
            <tag> fun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笑话一则</title>
      <link href="posts/2019-05-15/a-joke/"/>
      <url>posts/2019-05-15/a-joke/</url>
      
        <content type="html"><![CDATA[<p>所谓殊途同归，讲的是以前所有当飞行员、科学家、政治家梦想的中国小朋友们。  </p><p>成年以后的梦想统一变为买房……</p>]]></content>
      
      
      <categories>
          
          <category> Thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> joke </tag>
            
            <tag> fun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用命令行在Linux同步坚果云</title>
      <link href="posts/2019-05-06/jianguoyun-command-line/"/>
      <url>posts/2019-05-06/jianguoyun-command-line/</url>
      
        <content type="html"><![CDATA[<p>坚果云更Linux也可以配合的很好。</p><a id="more"></a><h2 id="开启WebDAV"><a href="#开启WebDAV" class="headerlink" title="开启WebDAV"></a>开启WebDAV</h2><p>在坚果云网页端可以找到WebDAV的管理界面，开启后就可以得到一个密钥。</p><p><img src="https://tobyqin.github.io/images/image-20190506210443671.png" alt="image-20190506210443671"></p><p>有图形界面的操作系统坚果云都提供客户端了，现在我希望添加到坚果云的某个目录的文件能够自动checkin到github，从而实现随时写博客之类的功能。</p><h2 id="cURL读取-WebDAV-目录文件"><a href="#cURL读取-WebDAV-目录文件" class="headerlink" title="cURL读取 WebDAV 目录文件"></a>cURL读取 WebDAV 目录文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PROPFIND --user <span class="string">'user@xxx.com:password'</span> <span class="string">'https://dav.jianguoyun.com/dav/Blog/@TODO'</span></span><br></pre></td></tr></table></figure><p>以上命令会返回这个目录里所有的信息，不过是xml的，不太好处理。</p><h2 id="Python-读取-WebDAV目录文件"><a href="#Python-读取-WebDAV目录文件" class="headerlink" title="Python 读取 WebDAV目录文件"></a>Python 读取 WebDAV目录文件</h2><p>只要能找到合适的包，Python 做什么都很容易，读取 WebDAV 目前我发现 <a href="https://pypi.org/project/fs.webdavfs/" target="_blank" rel="noopener">fs.webdavfs</a> 相对好用一点。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install fs.webdavfs</span><br></pre></td></tr></table></figure><p>读取目录的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jg_sync.py</span></span><br><span class="line"><span class="keyword">from</span> webdavfs.webdavfs <span class="keyword">import</span> WebDAVFS</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://dav.jianguoyun.com/dav'</span></span><br><span class="line">options = &#123;</span><br><span class="line">    <span class="string">'login'</span>: <span class="string">'user@xxx.com'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'password'</span>,</span><br><span class="line">    <span class="string">'root'</span>: <span class="string">'/Blog/@TODO'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs = WebDAVFS(url, **options)</span><br><span class="line">files = fs.listdir(<span class="string">'.'</span>)[<span class="number">1</span>:]</span><br><span class="line">print(<span class="string">'\n'</span>.join(files))</span><br></pre></td></tr></table></figure><h2 id="下载-WebDAV-文件"><a href="#下载-WebDAV-文件" class="headerlink" title="下载 WebDAV 文件"></a>下载 WebDAV 文件</h2><p>推荐用 cCURL 而不是 Python，Python 下载文件会有各种异常，中文编码或者路径什么的很不灵光，折腾了我半天都没弄好，还是 cURL 简单粗暴。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Update from jianguoyun..."</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(dirname "$0")</span>"</span></span><br><span class="line">files=$(python3 jg_sync.py)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">urlencode</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $(python3 -c <span class="string">"import urllib.parse; print (urllib.parse.quote('''<span class="variable">$1</span>'''))"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">download_file</span></span>() &#123;</span><br><span class="line">    cmd=<span class="string">"curl -u 'user:pass' 'https://dav.jianguoyun.com/dav/Blog/@TODO/_remote_' -o '@TODO/_local_'"</span></span><br><span class="line">    cmd=<span class="string">"<span class="variable">$&#123;cmd/_local_/$1&#125;</span>"</span></span><br><span class="line">    cmd=<span class="string">"<span class="variable">$&#123;cmd/_remote_/$2&#125;</span>"</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">delete_remote_file</span></span>() &#123;</span><br><span class="line">    cmd=<span class="string">"curl -X DELETE -u 'user:pass' 'https://dav.jianguoyun.com/dav/Blog/@TODO/_remote_'"</span></span><br><span class="line">    cmd=<span class="string">"<span class="variable">$&#123;cmd/_remote_/$1&#125;</span>"</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IFS=<span class="string">'</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$files</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Download <span class="variable">$file</span>"</span></span><br><span class="line">    encoded_name=$(urlencode <span class="string">"<span class="variable">$file</span>"</span>)</span><br><span class="line">    download_file <span class="string">"<span class="variable">$file</span>"</span> <span class="string">"<span class="variable">$encoded_name</span>"</span></span><br><span class="line">    delete_remote_file <span class="string">"<span class="variable">$encoded_name</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>在脚本开始部分先通过 Python 获取 WebDAV 的目录中的文件，然后用cURL把文件拉到本地，接着从远端目录删掉这个文件。</p><p>上面步骤完成后文件就会被下载到本地的 @TODO 目录，再把这个目录里的文件稍作加工，就可以发布了。</p><h2 id="上传文件到-WebDAV"><a href="#上传文件到-WebDAV" class="headerlink" title="上传文件到 WebDAV"></a>上传文件到 WebDAV</h2><p>从简单而言，还是用cURL：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">upload_file</span></span>() &#123;</span><br><span class="line">    cmd=<span class="string">"curl --user 'user:pass' -T '_local_' 'https://dav.jianguoyun.com/dav/Blog/_remote_'"</span></span><br><span class="line">    cmd=<span class="string">"<span class="variable">$&#123;cmd/_local_/$1&#125;</span>"</span></span><br><span class="line">    cmd=<span class="string">"<span class="variable">$&#123;cmd/_remote_/$2&#125;</span>"</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个方法，就可以实现反向从git同步文件到坚果云。</p><h2 id="其他一些心得"><a href="#其他一些心得" class="headerlink" title="其他一些心得"></a>其他一些心得</h2><p>其实还可以通过百度云做中转，使用 <a href="https://github.com/houtianze/bypy" target="_blank" rel="noopener">bypy</a> 这个包，纯 Python 实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip insall bypy</span><br><span class="line">bypy info</span><br><span class="line">bypy upload ...</span><br><span class="line">bypy download ...</span><br></pre></td></tr></table></figure><p>同步脚本写完后，可以用<a href="https://crontab.guru/" target="_blank" rel="noopener">crontab</a>在你的云主机上定时执行，比如没10分钟去坚果云查询一下，如果有就做后续操作。</p><p>Python 操作 WebDAV的包不是特别多，好用的更少。</p><p>使用cURL操作WebDAV是也要注意文件名中编码的问题，比如中文，空格，特殊字符都需要转义。</p><p>更多cURL的操作可以google或者看<a href="https://www.qed42.com/blog/using-curl-commands-webdav" target="_blank" rel="noopener">这篇文档</a>。</p><p>还有一个办法是把 WebDAV 挂载到Linux上，大概搜索了一下 <a href="https://wiki.archlinux.org/index.php/Davfs2" target="_blank" rel="noopener">davfs2</a> 发现也挺折腾的，不去弄了。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webdav </tag>
            
            <tag> jianguoyun </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 MacOSX 上 准备 Jekyllrb 环境的坑</title>
      <link href="posts/2019-04-28/jekyllrb-error-on-macosx/"/>
      <url>posts/2019-04-28/jekyllrb-error-on-macosx/</url>
      
        <content type="html"><![CDATA[<p>Jekyllrb还是有必要了解一下。</p><a id="more"></a><h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>弄了半天把Ruby和Gem环境弄好，运行 <code>bundle install</code> 后报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bundle install                                                                                                                                                         Traceback (most recent call last):</span><br><span class="line">    1: from &#x2F;Users&#x2F;ivolooser&#x2F;gems&#x2F;bin&#x2F;bundle:23:in &#96;&lt;main&gt;&#39;</span><br><span class="line">&#x2F;Users&#x2F;ivolooser&#x2F;gems&#x2F;bin&#x2F;bundle:23:in &#96;load&#39;: cannot load such file -- &#x2F;usr&#x2F;local&#x2F;lib&#x2F;ruby&#x2F;gems&#x2F;2.6.0&#x2F;gems&#x2F;bundler-1.17.2&#x2F;exe&#x2F;bundle (LoadError)</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>把需要的Bundle版本全都给它装上，现在错误的是没有1.17.2，那么开装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem install bundler -v &#39;1.17.3&#39;                                                                                                                                        Successfully installed bundler-1.17.3</span><br><span class="line">Parsing documentation for bundler-1.17.3</span><br><span class="line">Done installing documentation for bundler after 3 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure><p>再运行 <code>bundle install</code>，还是报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Can&#39;t find gem bundler (&#x3D; 1.11.2) with executable bundle (Gem::GemNotFoundException)</span><br></pre></td></tr></table></figure><p>应该是<code>Gemfile.lock</code>里写死了指定版本的Bundler才可以运行网站，那么再装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem install bundler -v &#39;1.11.2&#39;                                                                                                                                        Successfully installed bundler-1.11.2</span><br><span class="line">Parsing documentation for bundler-1.12.2</span><br><span class="line">Done installing documentation for bundler after 3 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure><p>再来运行 <code>bundle install</code>，搞定。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bundle install   </span><br><span class="line">...</span><br><span class="line">Bundle complete! 10 Gemfile dependencies, 30 gems now installed.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jekyllrb </tag>
            
            <tag> ruby </tag>
            
            <tag> bundler </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>山村咏怀</title>
      <link href="posts/2019-04-27/life-peom/"/>
      <url>posts/2019-04-27/life-peom/</url>
      
        <content type="html"><![CDATA[<blockquote><p>【宋代】邵雍</p></blockquote><p>一去二三里，烟村四五家。</p><p>亭台六七座，八九十枝花。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker一篇通</title>
      <link href="posts/2019-04-20/docker-in-one-day/"/>
      <url>posts/2019-04-20/docker-in-one-day/</url>
      
        <content type="html"><![CDATA[<p>Docker作为当今最流行的容器技术，我们还是需要紧跟时代努力学习，避免被公司优化掉。本文以轻松愉快的方式介绍了我对容器的认识，需要深入的同学建议多多查阅<a href="https://docs.docker.com/engine/docker-overview/" target="_blank" rel="noopener">官方文档</a>。</p><a id="more"></a><h2 id="为啥要-Docker"><a href="#为啥要-Docker" class="headerlink" title="为啥要 Docker"></a>为啥要 Docker</h2><p>千言万语不如一张图：</p><p><img src="https://tobyqin.github.io/images/image-20190420141039942.png" alt="image-20190420141039942"></p><p>来源： <a href="https://www.docker.com/why-docker" target="_blank" rel="noopener">https://www.docker.com/why-docker</a></p><p><strong>简单总结：</strong></p><ol><li>更少的部署时间，更高的交付效率balabala，反正很厉害</li><li>老板花更少的资源，做更多的事</li><li>员工花更少的时间，做更多的事（加量不加价？）</li></ol><p>总之，Docker可以让你和你的企业变得很牛很潮，甚于内裤外穿。</p><h2 id="啥是-Docker"><a href="#啥是-Docker" class="headerlink" title="啥是 Docker"></a>啥是 Docker</h2><p>再来一张图：</p><p><img src="https://tobyqin.github.io/images/image-20190420141741582.png" alt="image-20190420141741582"></p><p>来源： <a href="https://www.docker.com/resources/what-container" target="_blank" rel="noopener">https://www.docker.com/resources/what-container</a></p><p>简单总结：</p><ol><li>Docker 是容器技术的一种实现，是当下最流行的（不代表以后还是它）</li><li>容器相对于虚拟机更轻量，但是能实现和虚拟机几乎一样的功能</li><li>虚拟机需要上G的磁盘空间外加和真实环境等效的CPU，内存</li><li>容器只需要运行写入的磁盘空间（MB级），能使用宿主机全部CPU，内存</li></ol><p>打通俗一点的比分，独立的物理机是别墅，花园车库都是你的；虚拟机是楼盘卖的各种公寓，有独立的客厅卧室；容器是酒店里的房间，大部分资源都是公用的。</p><p>那为啥我不住别墅而住酒店呢？别墅不仅贵还要养管家，高档的酒店不见得比别墅和公寓差，但成本和管理效率高多了。</p><h2 id="怎么实现容器化"><a href="#怎么实现容器化" class="headerlink" title="怎么实现容器化"></a>怎么实现容器化</h2><p>我们可以把容器化流程一般化，例如作为软件发布方，流程大抵如此：</p><p><img src="https://tobyqin.github.io/images/image-20190420151830272.png" alt="image-20190420151830272"></p><p>所谓基础镜像，你可以简单理解成操作系统。发布方需要把自己的软件和基础镜像打包后推送到仓库，就算容器化了。</p><p>注意，你要打包的不光是软件本身，还有各种配置过程，比如修改文件，修改权限，打开端口等等。</p><p>关于Docker镜像，我们可以看作千层饼，基础镜像是最下面一层，每添加一个功能（命令）就往上叠一层，看官方这个图：</p><p><img src="https://tobyqin.github.io/images/2019-04/container-layers.jpg" alt="Layers of a container based on the Ubuntu image"></p><p>基础层是Ubuntu，上面的4层分别代表了加了4次功能，比如：</p><ol><li>Add file1</li><li>Install app1</li><li>Install app2</li><li>Change permission</li></ol><p>每一次运行命令都会生成一个层（Layer），每个层都是可以复用的。比如在任意层打上标签后发布，或者在下次制作镜像时加以利用（缓存加速）：</p><ol><li>Add file1 （秒完成）</li><li>Install app1 （秒完成）</li><li>Install app3 （新的Layer）</li><li>Change permission （新的Layer，上一步的Layer不一样）</li></ol><p>打包出来的镜像层是只读的，当镜像被运行后就会生成容器，每个容器都只是对镜像附加了一个可写层，所以资源利用率很高。</p><p>了解完生产方的流程后，我们来看一下消费方的流程：</p><p><img src="https://tobyqin.github.io/images/image-20190420155230888.png" alt="image-20190420155230888"></p><p>作为消费方，可以用来去自如，为所欲为来描述容器化后的世界：</p><ol><li>我想要啥就去仓库Pull一下</li><li>运行容器，不必担心配置繁琐，环境差异这种烦心事</li><li>这镜像功能不错 - 那就让它跑着</li><li>这镜像是个乐色 - 分分钟删了它</li></ol><p>有了容器，开发的锅更难甩掉了，因为你是容器的爹，也是容器的妈。测试运维找上门，你再也不敢说在我这明明是好的啊。</p><h2 id="容器化的限制"><a href="#容器化的限制" class="headerlink" title="容器化的限制"></a>容器化的限制</h2><p>容器化的实现源于Linux系统本身的一种特性，叫<a href="https://en.wikipedia.org/wiki/OS-level_virtualisation" target="_blank" rel="noopener">系统级虚拟化</a>（OS-level virtualisation）。早在10多年前在Google已经广泛应用，对，Google那个糟老头坏的很，用了那么久都不跟我们说容器真香。等Docker火了以后它才说光Docker不够，你们还需要Kubernets。</p><p>![docker fun](<a href="https://tobyqin.github.io/images/docker" target="_blank" rel="noopener">https://tobyqin.github.io/images/docker</a> fun.jpeg)</p><p>这张图经常出现在我们视线，为啥鲸鱼和企鹅还有老鼠在一起啊？鲸鱼代表着Docker，企鹅代表着Linux，老鼠代表着Go语言。Docker运行的基础是Linux，它是由Go语言编写的，哦原来Docker和它爹它妈在聚餐呢。</p><p>既然容器化原理离不开Linux特性，那么容器化的限制也显而易见：</p><ol><li>你的应用必须能跑在Linux上</li><li>你的应用应该是无状态的 - 允许随起随停</li></ol><p>举例说明，适合容器化的应用：</p><ul><li>前端服务，微服务，无状态任务</li></ul><p>不合适容器化的应用：</p><ul><li>数据库，数据库，数据库</li></ul><p>为啥数据库不适合容器化啊？第一，数据库是有状态的；第二，数据库不是想起就起想停就停的，数据安全大过天；第三第四第五网上写了一堆展开可以另写一篇。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>容器化还有一些最佳实践：</p><ol><li>一个容器只运行一个应用</li><li>使用镜像来交付应用，不要直接部署</li><li>分层构建容器，尽可能减少层的数量</li><li>不要把本地运行的容器转成镜像</li><li>不要将数据存储在容器中</li></ol><h3 id="Windows容器"><a href="#Windows容器" class="headerlink" title="Windows容器"></a>Windows容器</h3><p>你可能听过<a href="https://www.microsoft.com/zh-cn/cloud-platform/containers" target="_blank" rel="noopener">Windows容器</a>，是有那么一回事，但是当前还不是很成熟，勇敢你的可以尝试，但你的老板大概是不会让它跑在生产环境的。据说携程已经将Windows容器化应用到生产了，牛Pi（破音）！</p><h2 id="容器的优缺点"><a href="#容器的优缺点" class="headerlink" title="容器的优缺点"></a>容器的优缺点</h2><p>优点显而易见，随便列几个：</p><ol><li>比VM小，比VM快，比VM便宜</li><li>更容易发布和维护，有效避免DEV，QA，OPS的撕逼</li><li>社区非常活跃，国外有谷歌微软亚马逊，国内有BAT做先驱</li></ol><p>那么缺点呢？并不是太多，不信你到网上找找看，大多是为赋新词强说愁，简单列举：</p><ol><li>平台限制，目前只支持Unix/Linux应用，只支持64位系统</li><li>相对于直接部署应用，性能会差一些</li><li>学习和迁移成本，取决于现有架构和资源</li><li>Docker公司决策有点迷，很多言论说它要挂了</li></ol><p>理论讲完了，我们进入实操环节。</p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>现在Docker的安装非常傻瓜，只要从<a href="https://download.docker.com/" target="_blank" rel="noopener">官网下载</a>对应平台的安装包点击几下就可以安装完成。你需要知道：</p><ol><li>Windows用户需要开启<a href="https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-must-be-enabled" target="_blank" rel="noopener">CPU虚拟化</a>，配置4G内存以上，Windows 10 / 64位系统</li><li>早期版本的Windows可以考虑使用<a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a>或通过Linux虚拟机来安装</li><li>MacOSX用户建议<a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">下载Docker Desktop</a>后安装，用Brew会更麻烦</li><li>Linux用户最简单最野生，用各种包管理器就可以装，例如：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker     # centos / redhat</span><br><span class="line">apt-get install docker # ubuntu</span><br></pre></td></tr></table></figure><p>坑：在Windows下，Docker和Genymotion是有冲突的，一个要开CPU虚拟化，一个要关CPU虚拟化，二者势不两立，目前没有好的解决办法。</p><p>我们装的Docker都是CE（Community Edition）版，另外Docker还提供了企业版。</p><table><thead><tr><th align="left">Capabilities</th><th align="center">Docker Engine - Community</th><th align="center">Docker Engine - Enterprise</th><th align="center">Docker Enterprise</th></tr></thead><tbody><tr><td align="left">Container engine and built in orchestration, networking, security</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="left">Certified infrastructure, plugins and ISV containers</td><td align="center"></td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="left">Image management</td><td align="center"></td><td align="center"></td><td align="center">Yes</td></tr><tr><td align="left">Container app management</td><td align="center"></td><td align="center"></td><td align="center">Yes</td></tr><tr><td align="left">Image security scanning</td><td align="center"></td><td align="center"></td><td align="center">Yes</td></tr></tbody></table><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><p>在Windows / MacOSX中，双击小鲸鱼就可以启动Docker，启动成功后在通知区域就可以看到Docker的图标。</p><p>坑：在Windows / MacOSX 中居然真的只能通过图形来重启或者停止Docker服务？！</p><p>在Linux 中需要使用命令行来管理 Docker 服务，以CentOS 7为例。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">systemctl enable docker # auto start when boot</span><br></pre></td></tr></table></figure><p>我们平时说的Docker一般是指Docker Engine，前面提到的安装启动Docker指的都是Docker Engine，这个Engine提供了一系列功能：</p><ol><li>管理镜像比如：拉取镜像，打包镜像，推送镜像</li><li>管理容器比如：运行容器，停止容器，诊断容器</li></ol><p>如果Docker Engine已经启动成功，在命令行（Windows建议PowerShell，MacOSX，Linux建议Bash）中就可以通过下面两个命令检查其运行状态。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p>反之，如果Docker Engine没启动，那么就会有类似的错误。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><p>Docker 大部分操作都是通过命令行来完成的，对你还记得Windows和MacOSX的那个图像客户端，他们可以干什么？简单说他们除了用来启动和退出Docker外，还可以用来配置仓库源和网络代理地址，别的功能你就忘了吧。</p><p>还有，在中华大地，使用Docker前最好还是先<a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">配置国内的源</a>，不然镜像会拉的很慢，便秘的感觉。</p><p>万事俱备，我们来一个Docker Hello World：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run hello-world</span></span><br><span class="line">Unable to find image 'hello-world:latest' locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:92695bc579f31df7a63da6922075d0666e565ceccad16b59c3374d2cf4e8e50e</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br></pre></td></tr></table></figure><p>运行完这个命令，以后出去面试你就可以跟面试官说自己精通Docker和容器化技术了。</p><p>面试官再追问，你就说 Docker 命令太多了，我一般都是通过<code>docker --help</code> 查阅的。当然啦，咱也不水的，Docker 命令我说起来也是一套一套的，不信你往下看。</p><p>再说说这个Hello World，你发现没有，作为消费方，其实你只要一个<code>docker run &lt;image&gt;</code> 命令就够了，Docker足够聪明，如果这个<code>&lt;image&gt;</code> 不存在，那么它就会仓库里找，找到了就自动pull，然后运行起来。</p><p>回到工作中，如果开发同学做完了一个需求，是不是告诉你这个<code>run</code>命令的具体参数就可以测试和发布了呢？（基本）是的！天啊，开发同学太厉害了，他变强了，也变秃了。</p><p><img src="https://tobyqin.github.io/images/strong.jpg" alt=""></p><p>聪明的你可能想到了，在社会人维护的Docker仓库里，其实包含了很多打包好的软件镜像，你只要<code>docker run</code>就行，比如jenkins，sonarqube，redis，kafka，你能想到的全都有。天啊，原来用Docker整一个玩耍的环境那么简单！</p><h3 id="命令速记"><a href="#命令速记" class="headerlink" title="命令速记"></a>命令速记</h3><p>也许你知道一些Docker命令，比如：</p><ul><li>docker run</li><li>docker images</li><li>docker ps</li><li>docker rename</li><li>docker rm / rmi</li></ul><p>但是我真的建议你忘记它们，换一种方式去使用和记忆Docker命令。当你敲完<code>docker --help</code> 之后，出来的信息大概是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker --help</span><br><span class="line"></span><br><span class="line">Usage:docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  checkpoint  Manage checkpoints</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  image       Manage images</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>不重要的部分我都省略了，在当前和未来版本的Docker中，官方都极力推荐我们通过管理命令去执行Docker命令。比如说：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>推荐使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>虽然<code>docker ps</code> / <code>docker exec</code> 等等命令更简洁，但是也更混乱，不便记忆。你有时候甚至不确定自己操作的是容器还是镜像或者是别的对象？</p><p>让我们再仔细对比一下管理命令和简化版命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> via management <span class="built_in">command</span></span></span><br><span class="line">docker image ls</span><br><span class="line">docker image rm</span><br><span class="line">docker image history</span><br><span class="line"></span><br><span class="line">docker container ps</span><br><span class="line">docker container rename</span><br><span class="line">docker container rm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> via docker <span class="built_in">command</span></span></span><br><span class="line">docker images</span><br><span class="line">docker rmi</span><br><span class="line">docker history</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line">docker rename</span><br><span class="line">docker rm</span><br></pre></td></tr></table></figure><p>所以在你理解Docker能做的事情后，再通过管理命令去实践你就会事半功倍。我做了一个思维导图，列出了常见的操作。</p><p><img src="https://tobyqin.github.io/images/image-20190420185522119.png" alt="image-20190420185522119"></p><p>在敲命令时你要时刻记住自己要做什么，不要迷路：</p><ol><li>需要配置网络，那就<code>docker network xxx</code></li><li>需要配置存储，那就<code>docker volume xxx</code></li><li>需要管理镜像，那就<code>docker image xxx</code></li><li>需要管理容器，那就<code>docker container xxx</code></li></ol><p>是不是超级简单？</p><h3 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h3><p><a href="https://www.portainer.io/" target="_blank" rel="noopener">portainer</a> 是一个浏览器界面的图形化Docker管理工具，它实现了几乎所有的Docker Engine操作，你只要两条命令就可以让它运行在你的机器上。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker volume create portainer_data</span><br><span class="line">$ docker run -d -p 9000:9000 -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data portainer&#x2F;portainer</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20190420231352125.png" alt="image-20190420231352125"></p><p>有了它，你就可以忘掉上面的命令，前提是你先通过面试。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>要制作容器镜像，你需要一个详细的步骤，这个实施过程记录下来就是Dockerfile。我们来看一个例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>其实Dockerfile很简单易懂，无非就是第一做什么第二做什么，自己写几遍就记住了。在Dockerfile中可以用的命令并不是特别多。</p><table><thead><tr><th>关键字</th><th>解释</th></tr></thead><tbody><tr><td>FROM</td><td>选择基础镜像版本，例如：<code>FROM ubuntu:18.04</code></td></tr><tr><td>LABEL</td><td>给镜像添加标签，例如：<code>LABEL version=&quot;0.0.1-beta&quot;</code></td></tr><tr><td>WORKDIR</td><td>指定工作目录（会自动创建），例如：<code>WORKDIR /target</code></td></tr><tr><td>ADD / COPY</td><td>复制文件，ADD会自动解压，例如：<code>COPY . /target</code></td></tr><tr><td>RUN</td><td>运行命令，例如：<code>RUN apt-get update -y</code></td></tr><tr><td>ENV</td><td>设置环境变量，例如：<code>ENV PG_VERSION 9.3.4</code></td></tr><tr><td>USER</td><td>不使用root来运行容器，例如：<code>USER user1:group1</code></td></tr><tr><td>VOLUME</td><td>添加文件卷，例如：<code>VOLUME /myvol</code></td></tr><tr><td>EXPOSE</td><td>暴露指定端口，例如：<code>EXPOSE 80/tcp</code></td></tr><tr><td>CMD</td><td>容器的默认命令，例如：<code>CMD [“echo”, “hello”]</code></td></tr><tr><td>ENTRYPOINT</td><td>容器的入口命令，例如：<code>ENTRYPOINT [“top”, “-b”]</code></td></tr></tbody></table><p>以上只是简单介绍，需要用到具体命令时建议还是参考<a href="https://docs.docker.com/engine/reference/builder/#usage" target="_blank" rel="noopener">Dockerfile官方文档</a>。</p><p>这些命令里最难说清楚的就是<code>CMD</code>和<code>ENTRYPOINT</code>，如果我是面试官这是必考题。三言两语说不完，我们改日再聊这个话题吧。</p><p>有了Dockerfile之后，只要运行<code>docker image build</code>就可以生成镜像了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /your-project-dir</span><br><span class="line">docker image build -t tobyqin/xmind2testlink:1.0.0 .</span><br></pre></td></tr></table></figure><p>一般你需要用<code>-t</code>参数来给你的镜像取个名字和定个版本，别的参数不太重要。打包完之后发布也是手到擒来：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要提前在docker仓库注册账号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker login</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入用户名密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker push tobyqin/xmind2testlink:1.0.0</span></span><br><span class="line">The push refers to repository [docker.io/tobyqin/xmind2testlink]</span><br><span class="line">a50ecd8a5d30: Layer already exists</span><br><span class="line">d306e6933e16: Layer already exists</span><br><span class="line">b48eea5f4f04: Layer already exists</span><br><span class="line">6e7c7e6d6e7f: Layer already exists</span><br><span class="line">2aebd096e0e2: Layer already exists</span><br><span class="line">latest: digest: sha256:c06bc4a35073319b8d7e7ef128a7daa8cdb4e766468ffc50f8a61afcf5ef3f46 size: 1367</span><br></pre></td></tr></table></figure><p>发布成功后你也就成了一个Docker社会人了。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Dockerfile只是打包一个程序或者一种服务，实际上我们的应用会复杂的多，比如有web前端，有大后端，有缓存系统，有消息队列，有数据库等等。</p><p>这时候你就需要使用<a href="https://docs.docker.com/compose/overview/" target="_blank" rel="noopener">Docker Compose</a>了，它是一个官方提供的用来定义和运行多个容器的工具，你只要写一个配置文件就可以对容器进行编排，看例子。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>有了这个配置文件，你只需要运行<code>docker-compose up</code>就可以轻松管理配置文件里的一系列容器。</p><p>关于Docker Compose的介绍不做深入，也不推荐深入，因为这样的容器编排只能满足小企业或者个人开发者的需求，单台主机。真正在企业中我们会用 <a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">Docker Swarm</a> 或者 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernets</a>。</p><h2 id="Docker-Swarm-和-K8S"><a href="#Docker-Swarm-和-K8S" class="headerlink" title="Docker Swarm 和 K8S"></a>Docker Swarm 和 K8S</h2><p>Swarm是Docker官方提供的一款集群管理工具，其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。</p><p>Kubernets也叫k8s，中间刚好是8个字母。类似的我们还把international缩写成i11l。Kubernets是Google开源的容器编排引擎，支持大规模容器集群管理，自动化部署，自动伸缩，负载均衡，资源监控等等功能。</p><p>Swarm和Kubernetes其实是一类东西，但是Google家的东西更强大也更复杂，企业一般会二选一。</p><p>关于容器编排是另外一个话题（很大的），本期内容完。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
            <tag> docker </tag>
            
            <tag> container </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试左移和开发赋能</title>
      <link href="posts/2019-03-27/shift-test-to-left/"/>
      <url>posts/2019-03-27/shift-test-to-left/</url>
      
        <content type="html"><![CDATA[<p>从事测试开发那么长一段时间，一直不知道怎么去评价和衡量这个职业的目标是什么，超高的自动化测试覆盖率？或者超稳定超包容的自动化测试框架？</p><a id="more"></a><p>怎么才算得上是一个优秀的测试开发人员？上周有机会去听了阿里2天的公开课，好像明白了一些，拿来跟大家分享一下。</p><h2 id="内建质量"><a href="#内建质量" class="headerlink" title="内建质量"></a>内建质量</h2><p>在微软有一句名言：“质量是设计出来，而不是测出来的。” 当然，这是理想情况，如果产品经理都这么优秀，这个世界早就和平了。</p><p>今天我们不说产品经理，我们从测试和开发的角度看，怎么内建质量。</p><h3 id="让测试内建质量"><a href="#让测试内建质量" class="headerlink" title="让测试内建质量"></a>让测试内建质量</h3><p>为了内建质量，测试同学就要尽可能早地干预开发写bug，让bug死在摇篮里。换句话说就是让开发不要写出可以避免的bug：</p><ol><li>产品，开发，测试应该同时参与需求评审会议，澄清需求，达成共识</li><li>将关键测试点作为需求的一部分，让开发同学交付需求时完成自测</li></ol><h3 id="让开发内建质量"><a href="#让开发内建质量" class="headerlink" title="让开发内建质量"></a>让开发内建质量</h3><p>从开发的角度看，要提高代码的质量可以有很多种方式：</p><ol><li>提高自测意识，借助单元测试或者质量分析工具</li><li>真正理解需求和技术架构，进行Code Review或者结对编程</li><li>评估代码质量或者bug数量，跟绩效挂钩</li></ol><p>排除开发的自身能力问题，80%的bug都是需求理解不准确的问题，如果开发不愿背这个锅，那就甩给产品经理吧。</p><p>由此可见，如果测试不想看见这些bug，那么你就要帮产品表达需求，帮开发理解需求。</p><h2 id="测试左移"><a href="#测试左移" class="headerlink" title="测试左移"></a>测试左移</h2><p>上面我们说内建质量其实已经涉及到了测试左移，例如让QA在参与需求研讨时提出问题，列出测试点其实已经开始在进行测试了。</p><p>为什么我们要测试左移呢？因为发现问题的时间越晚，修复的成本就越高。</p><p><img src="https://tobyqin.github.io/images/2019-04/9f969a88cfae418fba23c10adc025b3a636807279198182687.jpg" alt="img"></p><p>图中橙色线条代表了传统测试发现缺陷的时间，大多数bug都是在功能测试和集成测试时发现的，最后导致的结果就是发布前加班加点，祈祷不要有bug漏到生产环境。</p><p>如果我们能把测试活动向左移动，那么就意味着修复成本大幅下降。</p><p><img src="https://tobyqin.github.io/images/2019-04/c8b20f490f1b40b28fe91e2fe48059fb636807279425994169.gif" alt="img"></p><p>但是谈何容易？想要把大部分测试点放在单元测试环境完成，非常依赖成熟的开发环境和极其资深的开发人员。</p><p>在阿里是这样实践的，让测试给开发赋能。</p><h2 id="开发赋能"><a href="#开发赋能" class="headerlink" title="开发赋能"></a>开发赋能</h2><p>从字面上解释就是，测试同学给开发赋于一定的能力，让他们有能力去完成测试，比如：</p><ol><li>降低测试门槛</li><li>使用测试工具（自动化）</li><li>获取测试数据</li><li>培养测试意识</li></ol><p>举个例子，开发同学在完成需求代码后，可以点击一个按钮得到测试数据，再点击一个按钮验证测试覆盖点，喝杯咖啡后就可以看到测试报告。</p><p>从上面这个例子看，开发同学其实他并不需要懂测试数据的设计，自动化测试的开发，测试报告的编排，但是他依然可以快速完成需求测试（门槛低），只要他养成习惯（培养意识）。</p><p>那么你就会说，这对测试的同学要求是不是很高啊？对啊，回到开篇的问题，如何评判一个测试人员的能力？在我看来就是评判他给开发和团队赋能的能力。在阿里是这样，在微软和谷歌也是这样。</p><p>一个优秀的测试人员将测试左移时，并不会将负担转移给开发。相反地，而是帮开发写出更高质量的代码，更高效率地交付需求。</p><p>那么测试能左移到什么程度呢？比如让开发在Coding时就发现问题，或者还没Coding就发现问题，那应该是极好的。</p><p><img src="https://tobyqin.github.io/images/2019-04/ca89b059129e418aaa383c8b1d83c69b636807279625728401.gif" alt="img"></p><p>怎么做到呢？刚才已经说过了，测试即需求，把bug扼杀在摇篮里。</p><h2 id="实践方法"><a href="#实践方法" class="headerlink" title="实践方法"></a>实践方法</h2><p>想实践测试左移可以有很多种方法，每个组织需要根据实践情况进行裁剪和调整。</p><ol><li>参与需求评审，帮助开发理解需求</li><li>参与架构、设计分析，提早预防问题</li><li>践行BDD，TDD</li><li>单元测试提案，接口测试提案</li><li>提供模拟数据能力，测试工具</li><li>制定提测标准，拒绝低质量代码</li><li>回归测试自动化</li><li>静态代码分析，单元测试覆盖率</li></ol><p>测试左移的概念给整个测试角色带来了巨大的转变。软件测试不仅仅是“发现bug”，而是致力于“尽可能早的检测和预防bug”。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>培训课件： <a href="/files/阿里Devops体系和实践.svg">阿里Devops体系和实践.svg</a></li><li>参考文章：<a href="https://blog.parasoft.com/what-is-the-shift-left-approach-to-software-testing" target="_blank" rel="noopener">What is shift-left testing?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微不足道的改进</title>
      <link href="posts/2019-03-09/little-improvement/"/>
      <url>posts/2019-03-09/little-improvement/</url>
      
        <content type="html"><![CDATA[<p>今天我说一个很小的故事，不知道对你会不会有启发。</p><a id="more"></a><p>话说有一个历史年代悠久的遗留系统，非常复杂和庞大，每次部署后需要一个漫长的服务启动过程。谁也不知道为什么这个启动过程这么慢，至少要半个多小时。</p><p>一天一位萌新工程师被指派去查问题，他问老鸟工程师，为什么这个系统要写那么多log？老鸟说老系统不写log谁知道当时发生了什么，以后多学学。</p><p>萌新又问，那为什么要写到nas上面？而且存了好几月甚至几年的log。老鸟工程师意味深长的说，写到nas方便你不用登录到服务器就可以取到log啊，存的越多当然线索就越多啦，你查完问题就赶紧做别的task，这个系统年纪可能比你爸年纪还大，管他那么多干嘛？</p><p>萌新工程师觉得问题并没有得到满意的解答，又找了更加资深的鸟二工程师，鸟二掐指一算说这应该是一个问题，但是系统太老谁都不敢动手，怕老bug附体招架不住。如果你一定要改进，试试把log写到本地磁盘做个定期清理，给nas腾空间，nas老是不够用。</p><p>按照老鸟的建议，萌新工程师把log地址从nas改成了本地路径，这时候神奇的事情居然发生了，这个老态龙钟的系统似乎迎来了第二春，从原来的30多分钟启动时间变成了不到10分钟！运行时处理数据的速度也提高了很多，哇，性能似乎直接提高了200%？！这个改进让萌新工程师一下逆袭，广受老板嘉奖和传颂，年终奖++！</p><p>古人说，勿以善小而不为，勿以恶小而为之，说的就是这种人。啊不，有可能古人说的是，命里有时终须有，命里无时莫强求。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件交付的原则</title>
      <link href="posts/2019-02-26/priciple-to-deliver-software/"/>
      <url>posts/2019-02-26/priciple-to-deliver-software/</url>
      
        <content type="html"><![CDATA[<p>《持续交付-发布可靠软件的系统方法》，部分读书笔记。</p><a id="more"></a><h2 id="为软件发布创建一个可重复且可靠的过程"><a href="#为软件发布创建一个可重复且可靠的过程" class="headerlink" title="为软件发布创建一个可重复且可靠的过程"></a>为软件发布创建一个可重复且可靠的过程</h2><p>让软件发布成为一件容易的事情，这是在你开始写一个软件开始前就要想办法达到的目标。只要软件发布简单到点击一个按钮甚至不需要点击按钮就能发布，你才会有动力去持续完善这个软件。</p><p>所以一般我在开始开发一个软件时就会考虑它的部署过程，会用到哪些资源，如果更新版本等等问题。</p><h2 id="将几乎所有事情都自动化"><a href="#将几乎所有事情都自动化" class="headerlink" title="将几乎所有事情都自动化"></a>将几乎所有事情都自动化</h2><p>有些工作是不能自动化的，比如分析业务逻辑，设计软件结构，编写测试等等。</p><p>但是能自动化的就尽可能让计算机来帮助你完成，比如发布软件涉及的各个环节，运行自动化测试，生成各种报告和指标。</p><p>重复的事情计算机往往比人更可靠，有时候你觉得它花的时间更多，但是它不用睡觉，你不行。</p><h2 id="把所有东西都纳入版本控制"><a href="#把所有东西都纳入版本控制" class="headerlink" title="把所有东西都纳入版本控制"></a>把所有东西都纳入版本控制</h2><p>人都是健忘的，我们除了需要把代码纳入版本控制系统，应该还将跟项目有关的其他东西也纳入版本管理：</p><ul><li>需求文档，测试用例，自动化测试脚本</li><li>机器配置，网络配置， 部署脚本</li><li>数据库创建，升级，回滚脚本等等</li><li>依赖配置，库文件，工具链，参考文档等等</li></ul><p>要具体到当前发布的是哪个版本，用了哪些对应版本号的依赖和库，当时的需求和测试时什么样子的。</p><h2 id="提前并频繁做让你感到痛苦的事情"><a href="#提前并频繁做让你感到痛苦的事情" class="headerlink" title="提前并频繁做让你感到痛苦的事情"></a>提前并频繁做让你感到痛苦的事情</h2><p>这是最通用的原则，也是最有启发性的。可以说我们说的一切都可以归结到这一点上。反复做痛苦的事情会有两种可能的结果：</p><ol><li>你麻木不仁了，周而复始继续痛苦</li><li>你揭竿而起了，把这个痛苦干掉了</li></ol><p>提前并频繁去做，我相信你会选择第二种结果。</p><h2 id="内建质量"><a href="#内建质量" class="headerlink" title="内建质量"></a>内建质量</h2><p>“内建质量”是精益运动的先驱戴明提出的名言之一。从而得出两个结论：</p><ul><li>测试不是一个阶段，也不应该在开发结束后才开始。</li><li>测试不纯粹或者主要是测试人员的领域。</li></ul><p>交付团队里的每个人都应该对产品的质量负责，所以在需求调研，分析，开发过程中其实已经对质量造成影响。只有保证每个环节的质量，才能确保整体的质量。</p><h2 id="“Done”意味着“已发布”"><a href="#“Done”意味着“已发布”" class="headerlink" title="“Done”意味着“已发布”"></a>“Done”意味着“已发布”</h2><p>经常听开发说需求终于做完（Done）了，但真的做完了吗？对于敏捷团队来说，“Done”意味着功能已经部署到生产环境了，已交付给用户了才算完成。</p><p>一件事情没有完成80%的说法，要么完成了，要么就是没完成。从这一原则得出一个有趣的推论，一个事情完成与否，并不是一个人能控制得了的，他需要所有人参与，包括开发，测试，运维，支持等等。</p><h2 id="交付过程是每个成员的责任"><a href="#交付过程是每个成员的责任" class="headerlink" title="交付过程是每个成员的责任"></a>交付过程是每个成员的责任</h2><p>无论项目成功还是失败，其结果都是属于这个团队的。但现实中开发总是把困难交给测试，测试又把困难交给运维，当问题出现时，人们会花费大量时间来修复，也会用同等时间来互相指责推卸责任。</p><p>为了更加快速且可靠地交付软件，我们应该鼓励所有参与整个过程的人进行更好的协作。</p><h2 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h2><p>软件的首次发布只是生命周期里的第一个阶段，随着不断演进，更多的发布和需求会接踵而来。所以你的交付过程也要随之不断演进。</p><p>召开回顾会议是一个很好的实践，反思过去一段时间内什么做的好，继续保持，做的不好，记录并改进。每个改进点都应该有一个人负责跟踪，确保能被执行，下一次会议向大家汇报结果。</p><p>自动化的开发，测试以及发布过程对交付软件的速度，质量和成本有着深远的影响。</p>]]></content>
      
      
      
        <tags>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用VueJS开发油猴（TamperMonkey）脚本</title>
      <link href="posts/2019-02-25/tampermonkey-user-script-with-vuejs/"/>
      <url>posts/2019-02-25/tampermonkey-user-script-with-vuejs/</url>
      
        <content type="html"><![CDATA[<p>前面我们介绍过怎么<a href="https://tobyqin.github.io/posts/2019-02-24/build-chrome-extension-with-vuejs/" target="_blank" rel="noopener">用VueJS开发浏览器插件</a>，也知道了它有一个巨大限制，就是需要注册成开发者你才能发布插件到商店。而且你发布的任何插件都需要经过严格的审核才能最终和用户见面。这时候我想你该认识一下油猴了。</p><a id="more"></a><h2 id="关于油猴"><a href="#关于油猴" class="headerlink" title="关于油猴"></a>关于油猴</h2><p>油猴全名叫TamperMonkey，别名也叫GM。如果说TamperMonkey各大插件商店里第二厉害的插件，没人敢说自己是第一了，去搜搜它的下载量和评价你就知道了。</p><p><img src="https://tobyqin.github.io/images/image-20190225203111286.png" alt="image-20190225203111286"></p><p>一般情况下浏览器的插件我们都是去商店里安装的，但如果你装了油猴插件后，你就可以到任何地址安装插件。它最大程度加强了你的浏览器，每一个油猴脚本就是一个插件。而且油猴几乎支持了所有浏览器，包括IE。</p><p>TamperMonkey官方的定义说这是一个用户脚本管理器。通俗的说法就是TamperMonkey允许你在浏览器打开的任意页面过程中执行一段自定义脚本，从而实现一些功能，比如：</p><ul><li>在百度搜索结果打开后把广告去掉</li><li>在百度云的资源页面提供VIP下载地址（假设你知道解密算法）</li><li>在你提交bug时自动填上一系列数据</li></ul><p>油猴能做的很多，可以这么说，限制它功能的只是咱自己的想象力。</p><h2 id="油猴脚本Hello-World"><a href="#油猴脚本Hello-World" class="headerlink" title="油猴脚本Hello World"></a>油猴脚本Hello World</h2><p>一个油猴脚本就是一个以<code>user.js</code>结尾的JavaScript脚本，你可以托管在任何位置。只要你装了油猴插件，当你访问这样一个js文件时，油猴就会提醒你是否安装这个脚本。</p><p><img src="https://tobyqin.github.io/images/image-20190225204445464.png" alt="image-20190225204445464"></p><p>所以开发一个油猴脚本就是写一个js文件，并以<code>user.js</code>结尾，例如<code>github-info.user.js</code>，然后托管在某个地方。</p><p>这个js文件需要符合油猴脚本的一些基本约定，比如这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Github Info</span></span><br><span class="line"><span class="comment">// @namespace    https://tobyqin.github.io/</span></span><br><span class="line"><span class="comment">// @version      0.2.1</span></span><br><span class="line"><span class="comment">// @description  A demo to use vuejs in tampermonkey script.</span></span><br><span class="line"><span class="comment">// @author       Toby Qin</span></span><br><span class="line"><span class="comment">// @include      *github.com*</span></span><br><span class="line"><span class="comment">// @exclude      *api.github*</span></span><br><span class="line"><span class="comment">// @supportURL   https://github.com/tobyqin/tampermonkey_vue</span></span><br><span class="line"><span class="comment">// @updateURL    https://github.com/tobyqin/tampermonkey_vue/raw/master/github-info/github-info.user.js</span></span><br><span class="line"><span class="comment">// @downloadURL  https://github.com/tobyqin/tampermonkey_vue/raw/master/github-info/github-info.user.js</span></span><br><span class="line"><span class="comment">// @require      https://vuejs.org/js/vue.min.js</span></span><br><span class="line"><span class="comment">// @require      https://code.jquery.com/jquery-3.4.1.min.js</span></span><br><span class="line"><span class="comment">// @require      https://github.com/tobyqin/tampermonkey_vue/raw/master/github-info/app.js</span></span><br><span class="line"><span class="comment">// @grant        GM_getValue</span></span><br><span class="line"><span class="comment">// @grant        GM_setValue</span></span><br><span class="line"><span class="comment">// @grant        GM_setClipboard</span></span><br><span class="line"><span class="comment">// @run-at       document-body</span></span><br><span class="line"><span class="comment">// @noframes</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">alert(<span class="string">'hello world!'</span>);</span><br></pre></td></tr></table></figure><p>从各个字段应该比较容易理解是干什么的，简单介绍一些常用字段：</p><ul><li>updateURL：脚本检查更新的地址，每天油猴会去这个地址查询新版本。</li><li>downloadURL：脚本下载地址，如果有更新就去这里下载下脚本。</li><li>include：url 包含匹配，当url符合这样的规则才启用脚本，可以写多条。</li><li>exclude：url 排除匹配，当url符合这样的规则时不启用脚本，可以写多条。</li><li>require：加载外部资源，可以是js，css或者图片，油猴会缓存这些资源，并提供调用方法。</li><li>grant：申请使用油猴API，如果没申请就不能使用。</li><li>run-at：脚本运行阶段，比如页面加载前，加载后或者闲置时等等。</li></ul><p>更多详细的解释还是去看官方的开发文档：</p><ul><li><a href="https://tampermonkey.net/documentation.php?ext=dhdg" target="_blank" rel="noopener">https://tampermonkey.net/documentation.php?ext=dhdg</a></li></ul><p>上面这个示范其实已经是一个完整的例子了，当你访问github.com的任意页面时浏览器都会弹出一个“hello world”的警告。</p><h2 id="加入jQuery和Vue"><a href="#加入jQuery和Vue" class="headerlink" title="加入jQuery和Vue"></a>加入jQuery和Vue</h2><p>jQuery虽然即将成为被大家争相抛弃的东西，但不得不说在油猴脚本里它还是有一席之地的。因为jQuery提供了便捷的选择器和链式操作，让我们足够方便去操控页面。</p><p>要使用jQuery，你要注意不能因为你选择的jQuery版本破坏了站点的功能，50%甚至更多的站点还在使用jQuery，但是有版本的差异。还好jQuery提供了noConflict的加载方式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// @require      https://code.jquery.com/jquery-3.4.1.min.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.jq = $.noConflict(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>那么Vue呢？就没那么幸运了，如果你的目标站点已经在使用Vue了，你可以不导入Vue，直接调用就好了。</p><p>Vue不提供noConflict的导入方式，所以一旦你导入和站点不一致的Vue版本后，什么事情都有可能发生。</p><ul><li><a href="https://github.com/vuejs/vue/issues/2349" target="_blank" rel="noopener">https://github.com/vuejs/vue/issues/2349</a></li></ul><p>所以在油猴插件中使用Vue需要做足够的调研。你可以参考我的这个例子同时使用jQuery和Vue来开发油猴插件。</p><ul><li><a href="https://github.com/tobyqin/tampermonkey_vue" target="_blank" rel="noopener">https://github.com/tobyqin/tampermonkey_vue</a></li></ul><p><img src="https://tobyqin.github.io/images/tampermonkey-vue.png" alt="tampermonkey-vue"></p><h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><p>首先说本地环境的准备，方法有很多，就是想方设法让你的用户脚本被托管在某个地方。</p><h3 id="插件集成环境"><a href="#插件集成环境" class="headerlink" title="插件集成环境"></a>插件集成环境</h3><p>油猴插件本身提供了一个简单的开发环境，你可以在这里写你的脚本，这时你不需要考虑托管的问题。</p><p><img src="https://tobyqin.github.io/images/image-20190225212103167.png" alt="image-20190225212103167"></p><p>但大多时候我们需要功能更强大的IDE，比如VsCode或者WebStorm。</p><h3 id="npm-serve"><a href="#npm-serve" class="headerlink" title="npm serve"></a>npm serve</h3><p>你可以用npm安装一个serve，然后把脚本目录通过http协议暴露出来。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install serve</span><br><span class="line">cd &#x2F;path&#x2F;to&#x2F;project</span><br><span class="line">serve -l 5000</span><br><span class="line"># now install user script at http:&#x2F;&#x2F;localhost:5000&#x2F;my.user.js</span><br></pre></td></tr></table></figure><h3 id="python-http-server"><a href="#python-http-server" class="headerlink" title="python http.server"></a>python http.server</h3><p>如果你本机安装了Python，也可以直接托管一个文件目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;path&#x2F;to&#x2F;project</span><br><span class="line">python -m http.server 5000</span><br><span class="line"># now install user script at http:&#x2F;&#x2F;localhost:5000&#x2F;my.user.js</span><br></pre></td></tr></table></figure><h3 id="WebStorm-everything"><a href="#WebStorm-everything" class="headerlink" title="WebStorm / everything"></a>WebStorm / everything</h3><p>如果你用的是WebStorm，在用户脚本目录下新建一个html，它会自动提供访问这个文件的http地址，你通过拼装也可以生成用户脚本的地址。</p><p>如果你是Windows也装了everything，在设置中启用http后也获得用户脚本的地址。总之方法很多，开动你聪明的大脑。</p><h2 id="调试用户脚本"><a href="#调试用户脚本" class="headerlink" title="调试用户脚本"></a>调试用户脚本</h2><p>调试脚本前，你需要到TamperMonkey设置中打开高级选项，选择开启调试。</p><p><img src="https://tobyqin.github.io/images/image-20190225211416418.png" alt="image-20190225211416418"></p><p>然后重启浏览器，先打开开发者控制台（F12），然后访问目标网站，这时候油猴会自动帮你在用户脚本运行前加上断点并暂停。</p><p><img src="https://tobyqin.github.io/images/image-20190225212629779.png" alt="image-20190225212629779"></p><h2 id="正式发布"><a href="#正式发布" class="headerlink" title="正式发布"></a>正式发布</h2><p>其实油猴脚本没有所谓的正式发布，你可以发布到几个常见的脚本站点（论坛）：</p><ul><li><a href="https://openuserjs.org/" target="_blank" rel="noopener">https://openuserjs.org/</a></li><li><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">https://greasyfork.org/zh-CN</a></li><li><a href="http://userscripts-mirror.org/" target="_blank" rel="noopener">http://userscripts-mirror.org/</a></li></ul><p>这几个站点在油猴插件都有入口，当然你也可以把你的脚本开源到github的仓库或者gist，然后告诉别人链接。再假如这是一个内部使用的脚本，你就部署到内网服务器等等。</p><h2 id="友情提醒"><a href="#友情提醒" class="headerlink" title="友情提醒"></a>友情提醒</h2><p>因为油猴脚本的灵活性和无限可能，不安全的油猴脚本是很危险的。比如它可以在你登录的账号页面上搜集信息，发送到后台，甚至直接下单，修改地址等等。</p><p>所以在下有几个建议。</p><ul><li>对于不信任的用户脚本，不安装。</li><li>对于不开源的用户脚本，不安装。</li><li>对于吹爆自己的用户脚本，不安装。</li></ul><p>另外针对油猴脚本，谷歌也出手了，在将来版本的Chrome中会更加限制插件对运行时网页的干预，比如禁止修改请求，篡改网页等等。</p><p>不过那是将来，现在学习一下，没坏处。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuejs </tag>
            
            <tag> tampermonkey </tag>
            
            <tag> user-script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用VueJS写一个Chrome浏览器插件</title>
      <link href="posts/2019-02-24/build-chrome-extension-with-vuejs/"/>
      <url>posts/2019-02-24/build-chrome-extension-with-vuejs/</url>
      
        <content type="html"><![CDATA[<p>浏览器基本已经天下大统了，放眼望去都是Chromium的天下。那么，能写一个浏览器插件也算是一种回报率不错的技能。</p><a id="more"></a><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>浏览器插件官方的说法叫扩展程序，允许你为浏览器增加各种功能，但不需要深入研究浏览器本身的代码。你可以用HTML，CSS和JavaScript创建新的扩展程序，如果你曾经写过网页，那么写一个插件是非常轻松的事情。</p><p>常见的插件一般就是地址栏后面的一个图标，点击后给你当前网页提供各种功能，或者在你点击网页右键时弹出额外的菜单。</p><h3 id="扩展程序目录结构"><a href="#扩展程序目录结构" class="headerlink" title="扩展程序目录结构"></a>扩展程序目录结构</h3><p>最简单的扩展程序只需要3个文件，或者更少。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-addon</span><br><span class="line">  |- manifest.json</span><br><span class="line">  |- icon.png</span><br><span class="line">  └─ popup.html</span><br></pre></td></tr></table></figure><ul><li>manifest.json：清单文件，用来描述插件本身，必须。</li><li>icon.png：图标文件，如果你不想用默认图标这也是必须的。</li><li>popup.html：算是插件的功能页吧，你至少得有点功能才有存在的意义吧。</li></ul><p>当然上面的例子是最精简的情况了，一般的插件会有多个html，还有js目录，css目录等等，你可以把插件当成一个静态网站，唯一的区别是多了一个manifest文件用来描述这个静态网站。</p><h3 id="清单文件的示例"><a href="#清单文件的示例" class="headerlink" title="清单文件的示例"></a>清单文件的示例</h3><p>下面是一个精简版的manifest.json。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"One-click Kittens"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"This extension demonstrates a browser action with kittens."</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"permissions"</span>: [</span><br><span class="line">    <span class="string">"https://secure.flickr.com/"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">    <span class="attr">"default_icon"</span>: <span class="string">"icon.png"</span>,</span><br><span class="line">    <span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去是不是很直观，名字，版本，描述，权限，行为。如果要深入再查查官方文档就OK了。</p><h2 id="做一个Hello-World插件"><a href="#做一个Hello-World插件" class="headerlink" title="做一个Hello World插件"></a>做一个Hello World插件</h2><p>有了基础知识，我们速度来个Hello World，先写manifest.json。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Hello"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Hello, Chrome extension."</span>,</span><br><span class="line">    <span class="attr">"icons"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"16"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">        <span class="attr">"48"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">        <span class="attr">"128"</span>: <span class="string">"img/icon.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"browser_action"</span>: </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">        <span class="attr">"default_title"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">        <span class="attr">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"permissions"</span>:</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"&lt;all_urls&gt;"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"homepage_url"</span>: <span class="string">"https://github.com/tobyqin/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再补一下图标文件和popup.html。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览器插件页面，右上角打开开发者模式，加载插件目录。</p><p><img src="https://tobyqin.github.io/images/image-20190224211641535.png" alt="image-20190224211641535"></p><p>这时我们的第一个插件就好了，点击插件图标就可以显示Hello World。</p><p><img src="https://tobyqin.github.io/images/image-20190224211834725.png" alt="image-20190224211834725"></p><h2 id="把Vue加进来"><a href="#把Vue加进来" class="headerlink" title="把Vue加进来"></a>把Vue加进来</h2><p>好像很容易嘛，我们直接用CDN的Vue，改造一下popup.html。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.6/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            message: <span class="string">'Hello Vue!'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不用卸载刚才安装的插件目录，只要再点击一下插件按钮就会自动加载最新的代码。不过好像不对，和期望的结果不一样。</p><p><img src="https://tobyqin.github.io/images/image-20190224213132801.png" alt="image-20190224213132801"></p><p>而且注意看插件页面，出现错误了。</p><p><img src="https://tobyqin.github.io/images/image-20190224213239330.png" alt="image-20190224213239330"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Refused to load the script &#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue&#x2F;2.6.6&#x2F;vue.js&#39; because it violates the following Content Security Policy directive: &quot;script-src &#39;self&#39; blob: filesystem: chrome-extension-resource:&quot;. Note that &#39;script-src-elem&#39; was not explicitly set, so &#39;script-src&#39; is used as a fallback.</span><br><span class="line"></span><br><span class="line">Refused to execute inline script because it violates the following Content Security Policy directive: &quot;script-src &#39;self&#39; blob: filesystem: chrome-extension-resource:&quot;. Either the &#39;unsafe-inline&#39; keyword, a hash (&#39;sha256-fMtOu4CF&#x2F;4bYGHZuo6ltgNQyLcxFW9rBnAYSk3yz53w&#x3D;&#39;), or a nonce (&#39;nonce-...&#39;) is required to enable inline execution.</span><br></pre></td></tr></table></figure><p>默认情况下，浏览器插件权限是非常低的，不允许访问除了插件本身的文件以外的文件，不能调用页面内脚本（inline script），也不能使用eval之类的函数。</p><p>你需要在manifest文件中配置好Content Security Policy（CSP）才能使用Vue。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"content_security_policy"</span>: <span class="string">"style-src 'self' 'unsafe-inline';script-src 'self' 'unsafe-eval' https://cdn.bootcss.com; object-src 'self' ;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个CSP写起来实在不怎么友好，伟大的网友做了一个工具可以帮你一把。</p><ul><li><a href="https://github.com/foundeo/content-security-policy.com/" target="_blank" rel="noopener">https://github.com/foundeo/content-security-policy.com/</a></li></ul><p>接下来，把页面内的script内容搬到单独的文件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// popup.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.6/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: '#app',</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: 'Hello Vue!'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>刷新一下插件，搞定了。</p><p><img src="https://tobyqin.github.io/images/image-20190224215911240.png" alt="image-20190224215911240"></p><h2 id="如何调试插件"><a href="#如何调试插件" class="headerlink" title="如何调试插件"></a>如何调试插件</h2><p>调试插件和调试一个普通的网页一样简单，右键选择审查元素就好了。</p><p><img src="https://tobyqin.github.io/images/image-20190224220344298.png" alt="image-20190224220344298"></p><p>包括插件的配置页面，新弹出的页面等等，都可以用一样的方法调试。</p><h2 id="如何发布插件"><a href="#如何发布插件" class="headerlink" title="如何发布插件"></a>如何发布插件</h2><p>当你完成插件开发后，在启用开发者模式的插件中心就可以看到打包插件按钮，这个按钮可以帮你快速打包crx文件，第一次打包你不需要提供密钥，它会帮你生成一个密钥，之后的版本升级你需要用同一个密钥打包，否则就被认为是一个新的插件了，所以切记保存好密钥。</p><p><img src="https://tobyqin.github.io/images/image-20190224220845746.png" alt="image-20190224220845746"></p><p>拿着打包好的crx文件你就可以到商店发布啦，不过发布到谷歌商店是要交钱的，一年9.9美刀的开发者会员。国内的各种商店收不收费不知道。</p><p>比较恶心的是，如果你的插件没有在谷歌浏览器的商店里上架，Chrome浏览器是不认的，以前还可以拖到插件页面安装，现在怎么都绕不过去了。但基于Chromium开发的第三方浏览器还是可以装的，比如Opera，QQ，360等等。</p><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h3><p>可能你要做的插件别人已经做过了，或者你想借鉴别人的插件，有两个方法。</p><ol><li>右键审查别人的插件页面，看看代码怎么工作的。</li><li>安装一个下载crx的插件，然后把别人的插件从商店下载到本地，重命名为zip并解压，就可以看到源码了。</li></ol><p>当然啦，别人的源码可能做过混淆加密。</p><h3 id="插件页面大小"><a href="#插件页面大小" class="headerlink" title="插件页面大小"></a>插件页面大小</h3><p>如果你的插件会弹出一个页面，浏览器默认会根据内容自适应页面大小，就像上面例子里的那个hello world，很丑是吧。一般插件页面都是限制body高度和宽度的，这样才不会歪。</p><h3 id="安全请求"><a href="#安全请求" class="headerlink" title="安全请求"></a>安全请求</h3><p>现在很难找到不是https的页面里，所以你的插件里如果会往后台发送请求的话，也是需要支持https协议的，否则会被拦截的。</p><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p>如果你的插件是可配置的，怎么保存配置信息呢？直接用<code>localStorage</code>就行了。<code>localStorage</code>对每个站点都是独立的，每一个插件可以看成独立的站点，所以当你在插件里调用<code>localStorage</code>对象时就是当前插件的<code>localStorage</code>。如果你希望配置是可同步的，那么请考虑<code>chrome.storage</code>对象，里面提供了<code>storage.local</code>和 <code>storage.sync</code>。</p><h3 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h3><p>不想推荐文档什么的，自己需要会去搜索的。那么有没有一个完整的例子？当然有啦，去看我的github吧，觉得不错就点个赞。</p><ul><li><a href="https://github.com/tobyqin/chrome_vue_ext_demo" target="_blank" rel="noopener">https://github.com/tobyqin/chrome_vue_ext_demo</a></li></ul><p><img src="https://raw.githubusercontent.com/tobyqin/chrome_vue_ext_demo/master/capture.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuejs </tag>
            
            <tag> chrome </tag>
            
            <tag> extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向代理和内网穿透</title>
      <link href="posts/2019-02-22/reverse-proxy-and-intranet-through/"/>
      <url>posts/2019-02-22/reverse-proxy-and-intranet-through/</url>
      
        <content type="html"><![CDATA[<p>学习一下正向代理和反向代理。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>反向代理看上去看深奥，其实不然，只是因为汉语言文化的差异导致它看上去深奥。一般反派感觉都比较厉害和神秘。</p><p>要理解反向代理，我们就不得不说一下正向代理。</p><h3 id="正向代理-（Forward-Proxy）"><a href="#正向代理-（Forward-Proxy）" class="headerlink" title="正向代理 （Forward Proxy）"></a>正向代理 （Forward Proxy）</h3><p>所谓正向代理，就是大家通常说的代理。打个通俗的比方，你想跟你舅舅借钱，但不好开口（或者你舅妈会设法阻拦），就跟你妈说。这时母亲大人就是个正向代理。此时代理本质就是个桥的作用，这个桥让你能和桥对面的人交换信息。</p><p><img src="https://tobyqin.github.io/images/1550823489351.png" alt=""></p><p>正向代理是多对一的概念，例如你姐，你妹你可以通过你妈去跟舅舅借钱，但舅舅只有一个舅舅。舅舅有可能并不知道到底是谁真正在借钱，只知道钱给了你妈。</p><h3 id="反向代理-（Reserve-Proxy）"><a href="#反向代理-（Reserve-Proxy）" class="headerlink" title="反向代理 （Reserve Proxy）"></a>反向代理 （Reserve Proxy）</h3><p>大家都有打客服电话的经历，比如10086，一般上来就是个语音系统，转接人工服务后嘟嘟嘟好几声才有人接听，说我是工号xxx，很高兴为你服务。这个客服总机号码10086就是个反向代理，</p><p><img src="https://tobyqin.github.io/images/1550824448581.png" alt=""></p><p>反向代理隐藏了真实的服务端，有可能有N个客服对应N个号码，但你只需要记一个10086，它会平衡客服之间的压力给你安排合适的人。</p><p>反向代理是一对多的概念，刚好和正向代理反过来了。</p><ul><li>正向代理<strong>代理的对象是客户端</strong></li><li>反向代理<strong>代理的对象是服务端</strong></li></ul><p>反向代理最常见的作用就是负载均衡。比如你访问baidu的域名后，baidu会根据你的ip地址和网络情况给你分配最快的服务器，这个分配服务器的服务器就是反向代理。</p><p><img src="https://tobyqin.github.io/images/1550825022784.png" alt=""></p><p>反向代理还有一个场景就是内网穿透，因为服务对象是在内网里，你需要通过代理才能访问到。</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>从外网是没办法直接访问到内网的资源的，因为内网是一个局域网不在一个网段，而且还有防火墙在。</p><p><img src="https://tobyqin.github.io/images/1550826381553.png" alt="1550826381553"></p><p>这时候你弄个反向代理就可以解决这个问题：</p><ul><li>内网服务器访问代理服务器</li><li>握手，建立<strong>通道</strong></li><li>外网用户访问代理，代理通过<strong>通道</strong>和内网通信</li></ul><p><img src="https://tobyqin.github.io/images/1550848043738.png" alt="1550848043738"></p><p>举一个具体例子，TeamViewer的服务端（外网）就是个反向代理，它需要和TeamViewer客户端（内网）一直保持通信，建立一个通道（TeamViewer ID）。当远程连接这台机器时，你需要登录到TeamViewer服务器，然后通过代理通道（TeamViewer ID）和远程机器连接。</p><h2 id="一些反向代理服务"><a href="#一些反向代理服务" class="headerlink" title="一些反向代理服务"></a>一些反向代理服务</h2><p>远程连接内网机器的桌面服务是最常见的需求，有时候我们希望做的是自己的机器上跑一些服务能够从外网访问，比如demo，博客，甚至私有云等等。</p><p>TeamViewer和向日葵大家可能都知道，我说一些不一样的。</p><h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><p>开源界最流行的反向代理之一，frp全称FaskReverseProxy，它的目标是做最快速可靠的反向代理，用GO语言实现，在Github上正在快速迭代中。安装和配置都非常简单，只需要几个命令就可以完成。frp支持的客户端非常丰富，树莓派，路由器，安卓手机等等，可玩性很高。</p><p>frp服务可以让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API (比如微信公众号，企业号的开发)。</p><p>FRP还可以轻松代理TCP，HTTPS，SSH等等协议，你需要有一台具有公网IP的机器，最好加一个域名。</p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>曾经是开源界反向代理软件的老大，到2.0以后选择闭源，最后开源的版本2016年后就没有再更新，止于1.7。基于C语言实现，配置略复杂，不过据说灵活性和稳定性超好。</p><p>ngrok也可以代理常见的各种协议，自己搭建只能用早期的开源版本。或者选择商业公司提供的收费服务，国内外可以搜到很多提供NGROK服务的网站，可不可靠不太敢说，但真的很多。</p><p>这里列举一些知乎推荐过的，你也可以通过ngrok这个关键字搜索到很多。</p><ul><li>natapp.cn</li><li>小米球</li><li>Sunny-Ngrok</li><li>echosite</li></ul><h3 id="dog-tunnel"><a href="#dog-tunnel" class="headerlink" title="dog-tunnel"></a>dog-tunnel</h3><p>翻译过来就是狗洞吧，国人做的，基于GO语言开发，在GitHub上活跃度还不错，有1k+的星星，有兴趣可以试一下。</p><h3 id="serveo-net"><a href="#serveo-net" class="headerlink" title="serveo.net"></a>serveo.net</h3><p>无需注册，无需配置，只需要 ssh 就行，没有客户端，支持多端口映射，支持自定义子域名，只要一行代码。</p><p><code>ssh -R 80:localhost:3000 http://serveo.net</code></p><p>我试了一下，临时用一下真的很棒！</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>内网服务本来就是比较敏感的，所以从数据安全的角度看我觉得还是自己搭建代理服务更可靠。用不靠谱的服务有很大风险，还有可能很坑，非常坑。</p><p>比如nat123和花生壳，一步一步诱导你付费，协议，端口，流量，速度，域名每个细节都要收费，还不一次说清楚，你付完钱才知道后面还要付钱的，别问我怎么知道的。</p><p>更多讨论，你也可以去看知乎：<a href="https://www.zhihu.com/question/49629610/" target="_blank" rel="noopener">https://www.zhihu.com/question/49629610/</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse-proxy </tag>
            
            <tag> frp </tag>
            
            <tag> ngrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从手机截图报Bug扯到工具论</title>
      <link href="posts/2019-02-13/sync-screenshots-from-mobile-devices-to-pc/"/>
      <url>posts/2019-02-13/sync-screenshots-from-mobile-devices-to-pc/</url>
      
        <content type="html"><![CDATA[<p>我发现手机端的测试怎么截图报bug是个不可忽视的小问题，传统的做法真的很烦。在这里我提供一些思路给大家。</p><a id="more"></a><h2 id="自动同步截图文件夹"><a href="#自动同步截图文件夹" class="headerlink" title="自动同步截图文件夹"></a>自动同步截图文件夹</h2><p>这是一个看上去很不错的思路，现成有个工具可以达到这个目的：坚果云。</p><p>在手机端安装一个坚果云，配置好要同步的截图目录，每次截图后它会帮你自动同步。在电脑端安装客户端后直接就能看到新同步的文件，也可以直接在网页端刷新就能预览。</p><p>这个方案的问题：</p><ol><li>多台手机将登录同一个账号（实际情况必然如此，便于测试多台设备）</li><li>多台手机同步的截图目录会混在一起（N到1）， 图片很混乱</li><li>老设备很久以前的截图也会同步进来，数据量更大更混乱，你还不想删</li><li>同步的App在后台很有可能也很容易被杀掉</li></ol><p>所以这个方案适合新手机或者只用一台手机测试的情况，不是特别推荐。</p><p><img src="https://tobyqin.github.io/images/2019-02/201901051013491325.JPG" alt=""></p><h2 id="手动分享新图片"><a href="#手动分享新图片" class="headerlink" title="手动分享新图片"></a>手动分享新图片</h2><p>这是目前大家私人手机上很常用的方式，在测试机就不太合适了。</p><p>比如你不会在测试机登录自己的微信QQ，就算有公共的账号，在电脑上也只能登录一个实例，你用了其他人就用不了了。N台设备需要N个账号，明显不合适。</p><p>所以这个方案的关键是，找到一个合适的<strong>可以多设备登录，分享后能在网页端预览内容的App</strong>，并且还不能是公开分享，我的建议还是坚果云。</p><p>在手机端登录坚果云后，截图后直接分享到坚果云的某个目录，电脑上网页端刷新一下就可以看到截图，整个流程很顺畅。很多手机还可以在分享前编辑一下图片，这时候你还能用涂鸦工具标注bug区域等等。</p><p>再退一步，也可以考虑用邮箱来代替这样的App，截图，分享到邮件，填收件人，不算太爽还凑合，还有延迟可能比较高。</p><p>这个方案我用下来没有太大问题，支持安卓和苹果设备。唯一的问题是弄一个公共账号，不难。</p><p><img src="https://tobyqin.github.io/images/2019-02/201901051004382311.JPG" alt=""></p><h2 id="集成截图工具到被测应用"><a href="#集成截图工具到被测应用" class="headerlink" title="集成截图工具到被测应用"></a>集成截图工具到被测应用</h2><p>这是不少大厂的做法，比如支付宝应用截图后就会提示你是否要反馈问题，还有一些App在你摇一摇后就自动截屏反馈问题。</p><p>如果你们的开发团队有精力并且愿意为质量部门添砖加瓦，那么这个世界将会非常美好。这需要各部门的通力合作和强力支持，最主要还是老板和业务部门的点头，给资源和时间。</p><p>这样的集成可以做的很深入，不仅截图，还有日志，当前运行数据等等一并捕获提交到bug管理工具，省心啊。</p><p><img src="https://tobyqin.github.io/images/2019-02/4abeb57ffe.jpg" alt=""></p><h2 id="DIY一个同步工具"><a href="#DIY一个同步工具" class="headerlink" title="DIY一个同步工具"></a>DIY一个同步工具</h2><p>这是最后考虑的方案，简单来说就是自己写一个App，比如安装后在状态栏加一个同步按钮，或者贴在屏幕边缘等等。当你需要时点击一下进行同步，同时也提供个分享接口。做这样的一个App不算太难，不过还是需要时间和精力的投入，如果你有兴趣我们可以聊一聊。</p><p><img src="https://tobyqin.github.io/images/2019-02/201901141355323283.png" alt=""></p><p>基本功能大概是这样的：</p><ul><li>监控指定文件夹（截图目录），自动上传到远程设备目录</li><li>提供分享接口</li><li>收集设备状态</li><li>提供Web管理端，方便访问截图，查看设备信息</li><li>不需要连接数据线</li></ul><p>或许已经有类似的工具了，我没找到。但如果外部工具都不顺手的时候，自己做一个可能更符合需求。</p><p><img src="https://tobyqin.github.io/images/bee265372c.jpg" alt=""></p><h2 id="关于坚果云"><a href="#关于坚果云" class="headerlink" title="关于坚果云"></a>关于坚果云</h2><p>坚果云是目前唯一值得推荐的云盘，不限速只限流量，每月上传1G下载3G，没广告不推销，作为效率软件完全足够。每个项目组可以自己申请一个公用账号。</p><p>国内外的网盘因为各种原因都已经不值得推荐了，各种笔记类App也已经加上很很多限制，比如多端登录和流量限制等等。</p><p>坚果云作为一个要盈利的公司将来怎么样也不好说，而且是公网软件，敏感数据还是不要全往里面放。有朋友说可以考虑搭建私有云，我稍微对比总结了一下：</p><ol><li>seafile - 国内团队开发的开源企业级云存储方案，提供全平台客户端，口碑较好。</li><li>owncloud - 开源的个人云解决方案，貌似吐槽比较多，占资源，不太推荐。</li><li>nextcloud - 据说是从owncloud团队分出来的，核心差不多，颜值比较高，口碑也一般。</li></ol><p>如果将来公有云都挂了，那么我们就整一个。</p><p><img src="https://tobyqin.github.io/images/201901051016009569.jpg" alt=""></p><h2 id="我的工具论"><a href="#我的工具论" class="headerlink" title="我的工具论"></a>我的工具论</h2><p>有一些同学认为不能用太顺手的工具，因为会形成依赖，一旦离开就会浑身难受。</p><p>我认为这种担心是多余的，工具用得好，下班回家早。只有你工作效率提高了，才能更深入去了解业务和提高自己，如果总是忙于繁琐的事物，日复一日终将被工具替代。</p><p>古人云了，工欲善其事必先利其器。</p><p>古人还云了，磨刀不误砍柴工。</p><p>好的工具是不会消失的，但有可能收费。当你觉得值的话，就买下它吧，免费的有可能更贵。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第二题 - 两数相加</title>
      <link href="posts/2019-02-12/leetcode-add-two-numbers/"/>
      <url>posts/2019-02-12/leetcode-add-two-numbers/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 备忘。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个非空的链表，分别代表两个正整数。链表中存储的数字和实际的位数刚好相反，要求将这两个数字相加并以链表的结构返回。</p><p>举例说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p>假设给定的数字没有0开头（链表末位数肯定不是0），并且任意相加数也不为0。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>这道题目基本上就是模拟学生时代的加法，主要考虑遍历和进位的问题。</p><p>比较直接的做法就是：</p><ol><li>先遍历链表1，同时加上链表2对应数位的数字存入结果，暂时不考虑进位的问题。</li><li>如果链表1遍历结束后，链表2还没结束就直接剩下的直接加入结果。</li><li>遍历结果集，大于10的进位取余，直至结束。</li></ol><p>且看代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">         <span class="comment"># 相加结果集</span></span><br><span class="line">        r = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历链表1</span></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            <span class="keyword">if</span> l2: </span><br><span class="line">                <span class="comment"># 加上链表2相同位数的数字，忽略进位</span></span><br><span class="line">                r.append(l1.val + l2.val)</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果链表2已经结束，直接补位链表1</span></span><br><span class="line">                r.append(l1.val)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理下一位数</span></span><br><span class="line">            l1 = l1.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果链表2没结束，直接补位</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            r.append(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        </span><br><span class="line">        head = ListNode(<span class="number">0</span>) <span class="comment"># 结果链表</span></span><br><span class="line">        current = head</span><br><span class="line">        carry =<span class="number">0</span> <span class="comment"># 进位数</span></span><br><span class="line">        length = len(r)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#遍历结果集</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            current.val = r[i] + carry</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 大于10需要进位</span></span><br><span class="line">            carry = current.val // <span class="number">10</span></span><br><span class="line">            <span class="comment"># 取余为当前位数</span></span><br><span class="line">            current.val = current.val % <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 只处理到倒数第2位，重置current</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; length - <span class="number">1</span>:</span><br><span class="line">                current.next = ListNode(<span class="number">0</span>)</span><br><span class="line">                current = current.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果末位数还有进位，补一下</span></span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            current.next = ListNode(carry)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p>提交看看，68ms，打败92%的玩家，还不错。</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>加法我们当然可以自己算啦，也可以让CPU给我们算啊。所以解法二是一种赖皮的做法，就是把两个链表变成真正的整数，然后相加，然后再转成链表，你猜猜速度是更快还是更慢？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data_1 = <span class="string">""</span> <span class="comment"># 字符串</span></span><br><span class="line">        data_2 = <span class="string">""</span> <span class="comment"># 字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 链表1转字符串</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">None</span>):</span><br><span class="line">            data_1 += str(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链表2转字符串</span></span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="literal">None</span>):</span><br><span class="line">            data_2 += str(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 字符串翻转后转整数</span></span><br><span class="line">        data_1 = int(data_1[::<span class="number">-1</span>])</span><br><span class="line">        data_2 = int(data_2[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 相加后再转成字符串然后翻转</span></span><br><span class="line">        ans = str(data_1 + data_2)[::<span class="number">-1</span>]</span><br><span class="line">truetrue</span><br><span class="line">        <span class="comment"># 字符串拆开存放到数组</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ans)):</span><br><span class="line">            ret.append(ListNode(int(ans[i])))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历数组生成链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ret) - <span class="number">1</span>):</span><br><span class="line">            ret[i].next = ret[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>提交看看，80ms，打败了52%的玩家！看来这个来回倒腾的过程挺费CPU的，但是不费脑子啊。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于吃的几个段子</title>
      <link href="posts/2019-02-11/joke-about-eating/"/>
      <url>posts/2019-02-11/joke-about-eating/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tobyqin.github.io/images/image-20190211215953837.png" alt=""></p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>不论台湾，还是西藏新疆，</p><p>一寸一厘的国土都不能让，</p><p>谁知道上面能长出什么好吃的来。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>我这辈子，</p><p>唯一拿得起放不下的，</p><p>就是筷子了。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>作为入侵物种，</p><p>小龙虾在中国颜面扫地，</p><p>居然沦落到要靠人工养殖才能活下去……</p><p>如果有外来物种入侵中国成功了，</p><p>一定是因为它不好吃。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>在我国，东西分三类，</p><p>直接吃的，</p><p>看着好像可以吃的，</p><p>得想点办法才能吃的。</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>“说，你除了吃还会什么？”</p><p>“还会饿。”</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>亚当和夏娃吃了蛇给他们的禁果，</p><p>遭到了上帝的惩罚！</p><p>被逐出伊甸园，所以有了人类。</p><p>如果亚当和夏娃是中国人，</p><p>那被吃的，应该是那条蛇。</p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>你们吃是为了活着，</p><p>我们活着是为了吃。</p><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><p>晚上睡不着觉就开始数羊：</p><p>一只羊、两只羊、三只羊、</p><p>喜羊羊，美羊羊，懒羊羊，</p><p>沸羊羊，小肥羊，海底捞，</p><p>麻酱，小料，金针菇，虾滑，宽粉，</p><p>海带，豆芽，大海螺，茼蒿，菠菜……</p><p>TMD，下楼！不睡了！！！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> joke </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第一题 - 两数之和</title>
      <link href="posts/2019-02-10/leetcode-two-sum/"/>
      <url>posts/2019-02-10/leetcode-two-sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 备忘。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，找出和为指定值的两个元素的下标。举例说明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><p>假设数组中有且只有一种组合可以得到正确答案，并且相同元素不可以重复使用。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>很容易想到暴力破解，只要做两层循环就可以搜索出答案。实现起来和冒泡排序类似。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,length):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i,j]</span><br></pre></td></tr></table></figure><p>这个解法效率很低，运行2900ms，只打败了全球20%的玩家。</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>我们可以优化一下，用哈希表（字典）来保存数字的索引和值，这样搜索的复杂度就变成了O(1)，而遍历的复杂度是N。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="comment"># 建立index和value的反向索引</span></span><br><span class="line">        d = &#123;x:i <span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(nums)&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            part = target - nums[i] <span class="comment"># 取差值</span></span><br><span class="line">            <span class="keyword">if</span> part <span class="keyword">in</span> d <span class="keyword">and</span> <span class="keyword">not</span> d[part]==i: <span class="comment"># 在字典中搜索差值</span></span><br><span class="line">                <span class="keyword">return</span> [i,d[part]]</span><br></pre></td></tr></table></figure><p>提交看疗效，20ms，打败全球100%玩家。</p><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>其实还可以优化一下，这个哈希表可以延迟建立，这样可以省掉建表时的那次遍历。但效果嘛，不一定是优化，且看代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        d = &#123;&#125; <span class="comment"># 空字典</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            part = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> part <span class="keyword">in</span> d:  <span class="comment"># 检索字典，有则直接返回</span></span><br><span class="line">                <span class="keyword">return</span> [i,d[part]]</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 没找到，加入字典</span></span><br><span class="line">                d[nums[i]]=i</span><br></pre></td></tr></table></figure><p>提交，也是20ms，依然打败100%全球玩家。不过要注意一点，这种算法返回的下标都是反的，比如上面两种算法返回的是<code>[0,1]</code>，但是这里返回的就是<code>[1,0]</code>了。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年1月书单</title>
      <link href="posts/2019-02-09/book-list-for-2019-jan/"/>
      <url>posts/2019-02-09/book-list-for-2019-jan/</url>
      
        <content type="html"><![CDATA[<p>一月书单备忘。</p><a id="more"></a><p>##《凤凰项目，一个IT运维的传奇故事》</p><p><strong>作者：Gene Kim，Kevin Behr，George Spafford，软件工程</strong></p><p>以小说的形式讲述了主人公如何将一个公司曾经痛苦的业务，开发，测试，运维混乱互相撕逼的状况，实现浴火重生的故事。纯理论的絮叨很多人没办法看下去，故事化以后我只花了3天时间就看完了，而且大概也明白了三步工作法的套路：</p><ol><li>第一工作法是从开发到技术运营，再到客户的整个自左向右的工作流。主要依赖自动化。</li><li>第二工作法是建立各阶段自右向左的快速持续<strong>反馈</strong>流，以确保防治问题再次发生或者更快发现问题。主要为了保证上游质量，依赖价值指标。</li><li>第三工作法是创造公司文化，不断尝试，这需要承担风险并从成功和失败中吸取经验教训。主要为了持续改进。</li></ol><p>这本书评价还挺高，不管是外行还是内行都可以宏观了解到到开发运维的必要性。开发运维并不仅仅是简单的自动化工具的集成，虽然自动化是开发运维的很大一部分内容。更重要的是价值流导向，自始至终拥有共同的目标并共同解决问题。</p><h2 id="《北京折叠》《弦歌》《繁华中央》"><a href="#《北京折叠》《弦歌》《繁华中央》" class="headerlink" title="《北京折叠》《弦歌》《繁华中央》"></a>《北京折叠》《弦歌》《繁华中央》</h2><p><strong>作者：郝景芳，科幻</strong></p><p>这是第二次读《北京折叠》，作者通过科幻的主题去映射社会和阶级问题，二刷依然能让人反思很久。这也是中国第二个雨果奖获得者的获奖作品，不管你喜不喜欢，现实纵然是挺无奈的，在折叠的北京里三个阶层的人不公平地分着一样的城市和时间，跟现在社会一样，科幻版的朱门酒肉臭，路有冻死骨。</p><p>标题里的三部小说都是长篇《孤独深处》里的选篇，整部我并没有看完，可能以后也不想看完，毕竟它就是个小说集，喜欢的我就看，不喜欢的就不看。</p><p>《弦歌》和《繁华中央》其实是下上篇，嗯，先下后上。脑洞挺大，文明也可以成为最厉害的武器。如果地球上只允许文明存在，任何的武力抵抗都被消灭殆尽，想象一下。豆瓣上很多人认为这两篇才应该是雨果奖作品。</p><h2 id="《地球往事-三体I》"><a href="#《地球往事-三体I》" class="headerlink" title="《地球往事 - 三体I》"></a>《地球往事 - 三体I》</h2><p><strong>作者：刘慈欣，科幻</strong></p><p>第二次读《三体》，感觉没有第一次那么强烈了。还记得第一次读的时候，恨不得马上把整部一下读完，几个星期上班都想着剧情会怎么发展，宇宙社会学，宇宙哲学这些跟自己没关系的事情。</p><p>再读就淡定很多，难道是我年纪上去了？随着时间的推进，我觉得《三体I》会越来越难被接受，按现在的看法里面的背景设定的确有点out。这也是为什么很多人没办法体会三体迷们对作者的崇拜，因为三体最值得阅读的是后面两部，读完后面两部才算读过。</p><blockquote><p>给岁月以文明，而不是给文明以岁月。</p></blockquote><p>无论如何，这也不影响我对刘慈欣的敬佩，雨果奖实至名归。</p><h2 id="《流浪地球》"><a href="#《流浪地球》" class="headerlink" title="《流浪地球》"></a>《流浪地球》</h2><p><strong>作者：刘慈欣，科幻</strong></p><p>大年初二看完电影后去补了一下原著，中篇，不是很长，2个多小时就能看完。相对于电影情节来说，原著里表达的东西更丰富，涉及到了社会，生存这些问题。</p><p>人总归是很难一直保持理智的，尤其是在危难的时候。大多数科幻都是以灾难和悲剧收场的，因为作者或者说我们自己对人的本质都是质疑的，如果人都是无私的，那么还哪来的战争杀戮。</p><p>正义的出现是因为反派的存在，如果没有邪恶，就无所谓正义。</p><p>最后地球是不是真的要流浪我不知道，但是人类的未来一定是孤独的，当他足够强大的时候。</p><h2 id="《乌合之众》"><a href="#《乌合之众》" class="headerlink" title="《乌合之众》"></a>《乌合之众》</h2><p><strong>作者：古斯塔夫・勒庞，哲学，心理学</strong></p><p>这是我读的第一本哲学著作？不太确定了。</p><p>这本书主要对比了个体和群体的各方各面，1984年的观点在现在看来依然针针见血。所以这本书在社会心理学领域也是最有影响力的一本。</p><p>其实哲学的书挺枯燥的，里面说的你看都是对的（或者说没错）。我读的过程就是，哦，知道了，是这样的，的确是这样的，可是我能怎样，心灵也不会震动。</p><p>我来引用一些大家感受一下。</p><blockquote><p>形成集体的个人会感觉到一种势不可挡的力量，使他敢于发泄出自本能的欲望。</p><p>群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。</p><p>孤立的个人很清楚，在孤身一人时，他不能焚烧宫殿或洗劫商店，即使受到这样做的诱惑，他也很容易抵制这种诱惑。但是在成为群体的一员时，他就会意识到人数赋予他的力量，这足以让他生出杀人劫掠的念头，并且会立刻屈从于这种诱惑</p><p>群体表现出来的感情不管是好是坏，其突出的特点就是极为简单而夸张。</p><p>群体因为夸大自己的感情，因此它只会被极端感情所打动。希望感动群体的演说家，必须出言不逊，信誓旦旦。</p><p>群体可以杀人放火，无恶不作，但是也能表现出极崇高的献身、牺牲和不计名利的举动，即孤立的个人根本做不到的极崇高的行为。</p></blockquote><p>不知道以后我还会不会读哲学，也许是我阅历还不够。</p><p>但是你看，多少小说的终极问题都是哲学问题，我们看的津津有味。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 PyCharm 的使用和设置建议</title>
      <link href="posts/2019-02-08/pycharm-tips/"/>
      <url>posts/2019-02-08/pycharm-tips/</url>
      
        <content type="html"><![CDATA[<p>PyCharm是笔者强烈推荐的Python IDE，如果你有EDU的邮箱可以直接<a href="https://tobyqin.github.io/posts/2016-09-27/get-jetbrains-student-licence/" target="_blank" rel="noopener">申请专业版授权</a>，或者就使用社区版，功能上并没有太多缩减，日常开发也完全够用。</p><a id="more"></a><p>如果是首次安装PyCharm，有一些设置项建议还是按照自己习惯修改掉，所谓磨刀不误砍柴工。</p><h2 id="显示工具栏"><a href="#显示工具栏" class="headerlink" title="显示工具栏"></a>显示工具栏</h2><p>默认PyCharm并不显示工具栏（Toolbar），在大多数IDE工具栏都放了最常用的操作，你可以通过主菜单-显示-菜单栏来显示工具栏。工具栏显示出来后你还可以通过右键定制上面的按钮，我会把一些跟VCS相关的操作放到上面，比如Fetch，Push，默认它只加了Pull和Commit。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208162340.png" alt=""></p><h2 id="智能提示匹配大小写"><a href="#智能提示匹配大小写" class="headerlink" title="智能提示匹配大小写"></a>智能提示匹配大小写</h2><p>可能是出于动态语言和性能的考虑，PyCharm的代码提示默认是大小写敏感的。例如你敲<code>b</code>会提示你<code>back</code>但不会提示你<code>BACK</code>，坦白讲挺不方便的，你可以改掉它。在设置里搜索<code>match case</code>就可以进行调整。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208163613.png" alt=""></p><h2 id="鼠标滚轮调整字体大小"><a href="#鼠标滚轮调整字体大小" class="headerlink" title="鼠标滚轮调整字体大小"></a>鼠标滚轮调整字体大小</h2><p>有时候我们讨论或者分享代码时，已经设置好的字体大小可能不太合适，很多IDE或者软件都是支持使用鼠标滚轮实时调整字体大小的，PyCharm中你需要手动启用这个功能。在设置中搜索<code>zoom</code>就可以找到对应设置项。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208170026.png" alt=""></p><p>##修改单元测试框架</p><p>如果你也有写单元测试的习惯，想必一定知道pytest，PyCharm可以很好地和很多知名的测试框架，但是默认它配置的是unittest，在设置中搜索<code>test</code>就可以调整成你常用的框架。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208164442.png" alt=""></p><p>比如调整成pytest之后，只要你的方法名前缀是<code>test_</code>，那么IDE就会提示你这是一个test，在前面会多出一个小三角形，让你很方便地运行或者调试。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208165147.png" alt=""></p><p>PyCharm支持的测试框架很多，但我喜欢的还是pytest。</p><p>顺带一提的是，PyCharm可以自定义的类似配置还有很多，比如terminal使用的shell，虚拟环境选用的工具，Flask模板语言等等。</p><h2 id="提交代码前的选项"><a href="#提交代码前的选项" class="headerlink" title="提交代码前的选项"></a>提交代码前的选项</h2><p>假设你已经默认显示工具栏，那么以后你提交代码只需要点击工具栏里的Commit按钮即可，这时候会弹出一个对话框，你在这里可以很方便地看到你要提交的文件，可以随意diff，add, remove甚至直接edit。很多时候我们在diff时发现有些旮旯里总漏点东西，一般的流程时关掉diff，回到编辑器，找到那个地方改掉，在PyCharm这个提交对话框，你可以一气呵成，爽歪歪。</p><p>更厉害的是，你还可以选择提交前格式化代码，优化import区等等。</p><p><img src="https://tobyqin.github.io/images/image-20190208172622399.png" alt="image-20190208172622399"></p><h2 id="其他可以调整的设置"><a href="#其他可以调整的设置" class="headerlink" title="其他可以调整的设置"></a>其他可以调整的设置</h2><ol><li>外观和主题，包括编辑器字体，背景等等。</li><li>快捷键，如果你记不住它默认的快捷键，那么就改成你能记住的。</li><li>隐藏某些项目文件，治愈强迫症患者。（设置中搜索“ignore files”）</li><li>安装自己顺手的插件。（设置中搜索“plugins”）</li></ol><h2 id="一些使用心得总结"><a href="#一些使用心得总结" class="headerlink" title="一些使用心得总结"></a>一些使用心得总结</h2><p><strong>内置的VCS很好用</strong></p><p>内置的Version Control提供了日常操作需要的所有功能，而且触手可及，关键是非常直观，用过之后欲罢不能。它还提供了changlist和shelvset功能，让你在合并或者提交代码前暂存不想处理的修改，这是很多开发者都想要的功能。</p><p><img src="https://tobyqin.github.io/images/image-20190208173827240.png" alt="image-20190208173827240"></p><p><strong>内置的命令行工具很好用</strong></p><p>IDE内置命令行工具其实是一个硬需求，你看现在，几乎你找不到一个不带命令行的IDE。PyCharm带的IDE最方便的地方在于，可以自动识别项目里的虚拟环境并启用它，这是外部命令行工具没法比拟的。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208174528.png" alt=""></p><p><strong>内置的Python Console很好用</strong></p><p>写Python肯定是离不开即时解释器的，在PyCharm里你随手就可以用Python Console测试代码片段，它不仅提供了智能提示，还可以查看运行中的变量，甚至还能绘图画表，集成iPython Notebook。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208174959.png" alt=""></p><p><strong>修改运行时状态很爽</strong></p><p>当你用PyCharm调试代码时，可以直接在Variables窗口看到运行变量，也可以直接修改这些变量的值，更厉害的是，你可以直接执行语句，点那个计算器一样的图标就行。</p><p><img src="https://tobyqin.github.io/images/2019-02/20190208175713.png" alt=""></p><p>这个功能Visual Studio里也有，叫ImmediateWindow，可以节约你大把的调试时间。然而PyCharm少了一个Visual Studio里我非常喜欢的功能，拖拽当前断点。假设当前断点停在第40行，VS里可以直接拖到前面几行，例如第30行，人为控制这块代码反复运行。</p><p><strong>总是为新项目建立虚拟环境</strong></p><p>千万不要只用默认的Python环境写多个项目，2个也不行，以后你会后悔的。如果你能真的确定这台机器的Python只跑一个项目，那你可以不用虚拟环境。在PyCharm建立一个新的虚拟环境只需要点几下，不麻烦的。</p><p><img src="https://tobyqin.github.io/images/image-20190208195643324.png" alt="image-20190208195643324"></p><p><strong>导入导出配置最靠谱</strong></p><p>前面我们说了很多配置选择，如果你有N台机器都安装了PyCharm，每台都重新配置一遍多累啊，特别是快捷键如果不用默认的，换机器都想哭。</p><p>PyCharm提供了一个同步配置的方案，你可以新建一个空的git repo，填到 Tools / Settings / Repository 里就可以自动上传配置。别的机器也同样配置一样，理论上配置就云同步了。但是我亲身体验告诉你，这个真不靠谱，Mac和Windows多倒腾几次就错乱了，想哭啊。还好我有方案B。</p><p><img src="https://tobyqin.github.io/images/image-20190208195752742.png" alt="image-20190208195752742"></p><p>方案B很简单，在某一台机器配置好后，选择主菜单 - 文件 - 导出配置。导出的配置是一个jar文件，随便扔到印象笔记或者坚果云里，新机器里用主菜单 - 文件 - 导入配置即可。</p><p><strong>专业版和社区版的区别</strong></p><p>刚好两个版本我都在用，大概说说专业版多出来可能会用到的东西。</p><ol><li>和Flask，Django深度集成，智能提示到你惊讶的级别。</li><li>支持调试多线程，提供性能优化工具。</li><li>快速获得和显示单元测试覆盖率。</li><li>集成数据库工具，可以在IDE里直接连接任何数据库。</li><li>支持Live Edit，让你在编辑代码同时，实时在浏览器中展示。</li><li>支持一键部署docker。</li></ol><p>专业版还是很厉害的，不过也很贵。多出来的功能挺方便，但也不是必须的，大家可以酌情选择。</p><p>最后，祝大家happy coding。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tips </tag>
            
            <tag> pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 DevOps ，咱们聊的可能不是一回事</title>
      <link href="posts/2019-01-29/about-devops-we-may-not-be-talking-about-the-same-thing/"/>
      <url>posts/2019-01-29/about-devops-we-may-not-be-talking-about-the-same-thing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文： <a href="https://www.jianshu.com/p/645bb1283a77" target="_blank" rel="noopener">https://www.jianshu.com/p/645bb1283a77</a></p></blockquote><p>在过去的三年中，我作为 DevOps 的咨询师参与了很多企业的 DevOps 转型咨询以及技术实施，也在不同的社区活动中分享了自己在 DevOps 上的实践、理解和观点。</p><a id="more"></a><p>随着 DevOps 的盛行，我在很多场合和越来越多的人聊起 DevOps。也在不同的渠道听到了很多人在讲 DevOps。然而，讨论的背后，我发现每个人对 DevOps 所指并不是同一件事情，也由于各执一词导致不欢而散。</p><p>于是我通过 DevOpsDays 的官方网站整理所有 DevOps 的有关材料，随着学习和了解的不断增多，我也渐渐的对 DevOps 有了更进一步的认识。我把学到的材料经过整理后把陆续放在了简书上，形成了” DevOps 前世今生” 这个系列，这个系列还在不断补充新的材料。</p><h2 id="含义越来越丰富的-DevOps"><a href="#含义越来越丰富的-DevOps" class="headerlink" title="含义越来越丰富的 DevOps"></a>含义越来越丰富的 DevOps</h2><p>DevOps 至今都缺乏一个清晰和统一的认识。对于一场运动来说，这是一件好事，也同样是一件坏事。虽然 Patrick 曾经在自己的博客里一再提到自己对 DevOps 的”正确认识’’，但社区似乎不以为然。</p><p>缺乏“官方定义”好处是人人都可以定义，因此没有一个人或者组织可以垄断 DevOps 定义权。所以每个人都自己可以参与到这一运动中去，不断为其增加新的概念、新的实践和新的工具。这会使 DevOps 社区不断的繁荣。</p><p>而坏处也很明显，对于 DevOps 的后来者 —— 那些没有参与进来的人，需要学习和理解的 DevOps 知识的广度和深度也越来越大。</p><p>以至于后来出现了这幅众所周知的“盲人摸象图”：</p><p><img src="https://tobyqin.github.io/images/2019-01/274927-9e9fe4421aa97735.png" alt=""></p><p>这幅图中包含了很多概念，但主要表现的意义 DevOps 是一系列概念的总和，任何一个单方面的定义只是 DevOps 的一个部分，而不是 DevOps 的整体，随着 DevOps 这个概念的不断膨胀，人们就更难理解 DevOps 了。</p><h2 id="那么，你理解的-DevOps-是指的什么？"><a href="#那么，你理解的-DevOps-是指的什么？" class="headerlink" title="那么，你理解的 DevOps 是指的什么？"></a>那么，你理解的 DevOps 是指的什么？</h2><p>在接触了各类客户和社区之后，我开始尝试理解每个人谈到 DevOps 的时候，他们分别指的是什么，以及所指内容背后的目标和动机。渐渐的，我把我所听到的 DevOps 概念分成如下四类，分别是：</p><ul><li>DevOps 是一组技术/实践</li><li>DevOps 是一个角色</li><li>DevOps 是一种工作方式</li><li>DevOps 是一种组织结构</li></ul><p>那么，我们分别来谈谈这四类 DevOps。</p><h2 id="当-DevOps-是一组技术-实践"><a href="#当-DevOps-是一组技术-实践" class="headerlink" title="当 DevOps 是一组技术/实践"></a>当 DevOps 是一组技术/实践</h2><p>在工程师文化的组织里，对先进技术的渴望是最常见的学习动机。可以促进工程师用更有效率，更优雅的方式解决问题。而对于非工程师文化的组织，新的技术往往是提升其 KPI 的工具。以下是我听到 DevOps 的时候，经常触及的话题：</p><ul><li>高频部署</li><li>持续交付</li><li>云计算/虚拟化技术</li><li>基础设施即代码</li><li>Docker</li><li>自动化运维</li></ul><h4 id="高频部署"><a href="#高频部署" class="headerlink" title="高频部署"></a>高频部署</h4><p>曾经和某跨国著名银行的外汇交易产品的 IT 产品负责人交流 DevOps。对方很自豪的告诉我，他们产品每天的部署频率超过500次，我听了不以为然。因为，部署频率高不见得是件好事。于是我问了以下几个问题：</p><ol><li>为什么你们需要这么频繁的部署？有这么频繁变动的业务需求吗？</li><li>在这么多次部署里，是发布业务价值的部署更多，还是修复问题的部署更多？</li><li>这些生产环境的变更难道完全是不可规划的吗？</li></ol><p>由于对方的金融业务有相应的法律法规，理论上没有这么频繁的变更需求，除非清理技术债，否则没有很强烈的变更动机。但对方并没有直接回答我的问题，而是换到了其它问题上，因此我最终也不清楚对方这么频繁变更的驱动力。</p><p>这对我有一个重要的：指标导向的 DevOps 往往是一种 DevOps 的反模式，它会忽略和掩盖真正的问题。</p><p>指标的背后是某种度量，如果部署频率一直很高，一定反应了某种现象。而这些现象不一定是个好现象：不是业务的变动很频繁，就是技术的变动很频繁。但如果二者都频繁，我们应该衡量变更带来的价值和风险（当然，DevOps 可以降低变更的风险），并优先变更价值较高的请求。有可能新的业务尝试让我们从市场上获得了更多的关注，也有可能新的技术提升了生产率。但无论是哪一种，部署频率应该是一个有多到少不断循环的过程。这表明系统在走向成熟和稳定的同时，能够及时响应变化，无论是对技术还是对业务，对变更产生的影响都需要一段时间去积累和总结数据。</p><p>此外，DevOps 绝不是为了提升部署频率而牺牲了软件质量和业务价值，甚至是安全措施。换句话说，DevOps 不是一种对质量的平衡和妥协，它是一种全局改进。全局的改进就意味着以价值为最高原则所度量的相关指标是不能有所下降的。</p><h4 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h4><p>持续交付是 DevOps 中非常重要的实践，持续交付的思想远早于 DevOps 。但直到第二届欧洲的 DevOpsDays 才有了持续交付这个重量级话题。因为持续交付本身也通过技术手段和实践解决了 DevOps 最初所面临的 Dev 和 Ops 的合作问题。</p><p>不夸张的说，如果 Patrick Debois 早一点读到持续交付中运维相关的话题，说不定就没有 DevOps 了。</p><p>然而，随着 DevOps 的理念的发展比持续交付融汇了更多的概念（这就是没有一个人能垄断定义的好处），使得 DevOps 更加广泛和盛行。因此， DevOps 所涵盖的范围已经超出了持续交付本身。</p><p>我把 持续交付 列为 DevOps 的核心实践之一，因为如果你没有实践 持续交付。那么根本不能称之为 DevOps，但是如果你完整实践了持续交付，那么你离完整的 DevOps 也不远了。</p><h4 id="云计算-虚拟化技术"><a href="#云计算-虚拟化技术" class="headerlink" title="云计算/虚拟化技术"></a>云计算/虚拟化技术</h4><p>随着分布式应用的井喷式发展。基础设施的管理成为了分布式应用的新瓶颈。在集中式管理的时代，大型应用只能运行在昂贵的小型机上，只有微软，SAP， IBM ，Oracle 和 EMC 这样的企业才有能力提供相应的产品完成这样复杂度很高的架构。因此企业需要单独的运维部门（Ops）来管理这些软件和设备。</p><p>而随着虚拟技术和云计算的兴起，企业的基础设施管理工作往往变得很简单。VMWare 这样的虚拟技术企业和 AWS 这样的云计算供应商提供了更加成熟和稳定的产品。大大的节约了企业机房管理的开支。</p><p>而 Ops 也不再需要进出机房，只需要通过远程桌面的方式就可以使用各种 SDK 开发工具去完成过去很多只有在机房才能做到的操作。</p><p>然而，即使云计算和虚拟化技术提升了 Ops 的生产率，减轻了 Ops 的痛苦。但仍没有解决 Dev 和 Ops 之间的矛盾 —— 开发团队和维护团队仍然各自为政，仍然通过制度谈判而不是合作共赢来工作，毕竟目标是相对立的。</p><h4 id="基础设施即代码"><a href="#基础设施即代码" class="headerlink" title="基础设施即代码"></a>基础设施即代码</h4><p>随着设备和网络的持续增多，加之更加复杂的应用部署和初始化。基础设施的管理成为了一个十分尖锐的问题。当复杂度上升一个量级，就需要专业的管理工具来管理这类问题。于是 Puppet 这样的框架顺势而出。以至于在 《DevOps Handbook》中，合著者之一的 John Willis 在理解了 PuppetLab 的创始人 Luke Kanies 的想法之后，才有了 DevOps 的最初理解。</p><p>基础设施即代码利用了编程语言和虚拟化工具 API 的无缝连接达到这一目的。它在很大程度上把基础设施的管理当做其问题域，采用正确的面向对象方式，让开发人员和运维人员能够理解并设计出更加稳定和灵活的基础设施。大大降低基础设施变更的风险：提升了运维知识的透明度并使基础设施变更具备幂等性。</p><p>此外，它在一定程度上解决了不同环境（开发，测试，生产）之间的不一致问题，也让开发人员能够学习到 Ops 领域的知识并用软件开发的优秀思想解决运维领域的问题。</p><p>因此，基础设施即代码除了工具以外，更是一种 Dev 和 Ops 之间相互沟通的媒介，能够让开发人员和运维人员相互理解。所以，基础设施即代码毫无疑问的是 DevOps 的核心实践之一。</p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p>Docker 是含着 DevOps 的金钥匙出生的，它诞生的第一天就带着 DevOps 的基因：更简单的解决了基础设施即代码和虚拟化在实践中的问题，进一步提升了自动化能力以提升效率，并且对开发人员和运维人员都十分友好。</p><p>甚至很多地方都会以是否采用 docker 来评判是否采用了 DevOps 的相关技术。</p><p>Docker 一定程度上简化了基础设施的初始化和状态管理问题。通过镜像和运行时容器封装了应用运行时的复杂度。并通过容器的编排实现轻量级的分布式架构，也更加经济快捷。</p><p>但是，Docker 和任何一种工具一样，都不是”黄金锤“。当用错了场景，使用 docker 可能是一场灾难。我曾经参与并帮客户完成了一个数据中心迁移的项目，就是采用的 docker 作为统一的运行时容器。最初是因为 docker 镜像的移植性好，在各种异构 Linux 系统上可以正确执行，且镜像构建过程透明。但是客户为了能让这个业务场景更加通用，又分别采用了另外两种工具对其部署场景进行封装，并写出了第三个工具。由于这个工具并没有很好的分离其业务关注点和技术关注点，导致这个工具使用异常繁琐，需要增加更多额外的配置去定制化容器运行环境。原本为了提升生产效率的手段反而成为了阻碍效率的绊脚石。</p><h4 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h4><p>看了以上那么多的工具和技术，很多对 DevOps 望文生义�或有些技术了解的运维工程师认为提高了自动化运维的水平，就是 DevOps。虽然 DevOps 里的一个重要特征是“自动化”，但拥有自动化运维，并不代表你就正在实践 DevOps，很可能你仅仅提升了运维部门的效率，但并没有从全局的角度提升开发和运维之间的效率和端到端价值的流动。因此，仅仅有自动化运维，还不足以称之为 DevOps。</p><h4 id="关于-“-DevOps-技术”"><a href="#关于-“-DevOps-技术”" class="headerlink" title="关于 “ DevOps 技术”"></a>关于 “ DevOps 技术”</h4><p>以上列举了很多所谓 “DevOps 技术”，是从技术的角度来认识 DevOps。然而，不探索 DevOps 真正的问题，以及技术背后的目的和最佳实践。往往会使导致对 DevOps 的片面了解而适得其反。</p><p>从 DevOps 运动发展的历史上来看，DevOps 相关技术是解决 DevOps 相关问题的结果，而非起因。因此，对于 DevOps 的理解如果本末倒置，则很有可能起到东施效颦的结果。你会发现你拿着一堆 DevOps 的锤子，看见了可能并不存在的钉子。</p><p>此外，我相信掌握工具对于工程师群体来说不是一件难事，并且随着技术的发展，工具和平台的使用会越来越容易。但是，能够跳出自己的舒适区和思维习惯，从全局的角度观察并解决问题的能力则是很多工程师所欠缺的。</p><h2 id="当-DevOps-是一个岗位角色"><a href="#当-DevOps-是一个岗位角色" class="headerlink" title="当 DevOps 是一个岗位角色"></a>当 DevOps 是一个岗位角色</h2><p>当 DevOps 传播开来，大家都会倾向于去找叫做 “DevOps” 的人，希望通过招聘和培训来提升自己的 DevOps 能力。 于是设置了一些称之为 “DevOps 工程师” 的岗位和角色。通过对这些招聘需求以及客户对 DevOps 的需求，我发现了四个不同但是相关的 “ DevOps 工程师 “ ：</p><ul><li>作为 Dev 的 Ops（会开发技能的运维工程师）</li><li>作为 Ops 的 Dev（会运维技能的开发工程师）</li><li>基础设施开发工程师</li><li>全栈工程师</li></ul><h4 id="作为-Dev-的-Ops"><a href="#作为-Dev-的-Ops" class="headerlink" title="作为 Dev 的 Ops"></a>作为 Dev 的 Ops</h4><p>有很多人也会认为，只要让开发工程师掌握运维技能，运维工程师掌握开发技能，就做到了 DevOps。这招来了很多运维工程师的反感。我采访过一些运维工程师，当初他们就是不喜欢也不想写代码，才选择了运维方向。</p><p>这种想法的其中一个动机是在于架构的逐渐稳定带来的运维工作减少，特别是使用了云计算技术和虚拟化技术的企业。这会让管理层有一种错觉，认为运维团队的空闲状态，一定程度上是浪费。因此，为了达到“人尽其用”，让运维工程师进入开发团队去写业务代码。并用“DevOps”作为对这种措施这一合理化的幌子。</p><p>这种想法的天真在于忽视了开发和运维的专业性和差异性。这让我想起一个段子：</p><blockquote><p>老板：“我怎么觉得在公司的运营中你们部门没起多大作用？”</p><p>运维经理：“你走过大桥吗？”</p><p>老板：“走过。“</p><p>运维经理：“桥上有栏杆吗？”</p><p>老板：“有。”</p><p>运维经理：“您过桥的时候扶栏杆吗？”</p><p>老板：“不扶。”</p><p>运维经理：“那么，栏杆对您来说就没用了？”</p><p>老板：“那当然有用了，没用栏杆护着，掉下去怎么办？”</p><p>运维经理：“可是您没有扶栏杆啊！？”</p><p>老板：“…… 可是 …… 可是没有栏杆，我会害怕！“</p><p>运维经理：“那么，运维就是桥上的栏杆。“</p></blockquote><p>虽然我不否认技术的发展对二者来说难度和门槛在不断降低。而且掌握一定开发技能的运维工程师前景更加光明。但是强人所难并不会让事情变好。此外，这类人才可遇不可求，也不要因为招不到这样的人而阻止了 DevOps 实践。</p><h4 id="作为-Ops-的-Dev"><a href="#作为-Ops-的-Dev" class="headerlink" title="作为 Ops 的 Dev"></a>作为 Ops 的 Dev</h4><p>同样的误解也会发生在开发工程师身上。对于开发工程师来说，其实难度并没有增加。无非是把 Ops 的工作当做需要通过别的工具完成的开发需求而已，甚至很多开发工程师自己也这么认为。</p><p>运维除了知识以外，很大一部分的不可替代性来源于生产环境的维护经验。然而这些经验不可复制，因为有些问题作为开发人员来说你很难碰到。我曾打趣的说，当你听到有人说“这不可能啊”，他一定是个运维新手。</p><p>就像我在上文强调的，软件开发和软件维护是相互关联但是各自独立的专业领域。DevOps 并不是要消除任何一方，而是要通过更加深入的合作成为彼此工作的润滑剂而非绊脚石。</p><p>对于开发工程师来说，掌握更多的技能绝对是一件好事。但也不要低估运维的专业性和经验性。</p><h4 id="基础设施开发工程师"><a href="#基础设施开发工程师" class="headerlink" title="基础设施开发工程师"></a>基础设施开发工程师</h4><p>由于有了虚拟化和基础设施即代码这样的技术，“通过 Dev 的方式完成 Ops 的工作，就是 DevOps “ 也很自然的成为了很多 Ops 对 DevOps 的认识。指的是通过 SDK，相关工具和配置文件，利用现有的平台资源，为应用程序构建基础设施。而他们往往有一个新的称谓：基础设施开发者 （Infrastructure Developer）或这 云计算工程师 （Cloud Engineer）。</p><p>有一次到马来西亚出差，我称自己是 Infrastructure Developer 被 Uber 司机当做政府基建项目开发商�问了一堆稀奇古怪的问题，当然我并没有澄清，而是继续逗他 ;-D</p><p>在一些企业里，基础设施开发工程师都会肩负着推行企业 DevOps 的责任。但很少有企业能够明确 DevOps 是要做什么（这就是 DevOps 缺乏基准定义的坏处），而这些基础设施开发工程师会慢慢变成一个孤立的“平台团队”，这对 DevOps 是不利的。</p><h4 id="全栈工程师"><a href="#全栈工程师" class="headerlink" title="全栈工程师"></a>全栈工程师</h4><p>当然绝对不排除有些工程师是既懂开发也懂运维的”复合型人才”。但这样的人才的成本也十分高昂：一方面是寻找这样的人所花费的时间。另一方面是雇用这样的人所花费的资金。此外，对于某些企业来说还有培养这样人才的成本。</p><p>但是，仅仅认为有了这样的人才就具备 DevOps 的能力也并不现实。首先，DevOps 是一个团队属性，而不是一个人属性。一个人的力量相较于一个团队来说，还是很有限。其次，招聘这样的人主要还是为了胜任纷繁多变的工作，创业公司尤其如此。因此，我有时候会戏称全栈工程师为“全干工程师”，听起来很厉害，但工作境遇并不见的很好。</p><h4 id="你可能只需要一个-“DevOps-晃动器”"><a href="#你可能只需要一个-“DevOps-晃动器”" class="headerlink" title="你可能只需要一个 “DevOps 晃动器”"></a>你可能只需要一个 “DevOps 晃动器”</h4><p>软件开发和软件运维，是两类不同但联系很密切的事务，在过去很长的时间里。由于专业性和责任的不同从甲乙双方的矛盾变成了企业内部的矛盾。这是企业在互联网转型过程中的必经阶段，因为运维的开发不密切合作带来的问题日渐突出。而如何平滑的过渡，则是 DevOps 成败关键所在。你所需要不光是工程人才，你还需要新型的管理人才或者外部顾问来推动这项改进。</p><p>一般来说，DevOps 的变革一定会调整组织的制度和做事方式。而制度层面的改变从企业内部是很难做到的。企业越大，“不求有功，但求无过”的鸵鸟心态普遍存在，因此越是大型的组织，所面临的组织僵化会越严重。组织僵化不见得是一件坏事，这意味着你的企业组织形态更加的问题和高效，这是长时间积累的结果。但由于过于高效，组织僵化的负面效应就是缺乏创新。</p><p>所以，要推动企业的 DevOps 转型，特别是制度方面的创新，往往需要从组织外部引入“晃动器”（无论是聘用新的管理人才，还是外部顾问）来松动一下过于高效的组织，这都是能够帮助组织解除僵化的方式。</p><h2 id="DevOps-是一种工作方式"><a href="#DevOps-是一种工作方式" class="headerlink" title="DevOps 是一种工作方式"></a>DevOps 是一种工作方式</h2><p>这算是最贴近 DevOps 的目标的定义。但是在理解和时间上也是问题百出，片面的理解和机械的模仿都会造成 DevOps 之痛。对于 DevOps 的工作方式，有以下四个常见的理解：</p><ul><li>用 Dev 的方法做 Ops 的事</li><li>换了名字的 Ops 团队</li><li>一个有 Ops 的 Dev 团队</li><li>一个 Dev 和 Ops 合作的团队</li></ul><h4 id="用-Dev-的方式做-Ops-的事"><a href="#用-Dev-的方式做-Ops-的事" class="headerlink" title="用 Dev 的方式做 Ops 的事"></a>用 Dev 的方式做 Ops 的事</h4><p>当你采用了上文中的 “基础设施即代码”，或者你有了“基础设施开发工程师”的时候。很自然的会想“我已经做到 DevOps 了”。然而，如果你并没有注意我在上述概念中特别提到的情况，那么你可能得到的只是下面所述的”换了名字的 Ops 团队“。</p><h4 id="换了名字的-Ops-团队"><a href="#换了名字的-Ops-团队" class="headerlink" title="换了名字的 Ops 团队"></a>换了名字的 Ops 团队</h4><p>这其实是很多公司的做法，认为 DevOps 所做的事情只是技术的更新，并无其它。</p><p>在 2016 年底我在悉尼的一个 DevOps 项目上做转型咨询，客户的应用系统是基于 AWS 构建的。并且客户始终认为 DevOps 工程师就是上文所述的基础设施开发团队，只是工作的内容全都在 AWS 上面，并没有什么变化。而且给这个团队一个很高大上的名字：Enablers。然而，这个团队仅仅用新工具是清偿了之前运维工程师留下的技术债，并没有帮助开发团队、测试团队甚至是业务团队从自己的角度提供帮助来提升价值的流动速度和工作效率。</p><p>不光如此，因为这个团队掌握了关键的基础设施资源，成为了所有团队前进的阻力，导致其它部门有更多积压的工作并需要更多人的人来处理。由于出现了这样的结果，“DevOps doesn’t work in my orgnization”（DevOps 在我的组织里不好使）的批评也不绝于耳。</p><p>在 DevOps 转型的初期，我们需要一个这样的团队从运维的角度提出统一的方案并提供统一的服务支持。但随着 DevOps 能力和成熟度的提升，这样一个实体团队而不是虚拟团队的存在则会成为 DevOps 继续发展的阻力。</p><h4 id="一个有-Ops-的-Dev-团队"><a href="#一个有-Ops-的-Dev-团队" class="headerlink" title="一个有 Ops 的 Dev 团队"></a>一个有 Ops 的 Dev 团队</h4><p>最天真的想法莫不如把两类工程师放在一个团队里，在同一个负责人的范围内消化 Dev 和 Ops 的问题。这样，Dev 和 Ops 就能统一目标，平衡矛盾和冲突，共同解决问题。</p><p>但实际上很少有企业能够走出这一步，一方面是 IT 部门的岗位设置和预算归属，另一方面是团队变更后的 KPI 考核。一件很小的举动就会牵扯更多的问题，使 DevOps 难以进行下去。此外，如果缺乏有效的 DevOps 实践或者外部教练d 额指引，那么使 Dev 和 Ops 的融合将是一个漫长的旅程。</p><p>在这种情况下，我建议采用 DevOps 项目制的方式来进行 DevOps 的体验：</p><ol><li>首先根据项目汇聚资源，在项目中预留 Ops 角色。</li><li>从运维部门借调运维工程师到项目中。运维部门要提前安排好运维工作的交接，或者至少把日常性的运维任务的80%剥离出来，分配给现有团队。保证进入项目团队的运维工程师的工作不被打扰</li><li>Ops 所在的部门绩效分为两块：一块为常规运维绩效（保证系统稳定性），另一块为 DevOps 项目绩效（保证开发顺利性），可以根据具体工作状况来设置这样的工作比率。</li><li>保证运维团队人员能够有机会进入项目实践 DevOps ，同时要把项目开发中的运维痛点带回给运维团队处理。</li></ol><p>在上述 2的悉尼项目里，我就成为了加入到了产品开发团队中的运维工程师。一方面解决开发团队痛点，一方面和 Enablers 团队沟通。一方面解决 开发团队的痛点，另一方面获得相应的权限和知识，并把 开发团队的反馈及时传达给 Enablers 团队。</p><h4 id="一个-Dev-和-Ops-合作的团队"><a href="#一个-Dev-和-Ops-合作的团队" class="headerlink" title="一个 Dev 和 Ops 合作的团队"></a>一个 Dev 和 Ops 合作的团队</h4><p>这就是 DevOps 所要达到的目标，它不是一个人的属性，而是一个团队的属性。它让利益相关方坐在一起解决问题，而不是相互甩锅。然而，由于”合作“的定义很简单，也很空泛，导致”合作“难以落地。以下是我认为”关键”的 DevOps 合作方式：</p><ol><li>共同进行架构设计</li><li>共同进行技术决策</li><li>持续交付流水线的建立</li><li>共同 Pair 和 Review 代码和环境的配置</li><li>共同参与回顾会议</li><li>通过定期的内部 Session 增加相互的理解</li><li>共同处理运维的问题</li></ol><p>此外，还有很多其他的合作方式能够提升 DevOps 的效果，在此不一一列举，这里仅做参考。如果你是一个敏捷的团队，只需要把 Ops 作为团队的一份子，参加所有的活动就可以了。</p><h2 id="DevOps-是一种组织文化"><a href="#DevOps-是一种组织文化" class="headerlink" title="DevOps 是一种组织文化"></a>DevOps 是一种组织文化</h2><p>在著名在 Velocity 09 大会上，来自 Flicker 的著名演讲”10+ Deploys Per Day: Dev and Ops Cooperation“ 明确的指出工具和文化是他们成功的原因。这也第一届 DevOpsDays 也将工具和文化这两个话题进一步细化。在会后 Patrick Debois 把 DevOps 定义为“管理改进”和技术提升“。</p><p>John Willis 和 Damon Edwards 也在 2010 年 MoutainView 举办的 DevOpsDays 中重新强调了文化的重要性。</p><p>相对于可以看得见的工具，文化显得华而不实，也有人认为 DevOps 文化是一种“空谈陷阱”。</p><p>有一篇关于企业文化的文章写的非常好，这篇文章叫做”Culture is the Behavior You Reward and Punish“。翻译过来就是：文化就是你奖励和惩罚的行为。就是说对行为的惩罚和奖励构成了你的文化，对 DevOps 也一样。奖励符合 DevOps 的行为（而不仅仅是鼓励），惩罚不符合 DevOps 的行为。就形成了 DevOps 的文化。</p><p>而我所说的“建立 DevOps 的文化“则是建立一种规则约束，这种约束不但包含了 DevOps 的行为准则，而且包含了奖励和惩罚的机制。而这种规则约束不能变成一纸空文，更要切实执行下去，形成一种行为习惯。</p><p>习惯的力量则能够保证一种好的制度和实践顺利的延续下去。当然这种规则约束不是一成不变的，这些约束和规则也需要根据团队的发展不断的变化以适应新的状况。</p><p>然而，就如上文所说的，由于企业并不存在产生 DevOps 的基因（否则你早就有 DevOps 了）。这些制度很难从内部产生，必须要的话，请引入外部资源，例如 DevOps 顾问或者 DevOps 教练。</p><p>我经常看到一些 ”KTV式转型”，这种转型就像是唱 KTV：当人们在 KTV 里面对歌词字幕你总能唱出来，也能唱对。但如果没有歌词，人们往往就唱不出来了。这里的歌词字幕就相当于是转型教练，当教练在的时候，每个人都知道怎么做。当教练不在，什么都没有了。</p><p>很多情况下，顾问和教练在短期内起到从”0到1“的转变，然而从”1-100“则不是一朝一夕就能实现的。文化的形成是一个长期的塑造过程，不是能够买来的。你需要有足够的耐心来不断的评估和反馈当前的状况。</p><p>以下是 DevOps 所鼓励的行为。尽管每个人都鼓励以下的行为，但实际效果则千差万别，往往抓住了形式而不是本质。</p><ul><li>信任</li><li>沟通</li><li>学习</li><li>分享/共担</li><li>不要指责</li></ul><h4 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h4><p>你的团队里的 Dev 和 Ops 之间是相互信任的吗？你信任你的团队成员吗？如果回答是。那么你的团队成员信任你吗？信任是相互的，而且是高效团队成功的基石。获得信任很难，需要时间去建立。信任同样也很脆弱，很容易就会失去。你是否明确哪些行为对信任有帮助，而哪些行为会伤害信任？你能说出那些帮助构建信任和伤害信任的行为吗？你的团队都清楚吗？</p><p>当想到以上这些问题，你还信任你自己和你的团队吗？</p><p>这里有一个很重要的原理：没有无条件的信任，信任是需要建立的。</p><p>除了《凤凰项目》中所介绍的构建信任的方式——把自己最脆弱的一面告诉大家——以外，这里我推荐一种构建信任的方式：</p><ol><li>回顾团队中的每一个人。</li><li>把你不信任的人说出来，并且说出你不信任的点。</li><li>为了消除这种不信任，你自己愿意做什么事情（而不是让对方做什么事情）</li><li>其它人为了消除团队中的不信任，也可以轮流发言。</li><li>如果消除了这种不信任，也请说出来。并为之前你不信任的人和整个团队故障欢呼。</li></ol><p>第三点最为重要，我们给出的建议往往不起效的原因就在于你在对别人提要求，而不是提供帮助。而人们对于提要求的感受都不会很好，只有提供自己的帮助，才是真正能解决问题的有效方式。另外，作为同一个团队的成员，你也必须想办法相信对方，并且让对方相信自己，没有选择。</p><p>很多人都觉得难以启齿，难以启齿的原因就是因为人们不愿意相信对方能够接纳这些不信任。而这么做恰恰能表明你对对方的信任，相信经历过一系列的措施之后，能改善当前的状况。</p><p>如果你觉得信任很难达成，那么这就是一个风险点，他会影响团队成员的行为和判断，造成不利的影响。所以，请多检查团队内部的信任情况，及时排除风险。</p><h4 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h4><p>沟通是一个泛滥的话题，各种打着“高效沟通”的方法也层出不穷，但人们虽然都懂各种道理，也知道沟通的重要性，可沟通仍然被用作为”命令“的幌子，或用来实施语言暴力。</p><p>沟通的主要目的在于对齐交换意见和看法，达成理解。</p><p>沟通不仅仅是信息交流的通道，同样也是情绪宣泄的出口。我们在沟通中，有多少是发泄情绪占了很大的比重，但我们往往没有察觉。人们对表达自己的情绪是难以启齿的，因此用各种各样的“道理”来掩盖真实的意图。如果团队成员的大脑被不良情绪占据，那么无论如何他在团队中都不会有很好的表现的。人们往往会用其它的方式宣泄自己的情绪，而缺乏正确的发泄渠道则会导致灾难。</p><p>你的团队里有没有比较沉默的人或者是不喜欢主动沟通的人？由于信任的逐渐缺失，有些人往往不再沟通。而这类不再沟通的人，往往是项目中的定时炸弹。而情绪积累到某一个点后，这个炸弹就会爆炸，造成很恶劣的影响。所以，尽早的介入并让每个人能够很顺畅的沟通，对降低情绪风险，尤为重要。</p><p>此外，在沟通里，你是听的多？还是说的多？如果作为听者，你真正明白对方讲的是什么吗？如果作为说者，你在沟通之前，你是否有计划，是否明确沟通的目的，沟通后如何确认达到了沟通的目的？</p><p>如果不确认这些问题，那么沟通往往就是没有意义的闲聊。</p><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><p>在英文里， 学习是一个词——Learn 。而在中文里“学习”是两个词，对应的英文分别是 Learn （学）和 Practice（习）。比如：learnt 就可以因为上下文的不同表示两种意思。一种是”经历过学习的过程，但不一定掌握”，另一种则是真正学会了。</p><p>当说到学习，往往想到的都是“输入”：看书（虽然买了也未必会看），看博客，看代码，看视频…… 然后练习，直到掌握。</p><p>然而，仅有输入是不够的，学习还应当有”输出“：形成博客、开源软件、演讲甚至是培训工作坊。有一句很著名的话叫做：“教是检验学习成果的唯一标准。”是不是真的掌握了，教一下别人，你会意识到“学习的错觉”。</p><p>在这里，我要强调一种重要的输入途径：从过往的经验教训中反思，总结，并形成团队的经验。很多事情过去了，无论成败，往往缺乏总结。这无法让团队成长，因为成败全凭”运气“。</p><p>学习的目的在于指导今后的实践，无论成败，都会降低未来失败的概率，多做“正确的事”，少做“错误的事”。</p><p>而只有学，没有习。只有输入，没有输出，或者只向外看，不向内看，都是片面的学习方式。我推荐的学习方式则是以输出作为学习目标，对知识和信息进行加工，思考，实践，提炼的过程。</p><p>毕竟，判断一个人的知识不再于他的输入，而在于他的输出。因为讲出来，才是自己的。</p><h4 id="不要指责"><a href="#不要指责" class="headerlink" title="不要指责"></a>不要指责</h4><p>很多问题棘手是因为人们不关注如何解决问题，而关注这个问题究竟是谁该负责。如果团队在责任归属的问题上花的时间很多，那么这就是一个指责文化的制度。在这种情况下，团队成员为了自保，会避免承担责任和解决问题。因此，很多事情没有进展，于是，整个组织沉浸在一种”不求有功，但求无过“的氛围下慢慢凝结，最后僵化。</p><p>我们常常听到“零容忍”，然而对问题的”零容忍“往往是很漂亮的口号。但它往往指的是”发现问题掩盖问题“。以前人们都说，不怕有问题，就怕看不见问题。而现在很多问题的出现并不是“黑天鹅””事件，而是”灰犀牛”事件。恰恰是对问题的选择性失明导致了不可挽回的结果。</p><p>在实践 DevOps 的时候，需要先测试一下有多少装睡的人。因为没有解决不了的问题，只有不愿承担的责任。</p><h4 id="分享-共担"><a href="#分享-共担" class="headerlink" title="分享/共担"></a>分享/共担</h4><p>Share 在英文里有两个意思，一个和别人分享，另一个是和别人共同承担。在 DevOps 的上下文里二者兼有，一方面是作为学习的结果的产出。另一方面是避免组织陷入不愿承担责任的文化。对于团队作战来说，一个人犯错，不是他一个人的责任，而是集体的责任。”当你用一个指头指着别人的同时，另外四个指头也指着自己。</p><p>我们要相信没有不良的人，只有不良的制度。当出现了问题，从制度上而不是从个人的角度分析问题出现的原因。而且要能总结原因，形成新的制度。如果一个问题不在制度上去避免，那么还会发成下一次。</p><h2 id="如果什么都是-DevOps-，那么-DevOps-实际上什么也不是"><a href="#如果什么都是-DevOps-，那么-DevOps-实际上什么也不是" class="headerlink" title="如果什么都是 DevOps ，那么 DevOps 实际上什么也不是"></a>如果什么都是 DevOps ，那么 DevOps 实际上什么也不是</h2><p>如果把所有 DevOps 相关的内容加总就能得到 DevOps，那和没有定义 DevOps 一样。如果我们没办法确定”什么不是 DevOps“，那同理我们也很难定义 DevOps 是什么。</p><p>我试图从上文中的认识里，提取出一些 DevOps 的必要元素来构成 DevOps 的概念。这些元素缺一不可，但单独拿出来又不能构成完整 DevOps 的概念。这样既可以保证对 DevOps 的完整理解，又避免 DevOps 概念过大难以下手。</p><p>根据我自己的实践，我认为 DevOps 包括以下几点原则：</p><ol><li>DevOps 有一个明确的目标：通过充分的合作解决由于责任模糊而相互推诿的问题。（没有 DevOps 痛点的团队自然也没有 DevOps 的动力）</li><li>DevOps 是一个团队属性而不是个人属性，这个团队需要处理开发和维护任务。（有单一任务都不算是 DevOps 团队，因为没有合作解决 DevOps 痛点的动机）</li><li>DevOps 是一种团队改进，对于团队的表现有明确目标和度量。（没有度量的改进就是耍流氓）</li><li>DevOps 是一种团队工作方式和文化，它包括了一系列促进 Dev 和 Ops 合作的具体技术和实践以达到上述目标。（ DevOps 也不是缺乏技术的理论空谈 ）</li></ol><p>因此，以下的描述都不是 DevOps：</p><ol><li>DevOps 不是一个职务或者角色，因为 DevOps 是团队属性。</li><li>不存在” DevOps 团队“，只存在”以 DevOps 方式工作的团队“。</li></ol><p>以上是我过去三年的 DevOps 实践和咨询经历，希望能给正在做 DevOps 的你一些参考和提示，并祝愿你在 DevOps 的实践过程中更加顺利。</p>]]></content>
      
      
      <categories>
          
          <category> Reprint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Networking </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当你在浏览器中输入“google.com”并回车，会发生什么？</title>
      <link href="posts/2019-01-25/what-happens-when-you-type-googlecom-into-your-browser-and-return/"/>
      <url>posts/2019-01-25/what-happens-when-you-type-googlecom-into-your-browser-and-return/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文： <a href="https://www.cnbeta.com/articles/tech/808191.htm" target="_blank" rel="noopener">https://www.cnbeta.com/articles/tech/808191.htm</a></p></blockquote><p>我遇到过的最喜欢的面试问题是：”你键入’google. com’到一个浏览器的地址栏中, 并点击<code>Enter</code>, 之后会发生什么呢？”</p><a id="more"></a><p>有人可以滔滔不绝几天, 试图以某种形式的完备性来回答此问题。他们会走多深？纯粹出于兴趣, 我要把我的答案罗列在此。当我在一次实际面试中被问到这个问题时, 在他们阻止我之前我漫谈了10分钟。之后即使在面试结束后，我一直记得当时我所遗漏的东西。</p><p>我将把这个格式化为文本墙, 因为在谈话中回答这个问题就是这样的感觉.</p><h2 id="那么发生了什么呢"><a href="#那么发生了什么呢" class="headerlink" title="那么发生了什么呢?"></a>那么发生了什么呢?</h2><p>浏览器将分析输入。通常情况下, 如果输入中有”. com”, 它不会认为你在输入搜索词。一旦它决定其必定是一个url时, 它会检查输入是否有协议头，如果没有, 它会在其开头添加”http://“。由于你没有指定一系列http协议功能, 因此它将假定使用默认值, 如端口80、GET方法和无基本身份认证。</p><p>然后, 它将创建一个http请求并发送该请求。我对我的底层网络知识没有信心, 但如果我确实要说, 我会说一些关于MAC地址, TCP数据包传输, 丢包处理等。但无论如何, 一个对”google. com”DNS的查找将会发生, 如果它还没有对此的缓存，DNS服务将应答一系列IP地址列表, 因为”google. com”不只单IP的。我认为在默认情况下浏览器会选择第一个。不确定它们是区域性的以及它是如何工作的, 但我知道它就在那里。</p><p>因此, http 请求从一个节点跳转到另一个节点, 直到它找到google. com负载均衡器的IP地址。这不会持续很久, 谷歌会回应说, 你需要使用https-假定是301永久重定向。因此, 它会原路返回到你的浏览器, 浏览器将协议更改为 https, 默认使用443端口并重新发送。这一次,TLS握手将在负载均衡器和浏览器客户端之间进行。我不是100%确定其工作原理, 但我知道该请求会告诉谷歌, 它支持什么协议 (TLS 1.0, 1.1, 1.2) ，然后谷歌将响应 “让我们使用1.2吧”。之后使用TLS加密发送请求。</p><p>我认为谷歌接下来要做的是将其放到负载均衡器上的网络应用程序防火墙规则集上, 看看它是否是一个恶意请求。当这通过之后, 安全连接可能已被终止 (因为PCI-DSS规则规定你不需要加密内部流量), 请求将被分配到其CDN中的某个池上, 而google端缓存主页将在http响应中返回。可能是预先压缩的。</p><p>谷歌的响应头将由浏览器读取，根据响应头的缓存策略进行缓存，然后正文将被解压缩。而且因为这是谷歌，它可能是超优化的：压缩，可能是许多预渲染内容、内联CSS、JavaScript和图像，以减少网络请求和首次渲染时间。但该请求将触发一系列其他请求，所有这些请求都是并发的，因为它应该运行HTTP/2。当这些请求正在进行时，JavaScript会被解析，可能没有阻塞，因为他们在标签上使用了defer属性 - 或者async，我从来没有单独阅读过这里他们做了些什么的资料。</p><p>但浏览器可能已经渲染了搜索框并且正在顶部的工具栏上工作，这将需要一些额外的网络请求 - 我可能已经有一个cookie或可能是带有OAuth令牌的本地存储 - 或我可能是使用Chrome并且它已经知道我是谁，并且使用auth的请求会被发送到他们的Google+ API上，告诉Google搜索页面的应用程序我的身份。</p><p>另一个请求将被发送, 以获取我的头像图像。在这一点上, 他们已经浏览器可嗅探的, 看看我是否未使用 chrome, 在这种情况下, 他们会有弹出一个工具栏提示, 告诉我：chrome 是真棒, 我应该使用它, 而不是其他任何浏览器。</p><p>我想此时需要冷静下来。所有这些都发生在一秒的时间内。</p><p>何为显著地不同?让我们看看对应的DNS:</p><p><img src="https://tobyqin.github.io/images/2019-01/116c69b7fb0b665.jpg" alt=""></p><p>我知道我以前见过google.com返回包中带有多个IP地址，但似乎不再是这种情况了。似乎他们之前常常使用轮巡策略，但现在不再使用了。 这个<a href="https://stackoverflow.com/questions/10257969/is-it-possible-that-one-domain-name-has-multiple-corresponding-ip-addresses" target="_blank" rel="noopener">StackOverflow</a>提问涉及了此情况。我已忘记了它被称为轮2。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>在一个正式结构化回答中，你可能会参考我有所了解但并不精通的OSI模型。在查阅资料之后，我将它视为如下的网络分层映射：</p><ol><li>应用 - 触发请求的逻辑</li><li>表示层 - HTTP</li><li>会话 - TLS</li><li>传输 - TCP</li><li>网络 - 路由 (IP)</li><li>数据链路 - 帧 (可看做数据包的容器)</li><li>物理层 - 比特流</li></ol><p>我记得在TLS中他们会在协议协商时交换证书。网络并不是我的强项。在我的浏览器中打开google.com，并禁用缓存：</p><p><img src="https://tobyqin.github.io/images/2019-01/d1eee285e02ff7b.jpg" alt=""></p><p>我记得主机名规范化——这是一个301。</p><p>从HTTP到HTTPS的校正是一个307内部重定向。</p><p>然后它下载字体、商标图像和我的头像图像。如果没有API调用，这意味着他们会在页面中推送我的个人资料信息并将其与返回数据捆绑在一起 - 因此当你点击google.com而不仅仅是提供缓存资产时，他们会进行实际的数据检索。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p><img src="https://tobyqin.github.io/images/2019-01/db31097ca290ccc.jpg" alt=""></p><p>以上是IE 11和Chrome响应数据的对比——所有都处于退出状态。</p><ul><li>IE11和Chrome之间没有太大的差别。但这意味着他们是用户代理嗅探服务器端而不是客户端。在我的答案中可能提到了这一点。</li><li>出乎意料的是，Chrome的响应体大了22kB。我想知道它是否是由在IE 11中明显缺席的语音搜索功能引起的。IE11可能需要polyfill和Chrome的广告，但它都被混淆了，我不会再进一步折磨自己了。</li><li>即使我在Chrome中清除了Cookie，它仍会在第一次请求时发送Cookie。它在IE 11中并没有这样做。</li></ul><h2 id="深入理解渲染"><a href="#深入理解渲染" class="headerlink" title="深入理解渲染!"></a>深入理解渲染!</h2><p><img src="https://tobyqin.github.io/images/2019-01/6e53d8e5af24b27.jpg" alt=""></p><p>上图是Chrome将为你提供的第一个屏幕截图。</p><ul><li>脚本标签中没有任何async或defer属性，只有nonce属性。我目前正在学习有关nonce的知识，这似乎与安全性有关。我估计他们想要那些阻塞式脚本。我确信他们在某些方面尝试过有/无aync/defer的情况，并决定反对之。</li><li>自我提示：完全响应是对JavaScript、CSS和HTML的乱七八糟的混合体。相比于其独立性，他们没有遵守任何控制其位置的规则。</li></ul><h2 id="问题本身是什么呢"><a href="#问题本身是什么呢" class="headerlink" title="问题本身是什么呢?"></a>问题本身是什么呢?</h2><p>你知道吗？ 对于人员而言，这可能不是一个很好的面试问题，因为答案涉及到如此多的网络知识。这是我喜欢的问题的格式，一些开放的事物，包括一些猜测。这使得面试官有机会跟进诸如“你认为TLS是如何建立的？”之类的问题，以查看候选人如何思考，看看他们有多少创意，看看他们的极限何在（有多耐心？）。</p><p>你最喜欢的面试问题是什么？</p>]]></content>
      
      
      <categories>
          
          <category> Reprint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年，再见</title>
      <link href="posts/2018-12-24/goodbye-my-2018/"/>
      <url>posts/2018-12-24/goodbye-my-2018/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tobyqin.github.io/images/2018-bye.jpg" alt="2018年"></p><p>去年的这个时候，我也想写一篇年底总结，无奈自己给自己找了各种理由借口，没写出来。</p><a id="more"></a><h1 id="懒"><a href="#懒" class="headerlink" title="懒"></a>懒</h1><p>今年从8月份就不爱动笔了，内心里一直有两个小恶魔，争论不休想要干架。一个说，一周7天你能蹦出8个想法，不写出来谁知道你他娘的是个天才？另外一个说，别老想着当网红，你那屁大的idea毛线都不是，写出来自己都懒得看。</p><p>其实内心并没什么小恶魔，只是因为懒。</p><h1 id="羞"><a href="#羞" class="headerlink" title="羞"></a>羞</h1><p>怎么说呢？博客这东西写的好的可以字字珠玑，让人读的醉生梦死，醍醐灌顶。写的不好的也可以记个流水账。写了就不要后悔，它可以锻炼你的大脑，提前防止老年痴呆。而且多年以后自己翻翻很大概率还能把自己弄的一把鼻涕一把泪（羞的）。</p><h1 id="戒"><a href="#戒" class="headerlink" title="戒"></a>戒</h1><p>2018年的社会已经是个相当浮躁的社会，每个人都说自己没时间，可是一刷手机能刷半天，碎片化的时间被各种应用塞满。</p><p>年初给自己订的读书目标（每月一本），一半都没完成，马上就2019了。翻开kindle看到都是自己喜欢的书名标题，但是还没找回上次阅读的线索时，手边的手机就亮了，拿起手机开始不亦乐乎地处理各种推送，仿佛整个世界都非常需要我，我好忙啊？？</p><p>还好，我读完了一本《受戒》，让我依稀感觉得到时光流逝，文字还是有感动人的魅力。</p><blockquote><p>在一起时，恩恩义义；分开时，潇潇洒洒。</p><p>她挎着一篮子荸荠回去了，在柔软的田埂上留了一串脚印。明海看着她的脚印，傻了。五个小小的趾头，脚掌平平的，脚跟细细的，脚弓部分缺了一块。明海身上有一种从来没有过的感觉，他觉得心里痒痒的。这一串美丽的脚印把小和尚的心搞乱了。</p><p>田彼南山， 荒秽不治， 种一顷豆， 落而为箕， 人生行乐耳， 须富贵何时。</p></blockquote><h1 id="点"><a href="#点" class="headerlink" title="点"></a>点</h1><p>2018年去了一趟南京，南京的老鸭粉丝汤真的是好吃，金陵是个风水宝地。</p><p>2018年游了一次西湖，西湖的春风拂面很是惬意，和大橙子来回在苏堤上走了三遍还恋恋不舍。</p><p>2018年回了一次老家，熟悉的鸡鸭叫声和虫鸣狗吠，让我感觉自己好像没出过远门。</p><p>2018年南方酷热的夏天和没有空调的房间也让我意识到，我来自农村，但已渐渐不习惯农村。</p><p>2018年大哥大嫂把侄子带到人间，父母的笑容因此增添了许多。</p><p>2018年父亲大人第一次上手术台，岁月会无情带走容颜和健康，不允许商量。</p><p>2018年给自己和大橙子办了健身卡。从第一次进健身房累到晕倒，到现在可以一口气跑6公里只经历了一个多月，我很感谢自己做的选择，流汗的感觉真好。</p><p>2018年已过而立，在上海看了几次房子，最终还是没有成为房奴。</p><p>2018年在Github提交了376次，相比去年的971次，着实少了许多。没有拿得出来说的项目，都是小猫小狗过家家。</p><p>2018年打了至少2000场农药，上过王者，然而有什么意义？终于弃坑，毁我青春。</p><p>2018年买了一个尤克里里，已经可以熟练弹唱小星星和生日快乐歌，从乐盲到明白了全全半全全全全半的含义，也知道了四大和弦原来这么厉害。</p><p>2018年花了一个月时间系统学习了移动端自动化测试的原理还提了方案，但最后老板说没时间给你折腾了，公司暂时不打算招人。</p><p>2018年我们公司也裁员了，我没有成为可以N+3的人，不知道是幸运还是不幸运。</p><p>2018年公司把我们带来澳门开年会，让我看见了什么叫纸醉金迷，什么叫一掷千金，什么叫有钱真好。</p><p>2018年混进各种测试群，原来大家都在努力用牛逼的技术解决多年以来一直都有的UI测试问题。在我看来，自动化测试真不应该测UI，但又不得不测。</p><p>2018年开始摸索着使用docker去部署自己的项目，不骗你说，真的很好用。</p><p>2018年用Vue去重构了几个项目，发现Vue真是个好东西，易学易用上手快，前端工程师也可以很快乐。</p><p>2018年走了Ract的walkthrough，发现它不太适合我，前端工程师要纠结的东西真多，还好我不是前端。</p><p>2018年写了第一个浏览器插件，第一个油猴脚本，感觉会JavaScript真的可以为所欲为。</p><p>2018年我想把后端的代码部署到本地，可是还是停留在想的阶段。</p><p>2018年在蚂蚁森林收了500个鸡蛋，种了2棵树，支付宝一直在怂恿我们使劲花钱。</p><p>2018年初买了两万的基金，年底亏了五千，今年市场到底发生了什么。我开了股票账号，但啥也不敢买。</p><p>2018年工资没怎么涨，但是5毛钱的硬币和纸币，已经开始花不出去了。</p><p>2018年越来越发现选择远比努力重要，但努力也远比不努力好的多。</p><p>2018年有很多伟大的人走了，但是还好身边的家人和朋友一个不少。</p><p>2018年和大橙子在一起刚好十年，昨天一起看了照片，没啥变化，真好。</p><p>2018年没有认识很多新面孔，也意味着不用告别很多老面孔。</p><p>2018年平平淡淡，但也真真实实。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Python 实现简单的 switch/case 语句</title>
      <link href="posts/2018-09-16/python-switch-case/"/>
      <url>posts/2018-09-16/python-switch-case/</url>
      
        <content type="html"><![CDATA[<p>在Python中是没有Switch / Case语句的，很多人认为这种语句不够优雅灵活，在Python中用字典来处理多条件匹配问题字典会更简单高效，对于有一定经验的Python玩家不得不承认，的确如此。</p><a id="more"></a><p>但今天我们还是来看看如果一定要用Python来Switch / Case，可以怎么玩。</p><h2 id="语法约束"><a href="#语法约束" class="headerlink" title="语法约束"></a>语法约束</h2><p>我们先定义一下Switch/Case应该怎么表达，为了简单我们可以让它长成这样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cn</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">us</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'us'</span>)</span><br><span class="line"></span><br><span class="line">switch(lang).case(<span class="string">'cn'</span>,cn)</span><br><span class="line">truetruetrue.case(<span class="string">'us'</span>,us)</span><br><span class="line">   .default(us)</span><br></pre></td></tr></table></figure><h2 id="类实现一"><a href="#类实现一" class="headerlink" title="类实现一"></a>类实现一</h2><p>通过以上约束，我们可以把switch当成一个类来实现，传入的参数在构造函数里处理，然后再分别实现case和default方法即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">switch</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, case_path)</span>:</span></span><br><span class="line">        self.switch_to = case_path</span><br><span class="line">        self._invoked = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">case</span><span class="params">(self, key, method)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.switch_to == key <span class="keyword">and</span> <span class="keyword">not</span> self._invoked:</span><br><span class="line">            self._invoked = <span class="literal">True</span></span><br><span class="line">            method()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, method)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._invoked:</span><br><span class="line">            self._invoked = <span class="literal">True</span></span><br><span class="line">            method()</span><br></pre></td></tr></table></figure><p>在构造函数中我们记住了<code>case_path</code> 和执行状态<code>_invoked</code>，在<code>case()</code>里如果当前的<code>key</code>和<code>switch_to</code>匹配并且函数没有被执行过，那么就更新<code>_invoked</code>并执行对应的方法。在<code>default()</code>里检查一下<code>_invoked</code>，如果从没执行过，那么就调用<code>default</code>分支的函数。</p><p>看上去还不错，我们来试用一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">switch(<span class="string">'cn'</span>).case(<span class="string">'cn'</span>,cn).case(<span class="string">'us'</span>,us).default(fail)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cn</span><br><span class="line">switch(<span class="string">'us'</span>).case(<span class="string">'cn'</span>,cn).case(<span class="string">'us'</span>,us).default(fail)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cn</span><br><span class="line">switch(<span class="string">'jp'</span>).case(<span class="string">'cn'</span>,cn).case(<span class="string">'us'</span>,us).default(fail)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fail</span><br><span class="line">switch(<span class="string">'cn'</span>).case(<span class="string">'cn'</span>,cn).case(<span class="string">'us'</span>,us)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cn</span><br></pre></td></tr></table></figure><p>让我们来看几个奇葩一点的case。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># duplicate case</span></span><br><span class="line">switch(<span class="string">'us'</span>).case(<span class="string">'us'</span>,cn).case(<span class="string">'us'</span>,us).default(fail)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cn</span><span class="params">()</span> <span class="title">return</span> '<span class="title">cn</span>'</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">us</span><span class="params">()</span> <span class="title">return</span> '<span class="title">us</span>'</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">return</span> <span class="title">value</span></span></span><br><span class="line">result = switch('cn').case('cn',cn).case('us',us)</span><br><span class="line">result</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;python_switch_case.switch object at <span class="number">0x11034fb70</span>&gt;</span><br></pre></td></tr></table></figure><p>发现了没有，上面的实现不会处理重复的case，当然你可以加强一下case方法，最好是抛出异常，其他编程语言通常都这样做。</p><p>第二个问题，你希望从case里拿到返回值，像上面的写法是没希望了，因为扔掉了。我们可以考虑在switch类里加一个result的变量来保存执行结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">switch</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, case_path)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">case</span><span class="params">(self, key, method)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        self.result = method()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在调用结束后，就可以通过<code>result</code>拿到结果了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_ = switch(<span class="string">'cn'</span>).case(<span class="string">'cn'</span>,cn).case(<span class="string">'us'</span>,us)</span><br><span class="line">_.result</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cn</span><br></pre></td></tr></table></figure><h2 id="类实现二"><a href="#类实现二" class="headerlink" title="类实现二"></a>类实现二</h2><p>我大概在网上搜了一下，你还可以参考<a href="http://code.activestate.com/recipes/410692/" target="_blank" rel="noopener">Brian Beck</a>通过类来实现Swich/Case。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">switch</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.fall = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the match method once, then stop"""</span></span><br><span class="line">        <span class="keyword">yield</span> self.match</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="string">"""Indicate whether or not to enter a case suite"""</span></span><br><span class="line">        <span class="keyword">if</span> self.fall <span class="keyword">or</span> <span class="keyword">not</span> args:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> self.value <span class="keyword">in</span> args:</span><br><span class="line">            self.fall = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = <span class="string">'z'</span></span><br><span class="line"><span class="keyword">for</span> case <span class="keyword">in</span> switch(c):</span><br><span class="line">    <span class="keyword">if</span> case(<span class="string">'a'</span>): <span class="keyword">pass</span>  <span class="comment"># only necessary if the rest of the suite is empty</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="string">'c'</span>): <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="string">'y'</span>): <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="string">'z'</span>):</span><br><span class="line">        print(<span class="string">"c is lowercase!"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="string">'A'</span>): <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">if</span> case(<span class="string">'Z'</span>):</span><br><span class="line">        print(<span class="string">"c is uppercase!"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case():  <span class="comment"># default</span></span><br><span class="line">        print(<span class="string">"I dunno what c was!"</span>)</span><br></pre></td></tr></table></figure><p>这种实现相对复杂一点，而且用起来也不是很舒服，又需要for又需要if（还不如直接if/else痛快）。当然也有好处，就是可以把相同结果的case放一起，而且case里可以写更多东西，不仅仅是一个方法名。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后我们还是回到Python推崇的方法来处理switch/case问题，一般我们可以通过字典来处理这种多分支的问题，举例说明。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MAPPING = &#123;</span><br><span class="line">    <span class="string">'cn'</span>: cn,</span><br><span class="line">    <span class="string">'us'</span>: us</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lang = <span class="string">'cn'</span></span><br><span class="line">result = MAPPING.get(lang, default=us)</span><br></pre></td></tr></table></figure><p>是不是一目了然，不仅易于阅读也易于维护。在字典中key是唯一的，value可以是任意类型的数据，可以是类或者是方法，所以足够灵活。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Quiz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Auto Update Your Pypi Package</title>
      <link href="posts/2018-07-29/pypi-package-auto-update/"/>
      <url>posts/2018-07-29/pypi-package-auto-update/</url>
      
        <content type="html"><![CDATA[<p>Sometimes we mgiht want to make our package update to latest version, let me show you how do I accomplish this.</p><a id="more"></a><h2 id="Determine-Versions"><a href="#Determine-Versions" class="headerlink" title="Determine Versions"></a>Determine Versions</h2><p>We have to determine current installed package version.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pkg_version</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="string">"""Get current version of a installed pip package."""</span></span><br><span class="line">    <span class="keyword">import</span> pkg_resources</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> pkg_resources.require(name)[<span class="number">0</span>].version</span><br><span class="line">    <span class="keyword">except</span> pkg_resources.DistributionNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>Then detemine latest published version, if this is an internal package, you have to implement a custom method like bellow.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_latest_version</span><span class="params">(name, server=<span class="string">'https://pypi.org'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    <span class="keyword">import</span> urllib.request, urllib.error</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = str(urllib.request.urlopen(<span class="string">'&#123;&#125;/simple/&#123;&#125;/'</span>.format(server, name)).read())</span><br><span class="line">        versions = re.findall(<span class="string">'([^-&lt;&gt;]+).tar.gz'</span>, content)</span><br><span class="line">        <span class="keyword">return</span> versions[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="Update-Methods"><a href="#Update-Methods" class="headerlink" title="Update Methods"></a>Update Methods</h2><p>We will use pip to update the package, here is the implementation.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_python_cmd</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Get current running python executable"""</span></span><br><span class="line">    <span class="keyword">return</span> sys.executable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_pkg</span><span class="params">(name, *args)</span>:</span></span><br><span class="line">    <span class="string">"""Update a pypi package with pip."""</span></span><br><span class="line"></span><br><span class="line">    arguments = [get_python_cmd(), <span class="string">'-m pip install -U'</span>, name]</span><br><span class="line">    arguments.extend(args)</span><br><span class="line">    cmd = <span class="string">' '</span>.join(arguments)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Update &#123;&#125;: \n&#123;&#125;\n'</span>.format(name, cmd))</span><br><span class="line">    os.system(cmd)</span><br></pre></td></tr></table></figure><p>The update method leaves <code>*args</code> is for internal package, you might want to parse in <code>--extra-index-url</code> and <code>--trust-host</code>.</p><h2 id="Combine-Together"><a href="#Combine-Together" class="headerlink" title="Combine Together"></a>Combine Together</h2><p>Finally, we implement the auto update method.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># auto_update.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utility <span class="keyword">import</span> get_pkg_version, get_latest_version, update_pkg</span><br><span class="line"></span><br><span class="line">NAME = <span class="string">'your_pkg_name'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_update</span><span class="params">(install=True)</span>:</span></span><br><span class="line">    <span class="string">"""Check update for the package."""</span></span><br><span class="line">    latest_version = get_latest_version(NAME)</span><br><span class="line">    installed_version = get_pkg_version(NAME)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> latest_version <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> install_version <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> latest_version != installed_version:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> install:</span><br><span class="line">            update_pkg(NAME)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'New version of &#123;&#125; is available, &#123;&#125;=&gt;&#123;&#125;.'</span>.</span><br><span class="line">                  format(NAME, installed_version, latest_version))</span><br></pre></td></tr></table></figure><p>Then, we place it in <code>__init__.py</code> in root of package, every time the package be imported, it will run the auto checker.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># your_pkg/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> auto_update <span class="keyword">import</span> check_update</span><br><span class="line"></span><br><span class="line">check_update()</span><br></pre></td></tr></table></figure><p>OK, we have done the auto update.</p><h2 id="Can-Be-Improved"><a href="#Can-Be-Improved" class="headerlink" title="Can Be Improved"></a>Can Be Improved</h2><p>In above example, we did not reload the module if there is an update, that depends on you. </p><p>Another thing can be improved is, we might not want to update the pacakge when there is an update, we just want to update it if there is a major / breaking update, the updator should be smarter.</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pypi </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将xmind文件转成可编程数据类型</title>
      <link href="posts/2018-07-01/parse-xmind-to-programmable-data-type/"/>
      <url>posts/2018-07-01/parse-xmind-to-programmable-data-type/</url>
      
        <content type="html"><![CDATA[<p>一个新的轮子。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近升级了一下<a href="https://github.com/tobyqin/xmind2testlink" target="_blank" rel="noopener">xmind2testlink</a>，顺带产生了一个中间轮子：<a href="https://github.com/tobyqin/xmindparser" target="_blank" rel="noopener">xmindparser</a>。</p><p><a href="https://www.xmind.cn/" target="_blank" rel="noopener">xmind</a>是知名的思维导图软件，可以用来整理思路，设计测试案例等等。一旦完稿后软件本身支持导出为图片，PDF，Excel等等文件格式。免费版相对于Pro版能导出的文件种类少一些，但有时候你可能想我做的xmind能不能通过编程再加工一下，比如集成到某个网页，或者通过api和某某系统集成。</p><p>那么<a href="https://github.com/tobyqin/xmindparser" target="_blank" rel="noopener">xmindparser</a>就是这么一个项目，了解一下。</p><h2 id="安装xmindparser"><a href="#安装xmindparser" class="headerlink" title="安装xmindparser"></a>安装xmindparser</h2><p>这个项目已经打包到PyPI，可以通过pip安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install xmindparser</span><br></pre></td></tr></table></figure><h2 id="Xmind-转Python-数据类型"><a href="#Xmind-转Python-数据类型" class="headerlink" title="Xmind 转Python 数据类型"></a>Xmind 转Python 数据类型</h2><p>xmindparser可以将xmind转成<code>dict</code>数据类型，比如下面这么一个xmind文件：</p><p><img src="https://tobyqin.github.io/images/xmind-example.png" alt="xmind example"></p><p>转换代码的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xmindparser <span class="keyword">import</span> xmind_to_dict</span><br><span class="line">out = xmind_to_dict(xmind_file)</span><br></pre></td></tr></table></figure><p>例子中<code>out</code>的数据结构如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Sheet 1"</span>,</span><br><span class="line">    <span class="attr">"topic"</span>: &#123;</span><br><span class="line">      <span class="attr">"makers"</span>: [</span><br><span class="line">        <span class="string">"star-orange"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"topics"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"link"</span>: <span class="string">"http://test.com"</span>,</span><br><span class="line">          <span class="attr">"topics"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"topics"</span>: [...]</span><br><span class="line">              <span class="string">"title"</span>: <span class="string">"e"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"test"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"structure"</span>: <span class="string">"org.xmind.ui.map.unbalanced"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"Sheet 2"</span>,</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>通过遍历sheet和topics就可以获取到xmind中每个节点的信息。</p><h2 id="Xmind-转-JSON"><a href="#Xmind-转-JSON" class="headerlink" title="Xmind 转 JSON"></a>Xmind 转 JSON</h2><p>转成JSON非常简单，如果你还是使用Python编程，可以这样写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xmindpraser <span class="keyword">import</span> xmind_to_json</span><br><span class="line">out_file = xmind_to_json(xmind_file)</span><br></pre></td></tr></table></figure><p>或者你直接调用命令行工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmindparser your.xmind -json</span><br></pre></td></tr></table></figure><h2 id="Xmind-转-XML"><a href="#Xmind-转-XML" class="headerlink" title="Xmind 转 XML"></a>Xmind 转 XML</h2><p>转成XML是类似的，使用Python编程，这样写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xmindpraser <span class="keyword">import</span> xmind_to_xml</span><br><span class="line">out_file = xmind_to_xml(xmind_file)</span><br></pre></td></tr></table></figure><p>或者你直接调用命令行工具：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmindparser your.xmind -xml</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>单个工具本身可能作用有限，但如果你能将各种工具融合起来，威力也许大很多。我们常说1+1，很多时候都是大于2的。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> xmind </tag>
            
            <tag> pypi </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS起步两三事</title>
      <link href="posts/2018-06-01/steps-to-start-nodejs-in-china/"/>
      <url>posts/2018-06-01/steps-to-start-nodejs-in-china/</url>
      
        <content type="html"><![CDATA[<p>主要是为了备忘，开始接触NodeJS有一段时间，断断续续，年纪也大了时间一长容易忘事情，汗。</p><a id="more"></a><h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><p>直接到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网下载</a>LTS版本安装即可，没必要追新功能用最新版。安装Node基本没什么坑，记得加到PATH就好。</p><p>Windows双击安装，macOS推荐使用brew安装，完成后在命令行里测试一下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br></pre></td></tr></table></figure><p>后期如果没有啥breaking的API改动基本也不用升级。</p><h2 id="必要的配置"><a href="#必要的配置" class="headerlink" title="必要的配置"></a>必要的配置</h2><p>NodeJS的包管理器<code>npm</code>，如果在墙内及有可能在使用过程中很不稳定，一般推荐使用国内的镜像源，目前最知名的也就是淘宝家的了。</p><blockquote><p> <a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p></blockquote><h3 id="npmrc"><a href="#npmrc" class="headerlink" title=".npmrc"></a>.npmrc</h3><p>你可以通过修改<code>~/.npmrc</code>来设置默认的包源:</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry</span>=https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>你也可以安装 <code>cnpm</code> 来代替 <code>npm</code> ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g</span><br></pre></td></tr></table></figure><p>之后的大部分<code>npm</code> 都可以直接用 <code>cnpm</code> 代替（发布相关的除外）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install &lt;package&gt;</span><br></pre></td></tr></table></figure><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><p>其实我还推荐你了解另外一种切换源的方式 <code>nrm</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmp install nrm -g</span><br></pre></td></tr></table></figure><p>使用方法如下，超级简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nrm ls</span><br><span class="line"></span><br><span class="line">* npm ---- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br><span class="line">  cnpm --- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br><span class="line">  taobao - https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line">  nj ----- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;</span><br><span class="line">  rednpm - http:&#x2F;&#x2F;registry.mirror.cqupt.edu.cn&#x2F;</span><br><span class="line">  npmMirror  https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;</span><br><span class="line">  edunpm - http:&#x2F;&#x2F;registry.enpmjs.org&#x2F;</span><br><span class="line">  </span><br><span class="line">$ nrm use taobao</span><br><span class="line"></span><br><span class="line">  Registry has been set to: https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure><p>使用 <code>nrm ls</code> 列出可以切换的源，然后<code>nrm use &lt;name&gt;</code> 瞬间切换，爽！</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>镜像源毕竟是copy的，同步状态有可能你不甚满意，最近taobao的源可能还有以下错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm ERR! registry error parsing json</span><br></pre></td></tr></table></figure><p>作为一个资深码农你也许有一个本地代理（SS懂？）让你无障碍访问国际互联网，那么你可以这么做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set proxy http:&#x2F;&#x2F;server:port</span><br><span class="line">npm config set https-proxy http:&#x2F;&#x2F;server:port</span><br></pre></td></tr></table></figure><p>配置好 <code>npm</code> 的代理后你又可以开心地玩耍了。</p><h2 id="Node入门须知"><a href="#Node入门须知" class="headerlink" title="Node入门须知"></a>Node入门须知</h2><p>三分钟入门NodeJS，如果你已经有其他语言的编程经验，是可以的。</p><p>NodeJS的核心可执行程序<code>node[.exe]</code>你可以简单理解成代码解释器，类似于Java的虚拟机，C#的.net Framework，Python里的<code>python[.exe]</code>，作用是把你的代码翻译成计算机行为。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node hello.js</span><br></pre></td></tr></table></figure><p>以上就是运行NodeJS代码的不二法则。</p><h3 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h3><p>很多知名框架都会提供所谓的脚手架命令，但是对于萌新玩家，我是不建议直接去使用脚手架的，这些脚手架做出来的目录结构对于萌新玩家来说是懵逼的，虽然有可能都是最佳实践的结果，但没有1，2，3步骤和手拉手，萌新也许直接退出游戏了。</p><p>新手真正的入门法则还是踏踏实实按照各种教程一步一步走，如果教程不好就换，没学会走路就想跑是不可能的。一般项目是这样开始的：</p><ol><li>明确项目需求（略）</li><li>创建项目目录</li><li>初始化项目信息</li><li>安装必要的依赖</li><li>模块划分，编码</li><li>系统集成，测试</li><li>项目发布，维护升级</li></ol><p>这个流程用NodeJS来实践大致是这样的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> create project </span></span><br><span class="line">mkdir [project-name]</span><br><span class="line">cd [project-name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> init project</span></span><br><span class="line">npm init</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install dependencies</span></span><br><span class="line">npm install &lt;package...&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install dev dependencies</span></span><br><span class="line">npm install &lt;package...&gt; -D</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> coding</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run and <span class="built_in">test</span></span></span><br><span class="line">npm run build</span><br><span class="line">npm run start</span><br><span class="line">npm run test</span><br><span class="line">npm run stop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> publish project</span></span><br><span class="line">npm publish .</span><br></pre></td></tr></table></figure><p>前面一节全都是在介绍<code>npm</code>，通过这个例子你应该明白它在NodeJS中的重要性了吧，所以让你的<code>npm</code>好用意义非凡。</p><p>例子中安装了两次依赖可能你有点困惑，可以这样理解，第一次依赖是项目运行时必要的依赖<code>--save-prod</code>，在发布时必须安装的；第二次依赖主要是用于开发或者测试的<code>--save-dev</code>，比如某些debug包或者test框架，方便开发才需要的包，在项目部署时没必要安装。其实还可能安装第三种依赖<code>--save-optional</code>，比如是用来做数据分析或者别的enhancement的，目前Node支持区分对待这三类依赖包。</p><h3 id="语法演示"><a href="#语法演示" class="headerlink" title="语法演示"></a>语法演示</h3><p>NodeJS里的JS就是JavaScript，属于动态语言，命名规则类似Java，但是语法更接近各种动态语言，比如Python或者Ruby。上手不难，了解一下标准库和数据基本类型，在IDE的加持下你就可以开始写代码了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js 项目的入口文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);  <span class="comment">// 导入标准库模块</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>); <span class="comment">// 导入已安装的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./hello'</span>);  <span class="comment">// 导入同目录下的模块</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./test'</span>; <span class="comment">// 导入模块的部分对象</span></span><br><span class="line"></span><br><span class="line">m.say(<span class="string">'yo..'</span>); <span class="comment">// 调用模块方法</span></span><br><span class="line">hello(<span class="string">'toby'</span>);</span><br><span class="line"></span><br><span class="line">fs.copyFileSync(src,dst) <span class="comment">// 调用标准库方法</span></span><br></pre></td></tr></table></figure><p>模块的编写范例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello world!'</span>; <span class="comment">// 模块的全局变量不会被导出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'say '</span> + word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello, '</span> + word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出就是对 module.exports 进行赋值</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    say: say,</span><br><span class="line">    hello: hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包管理小贴士"><a href="#包管理小贴士" class="headerlink" title="包管理小贴士"></a>包管理小贴士</h2><p>对于<code>npm</code>包的安装的位置我们来了解一下，简单来说就是这个包所作用的范围。如果安装包不带<code>-g</code>参数那么默认就是安装在当前目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &lt;package&gt;</span><br><span class="line"># &#x3D;&gt; will install to .&#x2F;node_modules</span><br></pre></td></tr></table></figure><p>这个包也就只有在当前目录（项目）里可用，这样方便做到环境隔离，不同项目可以用同样包的不同版本等等。</p><h3 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h3><p>如果安装过程中带了<code>-g</code>参数那么就意味这个包是全局（global）安装的，在系统的任何位置都是可用的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &lt;package&gt; -g</span><br><span class="line"># &#x3D;&gt; will install to &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules</span><br><span class="line"># &#x3D;&gt; or %AppData%\npm\node_modules</span><br></pre></td></tr></table></figure><p>一般的包安装都是不用带<code>-g</code>的，除了一些工具类的包，例如第一节介绍那些，这样系统干净一些，也可以避免全局包污染项目导致各种灵异事件。</p><h3 id="–depth"><a href="#–depth" class="headerlink" title="–depth"></a>–depth</h3><p>如果要查看安装了哪些global包可以用这个命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm list -g --depth&#x3D;0</span><br></pre></td></tr></table></figure><p>如果不加<code>--depth</code>，哎我去真没法看，也不知设计这个<code>list</code>的人为啥不默认带上这个参数，脑子被门夹了。为了方便你可以配上以下两个alias。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias ng&#x3D;&quot;npm list -g --depth&#x3D;0 2&gt;&#x2F;dev&#x2F;null&quot;</span><br><span class="line">alias nl&#x3D;&quot;npm list --depth&#x3D;0 2&gt;&#x2F;dev&#x2F;null&quot;</span><br></pre></td></tr></table></figure><h3 id="ncu"><a href="#ncu" class="headerlink" title="ncu"></a>ncu</h3><p>使用NodeJS就是要面对各种各样的包，有些包升级很勤快，你也想升级怎么办呢？哪些是outdated哪些不是，<code>npm</code>的升级命令真的很难用（记）哎。我推荐你了解一下<code>npm-check-updates</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install npm-check-updates -g</span><br></pre></td></tr></table></figure><p>这么好用的东西当然要全局安装啦，用法很简单，检查当前项目所有包的更新状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd my-project</span><br><span class="line">$ ncu</span><br><span class="line">Using &#x2F;Users&#x2F;tobyqin&#x2F;src&#x2F;blog&#x2F;package.json</span><br><span class="line">[..................] | :</span><br><span class="line">The following dependencies are satisfied by their declared version range, but the installed versions are behind. You can install the latest versions without modifying your package file by using npm update. If you want to update the dependencies in your package file anyway, run ncu -a.</span><br><span class="line"></span><br><span class="line"> hexo                   ^3.5.0  →  ^3.7.1</span><br><span class="line"> hexo-generator-search  ^2.1.1  →  ^2.2.5</span><br><span class="line"> hexo-server            ^0.3.1  →  ^0.3.2</span><br></pre></td></tr></table></figure><p>使用 <code>ncu -a</code>就可以一键更新项目里的所有包，当然它也提供了一些过滤参数，你可以<a href="https://www.npmjs.com/package/npm-check-updates" target="_blank" rel="noopener">查阅文档</a>。如果要看全局的包有没有可以更新的，试试<code>ncu -g</code>，非常方便。</p><p>有一点要注意，虽然命令是<code>ncu</code>但是包名不是，因为<code>ncu</code>的包名已经被一个天气预报的包占用了，无语。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在写NodeJS项目已经很容易了，JS经过了两三年的野蛮生长，诞生了成千上万个包（框架），其中不乏精品。</p><p>作为搬砖的码农，经过一顿<code>npm install</code>操作就可以做出一个不错的demo，你还犹豫什么，赶快上车吧！</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> mirror </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用浏览器的HEADLESS模式进行自动化测试</title>
      <link href="posts/2018-05-18/automation-tests-with-selenium-and-headless/"/>
      <url>posts/2018-05-18/automation-tests-with-selenium-and-headless/</url>
      
        <content type="html"><![CDATA[<p>自动化测试的进阶内容。</p><a id="more"></a><h2 id="了解HEADLESS模式"><a href="#了解HEADLESS模式" class="headerlink" title="了解HEADLESS模式"></a>了解HEADLESS模式</h2><p>HEADLESS BROWSER 指的是不需要用户界面的浏览器，这种浏览器在自动化测试和爬虫领域有着广泛的应用。</p><p>例如你想在网页上运行一些测试，从网页抓取信息，检查浏览器访问某些资源的状态，定时截取网页等等，你需要的是浏览器处理网页但不一定需要浏览器界面，这些情况都是HEADLESS BROWSER的应用场景。</p><p>Chrome 从 59.0 开始支持HEADLESS模式（2017年5月），Firefox从 55.0 开始也支持了HEADLESS模式（2017年9月）。也就是在今年2018年的4月份，老牌的无头浏览器 <a href="http://phantomjs.org/" target="_blank" rel="noopener">PhantomJS</a> 的核心开发者宣布不再维护该项目，因为Chrome 和Firefox的HEADLESS模式已经足够好并可以替代PhantomJS。</p><h2 id="实践-Selenium-HEADLESS"><a href="#实践-Selenium-HEADLESS" class="headerlink" title="实践 Selenium + HEADLESS"></a>实践 Selenium + HEADLESS</h2><p>使用浏览器的HEADLESS模式进行自动化测试，你需要先满足以下前提：</p><ul><li>Python + Selenium 运行环境</li><li>Chrome 59+ 或者 Firefox 55+</li><li>ChromeDriver 或者 GeckoDriver 最新版已加入PATH</li></ul><p>万事俱备，废话不多说我们直接上演示代码。</p><h3 id="Chrome版实例"><a href="#Chrome版实例" class="headerlink" title="Chrome版实例"></a>Chrome版实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">options = Options()</span><br><span class="line">options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">options.add_argument(<span class="string">'--disable-gpu'</span>) <span class="comment"># 允许在无GPU的环境下运行，可选</span></span><br><span class="line">options.add_argument(<span class="string">'--window-size=1920x1080'</span>) <span class="comment"># 建议设置</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(chrome_options=options)</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">browser.find_element_by_id(<span class="string">'kw'</span>).send_keys(<span class="string">'HELLO'</span>)</span><br><span class="line">browser.find_element_by_id(<span class="string">'su'</span>).click()</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>) <span class="comment"># 简单粗暴的等待，实际项目中勿用</span></span><br><span class="line"><span class="keyword">assert</span> browser.title == <span class="string">u'HELLO_百度搜索'</span></span><br><span class="line">browser.save_screenshot(<span class="string">'chrome-headless-test.png'</span>)</span><br></pre></td></tr></table></figure><h3 id="Firefox版实例"><a href="#Firefox版实例" class="headerlink" title="Firefox版实例"></a>Firefox版实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from time import sleep</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.firefox.options import Options</span><br><span class="line"></span><br><span class="line">options &#x3D; Options()</span><br><span class="line">options.add_argument(&#39;--headless&#39;)</span><br><span class="line"># options.add_argument(&#39;--window-size&#x3D;1920x1080&#39;) # Firefox无效</span><br><span class="line"></span><br><span class="line">browser &#x3D; webdriver.Firefox(firefox_options&#x3D;options)</span><br><span class="line">browser.set_window_size(1280, 1024) # 启动后设置浏览器大小，但是高度会随着访问的网页变化</span><br><span class="line"></span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br><span class="line">browser.find_element_by_id(&#39;kw&#39;).send_keys(&#39;HELLO&#39;)</span><br><span class="line">browser.find_element_by_id(&#39;su&#39;).click()</span><br><span class="line"></span><br><span class="line">sleep(1)</span><br><span class="line">assert browser.title &#x3D;&#x3D; u&#39;HELLO_百度搜索&#39;</span><br><span class="line">browser.save_screenshot(&#39;firefox-headless-test.png&#39;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器HEADLESS模式可以让程序运行的环境更贴近用户访问的真实环境，相对于模拟UserAgent等方式得出的数据也会更加准确可靠。</p><p>尤其在自动化测试领域，HEADLESS也有取代传统的带界面的自动化测试的趋势，有一些公司已经<a href="https://about.gitlab.com/2017/12/19/moving-to-headless-chrome/" target="_blank" rel="noopener">将实践投入生产</a>中。我们可以在调试自动化测试时使用用户界面，当部署到持续集成环境中是启用HEADLESS，并开启多线程使用并行的方式来运行测试案例，这样效率会大大提高，而且因为界面被干扰而导致测试失败的概率也会降低。</p><p>总的来说，至少在端对端的自动化测试中，HEADLESS模式没有明显的缺点，甚至可以成为网页自动化测试进化的下一个目标。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://developer.mozilla.org/en-US/Firefox/Headless_mode" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/Firefox/Headless_mode</a></li><li><a href="https://intoli.com/blog/running-selenium-with-headless-firefox/" target="_blank" rel="noopener">https://intoli.com/blog/running-selenium-with-headless-firefox/</a></li><li><a href="https://developers.google.com/web/updates/2017/04/headless-chrome" target="_blank" rel="noopener">https://developers.google.com/web/updates/2017/04/headless-chrome</a></li><li><a href="https://about.gitlab.com/2017/12/19/moving-to-headless-chrome/" target="_blank" rel="noopener">https://about.gitlab.com/2017/12/19/moving-to-headless-chrome/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> selenium </tag>
            
            <tag> headless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentry - 处理异常日志的正确姿势</title>
      <link href="posts/2018-05-11/collect-error-events-via-sentry/"/>
      <url>posts/2018-05-11/collect-error-events-via-sentry/</url>
      
        <content type="html"><![CDATA[<p>在各种系统和应用里，无论你的代码再完美也还是会抛异常，出错误。今天的主角是当今比较流行的异常记录框架 - Sentry，来了解一下。</p><a id="more"></a><h2 id="关于日志管理"><a href="#关于日志管理" class="headerlink" title="关于日志管理"></a>关于日志管理</h2><p>应用越做越复杂，输出日志五花八门，有print的，有写stdout的，有写stderr的, 有写logging的，也有自定义xxx.log的。那么这将导致平台应用日志分布在各个地方，无法统一管理。而且可能用的还不止一种开发语言，想规范和统一日志不是一件容易的事。</p><h2 id="为什么使用Sentry"><a href="#为什么使用Sentry" class="headerlink" title="为什么使用Sentry"></a>为什么使用Sentry</h2><p>Sentry是一个集中式日志管理系统。它具备以下优点：</p><ul><li>多项目，多用户</li><li>界面友好</li><li>可以配置异常出发规则，例如发送邮件</li><li>支持主流语言接口</li></ul><p>从Sentry的文档首页截下来的一张图，可以看到它支持目前主流的编程语言。</p><p><img src="https://tobyqin.github.io/images/sentry-supported-platform.png" alt="sentry-supported-platform"></p><h2 id="安装和快速上手"><a href="#安装和快速上手" class="headerlink" title="安装和快速上手"></a>安装和快速上手</h2><p>Sentry支持部署到本地服务器，具体可以参考以下文档：</p><ul><li><a href="https://docs.sentry.io/server/installation/" target="_blank" rel="noopener">https://docs.sentry.io/server/installation/</a></li></ul><p>但作为大多数个人开发者和中小企业，我更建议使用Sentry官网（<a href="https://sentry.io/）提供的云服务，你只需要注册一个Sentry账号，就可以快速享受到集中处理异常日志的服务。" target="_blank" rel="noopener">https://sentry.io/）提供的云服务，你只需要注册一个Sentry账号，就可以快速享受到集中处理异常日志的服务。</a></p><p>Sentry免费版可以：</p><ul><li>每月10k 错误日志上限</li><li>支持所有平台和语言，功能无缩水</li><li>无限项目数量，仅单用户访问，不提供团队功能</li></ul><p>具体的价格表可以看这里：</p><ul><li><a href="https://sentry.io/pricing/" target="_blank" rel="noopener">https://sentry.io/pricing/</a></li></ul><h2 id="开始配置DSN"><a href="#开始配置DSN" class="headerlink" title="开始配置DSN"></a>开始配置DSN</h2><p>你可以认为 DSN（Data Source Name）是Sentry 管理项目需要的<code>PROJECT_ID</code>，每个应用都需要对应一个 <code>PROJECT_ID</code>，以及用于身份认证的 <code>PUBLIC_KEY</code> 和 <code>SECRET_KEY</code>。由此组成一个这样的 DSN：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;PROTOCOL&#125;:&#x2F;&#x2F;&#123;PUBLIC_KEY&#125;:&#123;SECRET_KEY&#125;@&#123;HOST&#125;&#x2F;&#123;PATH&#125;&#123;PROJECT_ID&#125;</span><br></pre></td></tr></table></figure><p>PROTOCOL 通常会是 <code>http</code> 或者 <code>https</code>，HOST 为 Sentry 服务的主机名和端口，PATH 通常为空。</p><p>在你登入Sentry后台之后，你可以新建一个项目，之后就可以得到类似于下面这样一个DSN。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;e055040d5@sentry.io&#x2F;12345</span><br></pre></td></tr></table></figure><p>有了DSN以后，你就可以在客户端中将错误日志上传到Sentry了。</p><h2 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h2><p>这里我主要以Python为例，其他编程语言的客户端配置可以参考官网文档，步骤大同小异。</p><ul><li><a href="https://docs.sentry.io/quickstart/" target="_blank" rel="noopener">https://docs.sentry.io/quickstart/</a></li></ul><p>首先通过pip安装Sentry SDK。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install raven --upgrade</span><br></pre></td></tr></table></figure><p>然后初始化客户端。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> raven <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">DSN = <span class="string">'https://****@sentry.io/****'</span></span><br><span class="line">client = Client(DSN)</span><br></pre></td></tr></table></figure><p>最后，在你需要记录异常的代码为止调用<code>client.captureException()</code>即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    client.captureException()</span><br></pre></td></tr></table></figure><p>很多时候我们的异常信息应该包含更多的上下文信息，这样对于我们做后续分析会有更多帮助，那么你可以在Sentry捕获异常前加入这些上下文。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    processing(user, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    client.user_context(&#123;</span><br><span class="line">        <span class="string">'user'</span>: user.email,</span><br><span class="line">        <span class="string">'data'</span>: json.dumps(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    client.captureException()</span><br></pre></td></tr></table></figure><h3 id="一些经验之谈"><a href="#一些经验之谈" class="headerlink" title="一些经验之谈"></a>一些经验之谈</h3><p>当然，我们不可能在每处可能发生异常的代码为止都调用Sentry，也不可能去修补过去的代码将Sentry一一植入，一个好的建议是，无论何时，你的程序都有统一的异常处理机制，最好是全局的。这样的话，你只要将Sentry写在全局的异常处理器即可。</p><p>另外Sentry还对流行的开发框架提供了特别的支持，比如Flask，Django等等，在这些应用中你只要配置就行，不需要你去写什么全局的异常处理（虽然写起来也不难）。</p><p>Flask的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sentry = Sentry(dsn=<span class="string">'http://public_key:secret_key@example.com/1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">()</span>:</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    sentry.init_app(app)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure><p>Django的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> raven</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'raven.contrib.django.raven_compat'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">RAVEN_CONFIG = &#123;</span><br><span class="line">    <span class="string">'dsn'</span>: <span class="string">'http://public_key:secret_key@example.com/1'</span>,</span><br><span class="line">    <span class="comment"># If you are using git, you can also automatically </span></span><br><span class="line">    <span class="comment"># configure the release based on the git info.</span></span><br><span class="line">    <span class="string">'release'</span>: raven.fetch_git_sha(os.path.abspath(os.pardir)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常报告和提醒"><a href="#异常报告和提醒" class="headerlink" title="异常报告和提醒"></a>异常报告和提醒</h2><p>一旦你完成上面的配置，以后系统发生的所有错误异常都会被自动记录到Sentry，查看报告就是一件轻松愉快的事情了。</p><p>默认情况下，一旦异常发生，5分钟内就会有一封邮件送到你邮箱，包含了异常信息的大致描述。</p><p><img src="https://tobyqin.github.io/images/sentry-email-alert.png" alt="sentry-email-alert"></p><p>当然你还可以将异常报警集成到更多系统中，比如HICHAT，SLACK，IRC，WEBHOOKS，在Sentry后台提供了相应的入口。</p><p>在Sentry的项目 Dashboard 你可以浏览到更详细的报告，比如按照异常信息的类别进行分类和过滤，也可以统计近期异常的状态和频率，非常方便。</p><p><img src="https://tobyqin.github.io/images/sentry-dashboard.png" alt="sentry-dashboard"></p><p>Sentry还提供了异常信息的聚合，同样的错误有可能在多处抛出，传统的日志统计起来就不是很方便，在Sentry一目了然。</p><p>另外你还可以针对异常问题进行分配和跟踪，例如指派团队的某个成员去处理某一类问题，对于长时间没有再发生的问题自动标记为解决等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Sentry 还有有很多亮点，比如敏感信息过滤， release 版本跟踪，关键字查找，受影响用户统计，权限管理等。Sentry 的 plugin 模块还可以集成大量的第三方工具如： SLACK ， JIRA 。</p><p>对我们来说最大的便利就是利用日志进行错误发现和排查的效率变高了。但是，我们能不能完全依赖Senry呢？有几点值得探讨：</p><h3 id="不是日志的替代品"><a href="#不是日志的替代品" class="headerlink" title="不是日志的替代品"></a>不是日志的替代品</h3><p>Sentry 的目的是为了让我们专注于系统与程序的异常信息，目的是提高排查问题的效率，日志事件的量到达一个限制时甚至丢弃一些内容。官方也提倡正确设置 Sentry 接收的日志 level 的同时，用户也能继续旧的日志备份。</p><h3 id="不是排查错误的万能工具"><a href="#不是排查错误的万能工具" class="headerlink" title="不是排查错误的万能工具"></a>不是排查错误的万能工具</h3><p>Sentry 是带有一定策略的问题分析工具，以样本的形式展示部分原始日志的信息。信息不全面的同时，使用过程中也可能出现 Sentry 聚合所带来的负面影响，特别是日志记录质量不够的情况下。</p><h3 id="不是传统监控的替代品"><a href="#不是传统监控的替代品" class="headerlink" title="不是传统监控的替代品"></a>不是传统监控的替代品</h3><p>与传统的监控系统相比，Sentry 更依赖于发出的日志报告，而另外一些隐藏的逻辑问题或者业务问题很可能是不会得到反馈的。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.sentry.io/quickstart/" target="_blank" rel="noopener">https://docs.sentry.io/quickstart/</a></li><li><a href="https://blog.csdn.net/bigsec/article/details/54091109" target="_blank" rel="noopener">https://blog.csdn.net/bigsec/article/details/54091109</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> logging </tag>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说Python中的单元测试</title>
      <link href="posts/2018-04-08/unit-test-with-python/"/>
      <url>posts/2018-04-08/unit-test-with-python/</url>
      
        <content type="html"><![CDATA[<p>单元测试是每种编程语言必学的课题，是保护开发者的强力护盾，每个程序员都在时间允许的情况下尽可能多的写单元测试，今天我们不讨论其必要性，只抛砖引玉聊一聊Python中的单元测试，本文仅代表个人看法。</p><a id="more"></a><h2 id="标准库中难以忍受的-unittest"><a href="#标准库中难以忍受的-unittest" class="headerlink" title="标准库中难以忍受的 unittest"></a>标准库中难以忍受的 unittest</h2><p>很多时候我们总是认为标准库里的带的总是精挑细选的，如果不经过仔细打磨怎么可能入选为一等公民？但我要告诉你，Python标准库里的单元测试框架真不是最好的，随着你对Python的熟悉你甚至会讨厌这个unittest。</p><p>Python一直崇尚简单，优雅，高效地完成事情，当你写完一个函数需要测试一下时，使用标准库的unittest你需要做这些事情：</p><ul><li>新建单元测试脚本</li><li>导入单元测试依赖</li><li><strong>继承单元测试类</strong></li><li>实现单元测试方法</li></ul><p>具体的实例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerArithmeticTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testAdd</span><span class="params">(self)</span>:</span>  <span class="comment"># test method names begin with 'test'</span></span><br><span class="line">        self.assertEqual((<span class="number">1</span> + <span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line">        self.assertEqual(<span class="number">0</span> + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>看上去还行，不是很难。但是渐渐地你会吐槽：</p><ul><li>为啥我要新建一个文件来写测试？</li><li>为啥我要继承一个类来写测试？</li><li>为啥我要用unittest的Assertion来做断言？</li><li>为啥unitunit的命名规则跟最佳实践不一样（<code>mixedCase</code> vs <code>lower_case</code>）？</li></ul><p>要回答以上问题，答案只有一个：<a href="https://www.quora.com/Will-Pythons-unittest-module-become-pythonic-anytime-soon" target="_blank" rel="noopener">历史原因</a>。</p><p>很久很久以前，Python从Java借鉴了单元测试框架，包括命名规则和实现方式，一直沿用至今。不得不说这个框架没啥毛病，该有的功能的都有，想做的事都可以做，但是用起来总是没有爽的感觉。</p><p>但是为啥伟大的社区力量为啥不把这个框架改的爽一点呢？没办法，我估计是为了世界和平，你要知道Python这个庞然大物能健康地活着，后面有无数的类库和方法在支撑，而这些类库和方法都被单元测试保护着，如果修改了单元测试框架导致兼容性问题，就成了千古罪人。</p><h2 id="见识简洁的单元测试-pytest"><a href="#见识简洁的单元测试-pytest" class="headerlink" title="见识简洁的单元测试 pytest"></a>见识简洁的单元测试 pytest</h2><p>Python中很多大牛其实都有严重的强迫症，追求简洁和优雅的代码。必然的，他们会抛弃标准库中的unittest，使用或者发明自己心仪的单元测试框架。</p><p>正如其名，pytest是一个无数人推荐并在使用的Python单元测试框架，它使用起来非常简单，只要你的方法名以 <code>test</code> 开头就可以，你可以和需要测试的方法放在一起，亦或是新建一个文件来专门整理单元测试，都可以。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">your_func</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_your_func</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">assert</span> result</span><br></pre></td></tr></table></figure><p>这样的设计，就让你写单元测试成了顺手拈来的事，假如你写完了一个方法，想看看是否工作，在旁边直接写上一个<code>test</code> 开头的方法，稍微准备一下数据就可以验证这个方法好不好用，岂不妙哉？</p><blockquote><p>The idioms that pytest first introduced brought a change in the Python community because they made it possible for test suites to be written in a very compact style, or at least far more compact than was ever possible before. Pytest basically introduced the concept that Python tests should be plain Python functions instead of forcing developers to include their tests inside large test classes.</p></blockquote><p>pytest 的发明让大家意识到单元测试原来可以这么轻松和随意，完全没有必要去继承一个所谓的测试类或者按照复杂的规则才能开始书写测试代码，这也是我选择和推荐它的理由。</p><p>当然，如果原来你的单元测试时unittest写的话，pytest其实也是<a href="https://docs.pytest.org/en/latest/unittest.html" target="_blank" rel="noopener">有可能兼容的</a>的。</p><p>pytest 能够识别 <code>unittest.TestCase</code> 子类中的测试方法，如果文件名符合 <code>test_*.py</code> 或者 <code>*_test.py</code> 这样的规则。</p><p>并且大多数 <code>unittest</code> 的功能都是被支持的，例如：</p><ul><li><code>@unittest.skip</code> 装饰器;</li><li><code>setUp/tearDown</code>;</li><li><code>setUpClass/tearDownClass()</code>;</li></ul><p>我觉得，pytest有以下优点：</p><ul><li>上手和使用足够简单 </li><li>当case失败时信息足够丰富和直观，比如最后导致失败的变量值会打印出来</li><li>更丰富的运行参数</li><li>可以使用 <code>assert</code> 而不是 <code>self.assert*</code> </li><li>被广大IDE支持，社区资源丰富，用户群体大</li></ul><h2 id="让单元测试和IDE无缝集成"><a href="#让单元测试和IDE无缝集成" class="headerlink" title="让单元测试和IDE无缝集成"></a>让单元测试和IDE无缝集成</h2><p>毕竟我们大多数人都不是神，不能用记事本写代码，IDE才是我们正确搬砖的方式。Python的首选IDE毋庸置疑就是 JetBrain 公司出品的 <a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">PyCharm</a>。</p><p>在PyCharm中只要你将默认的单元测试驱动改成pytest，就可以在任意<code>test</code>开头的方法上通过右键菜单运行或者调试这个测试案例，非常方便。</p><p><img src="https://tobyqin.github.io/images/pytest-pycharm-settings.png" alt="更改PyCharm设置"></p><p><img src="https://tobyqin.github.io/images/pytest-context-run.png" alt="右键菜单运行或者调试"></p><p>如果你要运行当前文件的所有测试，只要从非<code>test</code>方法的其他区域点击右键即可。或者修改任意已经运行过的Configuration，添加你想要的参数，比如最多运行挂3个case就终止测试等等。</p><p><img src="https://tobyqin.github.io/images/pytest-configuration.png" alt="自定义Run Configuration"></p><h2 id="闲话和总结"><a href="#闲话和总结" class="headerlink" title="闲话和总结"></a>闲话和总结</h2><p>单元测试的重要性大家都知道，大名鼎鼎的TDD应该都听过，但是真正在实践的少之又少。</p><p>究其原因，一些人会说时间写代码都不够，哪还有空写单元测试。还有一些人就是嫌麻烦，在绝大多数编程语言里单元测试都是需要单独建立工程和目录的，写单元测试需要很多基础工作要做，本以为顺手就可以写的单元测试，实际上需要费九牛二虎之力还是在搭架子，太沮丧了。</p><p>Python的动态特性和灵活性让它有可能让单元测试超级简单，有可能你认为单元测试还是不要和业务代码混合在一起的好，那就多辛苦一点新建一个文件导入要测试的方法，写一个 <code>test</code> 开头的方法即可，不算太难，不要找推辞的理由。</p><p>最后我的个人观点，单元测试其实还有一个非常重要的作用，就是替代函数文档注释。比如你写了一个函数，使用起来可能有那么一点复杂，你可以给它写一份清晰的注释文档，但是千言万语不如给我来个例子，单元测试可以充当例子的角色，什么样的输入，输出结果如何，一目了然。</p><p>希望从今天起，你的代码也都有单元测试。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> unittest </tag>
            
            <tag> pytest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 查找重复文件升级版 - photodup</title>
      <link href="posts/2018-04-01/find-duplicate-photos-by-photodup/"/>
      <url>posts/2018-04-01/find-duplicate-photos-by-photodup/</url>
      
        <content type="html"><![CDATA[<p>之前写了一个简化版的<a href="/posts/2018-03-22/find-duplicate-files-by-python/">使用Python查找目录中的重复文件</a>，现在升级了一下，我们来提供一个友好的网页界面。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>上一个版本我们非常简单粗暴地将所有文件的hash扫描后保存到一个字典中，字典结构大概是这样的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">files = [&#123;<span class="string">'hash1'</span>:[<span class="string">'file/path...'</span>,<span class="string">'file/path...'</span>]&#125;,</span><br><span class="line">         &#123;<span class="string">'hash2'</span>:[<span class="string">'file/path...'</span>,<span class="string">'file/path...'</span>,<span class="string">'file/path...'</span>]&#125;,</span><br><span class="line">         &#123;<span class="string">'hash3'</span>:[<span class="string">'file/path...'</span>]&#125;]</span><br></pre></td></tr></table></figure><p>然后通过一个循环找出hash值对应的数组长度大于1的数组，现在我们把这个扫描结果保存到数据库中，之后只要查询数据库即可找到重复的文件。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>我们大致需要几个步骤就可以让程序跑起来：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tobyqin/photodup.git # 克隆代码</span><br><span class="line"></span><br><span class="line">cd photodup</span><br><span class="line">pip install -r requirements.txt # 安装必要的依赖包</span><br><span class="line"></span><br><span class="line">python db.py # 创建DB表结构</span><br></pre></td></tr></table></figure><p>表结构不需要太复杂：</p><table><thead><tr><th>id</th><th>hash</th><th>name</th><th>path</th><th>Existed</th></tr></thead><tbody><tr><td>1</td><td>ab3d</td><td>DCS_001.JPG</td><td>path/to/DSC_001.JPG</td><td>1</td></tr><tr><td>2</td><td>1d2c</td><td>DCS_002.JPG</td><td>path/to/DSC_002.JPG</td><td>2</td></tr></tbody></table><p>然后开始扫描你要检查的目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python scan.py dir1 dir2</span><br></pre></td></tr></table></figure><p>你可以传入一个或者多个目录，默认只检索jpg文件，也可以修改<code>config.py</code>里的配置项来自定义。扫描结束后，启动web服务即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python web.py</span><br></pre></td></tr></table></figure><p>顺利的话用浏览器打开 <a href="http://127.0.0.1:5001/" target="_blank" rel="noopener">http://127.0.0.1:5001</a> 就可以看到一个友好的网页，可以通过文件hash或者文件名来清理重复文件，可以预览图片文件。</p><p><img src="https://tobyqin.github.io/images/dup_by_hash.png" alt="dup_by_hash"></p><p><img src="https://tobyqin.github.io/images/dup_by_name.png" alt="dup_by_name"></p><h2 id="原理-amp-总结"><a href="#原理-amp-总结" class="headerlink" title="原理&amp;总结"></a>原理&amp;总结</h2><p>升级后的重复文件清理工具总共也不过两三百行代码，但是已经算是一个比较完整的程序，使用起来也方便了很多。升级过程中用到了前后端数据库各方面的知识，不管你的想法多简单，真正动手去实现才会有收获。</p><blockquote><p>项目地址：<a href="https://github.com/tobyqin/photodup" target="_blank" rel="noopener">https://github.com/tobyqin/photodup</a></p><p>技术栈：Python, SQL, Flask, Bootstrap, Jquery, CSS.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python查找目录中的重复文件</title>
      <link href="posts/2018-03-22/find-duplicate-files-by-python/"/>
      <url>posts/2018-03-22/find-duplicate-files-by-python/</url>
      
        <content type="html"><![CDATA[<p>是这样的，电脑上的堆积的照片有点多，而且重复的照片被放在了不同的目录，占用的空间越来越大，数量也多得已经不太适合人工分辨整理，写个Python脚本来处理吧。</p><a id="more"></a><h2 id="文件的唯一标识-MD5"><a href="#文件的唯一标识-MD5" class="headerlink" title="文件的唯一标识 - MD5"></a>文件的唯一标识 - MD5</h2><p>假如你要处理的重复文件有不同的文件名，最简单的办法就是通过MD5来确定两个文件是不是一样的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5sum</span><span class="params">(filename, blocksize=<span class="number">65536</span>)</span>:</span></span><br><span class="line">    hash = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: f.read(blocksize), <span class="string">b""</span>):</span><br><span class="line">            hash.update(block)</span><br><span class="line">    <span class="keyword">return</span> hash.hexdigest()</span><br></pre></td></tr></table></figure><p>这个方法可以快速获得一个文件的MD5值，<code>blocksize</code> 可以根据文件大小和CPU性能调整，一般选择的值约等于文件的平均大小。</p><h2 id="保存所有文件标识和路径"><a href="#保存所有文件标识和路径" class="headerlink" title="保存所有文件标识和路径"></a>保存所有文件标识和路径</h2><p>接下来遍历所有文件，使用MD5作为key，路径作为value，保存起来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dup = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_hash_dict</span><span class="params">(dir_path, pattern=<span class="string">'*.jpg'</span>)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(file)</span>:</span></span><br><span class="line">        hash = md5sum(file)</span><br><span class="line">        <span class="keyword">if</span> hash <span class="keyword">not</span> <span class="keyword">in</span> dup.keys():</span><br><span class="line">            dup[hash] = [file]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dup[hash].append(file)</span><br><span class="line"></span><br><span class="line">    p = Path(dir_path)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> p.glob(<span class="string">'**/'</span> + pattern):</span><br><span class="line">        save(str(item))</span><br></pre></td></tr></table></figure><h2 id="处理重复文件"><a href="#处理重复文件" class="headerlink" title="处理重复文件"></a>处理重复文件</h2><p>最后一步非常简单，把上一步建立的字典做一个简单的过滤就能找到重复文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_duplicate</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> dup.items() <span class="keyword">if</span> len(v) &gt; <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> hash, files <span class="keyword">in</span> get_duplicate().items():</span><br><span class="line">    print(<span class="string">"&#123;&#125;: &#123;&#125;"</span>.format(hash, files))</span><br></pre></td></tr></table></figure><p>接下来你可以根据自己的需要删除或者保留某个路径下的文件，本文到此为止。</p><blockquote><p> 完整的脚本代码： <a href="https://gist.github.com/tobyqin/9299d27bdb429ffaa7713ed760a44fbb" target="_blank" rel="noopener">https://gist.github.com/tobyqin/9299d27bdb429ffaa7713ed760a44fbb</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动为Flask写的API生成帮助文档</title>
      <link href="posts/2018-02-27/auto-document-flask-api/"/>
      <url>posts/2018-02-27/auto-document-flask-api/</url>
      
        <content type="html"><![CDATA[<p>Flask是Python一个非常轻量的库，可以让你毫不费力地写一个简单的网站。如果你需要写一些后台API或者准备自动化测试数据时，Flask是一个非常不错的选择。</p><a id="more"></a><h2 id="一个API例子"><a href="#一个API例子" class="headerlink" title="一个API例子"></a>一个API例子</h2><p>举个例子，我们可以这样写几个API，具体实现暂时略过：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views/api.py</span></span><br><span class="line"></span><br><span class="line">api = Blueprint(<span class="string">'api'</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@api.route('/get_todo', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_todo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Get all todo tasks."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api.route('/add_todo', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_todo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Add a todo task,  please post data in json format, e.g.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    data = &#123;</span></span><br><span class="line"><span class="string">              "name":"the title",</span></span><br><span class="line"><span class="string">              "task":"the detail"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api.route('/delete_todo', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_todo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Delete a todo task."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>一旦你的API完成，你可能需要和调用方沟通调用的细节，最好给一些例子。明明你已经在代码里给所有方法都写了注释，难道还要再把这些注释拿出来重新组织排版一下？</p><p>我猜你和我一样，听过这么一句话。</p><blockquote><p><strong>read the fucking manual</strong>!</p></blockquote><p>可是谁会去翻代码去看你的注释呢，何况你的代码他们还不一定能看到。如果能自动生成一个帮助页面那就好了。</p><h2 id="自动化API帮助文档"><a href="#自动化API帮助文档" class="headerlink" title="自动化API帮助文档"></a>自动化API帮助文档</h2><p>假设我们的API都是以 <code>http://127.0.0.1/api/*</code> 的形式书写的，那么最好把API的完整列表就放在根目录下面，比如这样：</p><p><img src="https://tobyqin.github.io/images/api-demo-home.png" alt="api-demo-home"></p><p>view 方法的实现主要依靠 <code>app.url_map</code> 来获取Flask中所有的API：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views/api.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_api_map</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Search API from rules, if match the pattern then we said it is API."""</span></span><br><span class="line">    <span class="keyword">for</span> rule <span class="keyword">in</span> get_app().url_map.iter_rules():</span><br><span class="line">        <span class="keyword">if</span> re.search(<span class="string">r'/api/.+'</span>, str(rule)):</span><br><span class="line">            <span class="keyword">yield</span> str(rule), rule.endpoint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api.route('/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""List all API to this page, api_map contains each api url + endpoint."""</span></span><br><span class="line">    api_map = sorted(list(get_api_map()))</span><br><span class="line">    index_url = url_for(<span class="string">'main.index'</span>, _external=<span class="literal">True</span>)</span><br><span class="line">    api_map = [(index_url + x[<span class="number">0</span>][<span class="number">1</span>:], x[<span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> api_map]</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'api_index.html'</span>, api_map=api_map)</span><br></pre></td></tr></table></figure><p>模板的实现：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># templates/api_index.html</span><br><span class="line"></span><br><span class="line">&#123;% extends "./layout.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;API Root&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block breadcrumb_nav %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('api.index') &#125;&#125;"</span>&gt;</span>Api Root<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block page_header %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Api Root<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content_area %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;</span><br><span class="line">&#123;% for i in api_map %&#125;    "<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/docs/&#123;&#123; i[1] &#125;&#125;"</span>&gt;</span>&#123;&#123; i[0] &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>"&#123;&#123; ",\n" if not loop.last &#125;&#125;&#123;% endfor %&#125;</span><br><span class="line">&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来文档化每个具体的API方法，最终的展示结果会是这样的。</p><p><img src="https://tobyqin.github.io/images/api-demo-full.png" alt="api-demo-full"></p><p>view 方法的实现思路其实也很明确，我们可以通过 <code>app.view_functions</code> 这个字典找到每个API 的endpoint所绑定的方法，然后访问方法的名字和文档即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views/main.py</span></span><br><span class="line"></span><br><span class="line">main = Blueprint(<span class="string">'main'</span>, __name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@main.route('/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Redirect home page to docs page."""</span></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'api.index'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@main.route('/docs/&lt;endpoint&gt;', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">docs</span><span class="params">(endpoint)</span>:</span></span><br><span class="line">    <span class="string">"""Document page for an endpoint."""</span></span><br><span class="line">    api = &#123;</span><br><span class="line">        <span class="string">'endpoint'</span>: endpoint,</span><br><span class="line">        <span class="string">'methods'</span>: [],</span><br><span class="line">        <span class="string">'doc'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'url'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        func = get_app().view_functions[endpoint]</span><br><span class="line"></span><br><span class="line">        api[<span class="string">'name'</span>] = _get_api_name(func)</span><br><span class="line">        api[<span class="string">'doc'</span>] = _get_api_doc(func)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> get_app().url_map.iter_rules():</span><br><span class="line">            <span class="keyword">if</span> rule.endpoint == endpoint:</span><br><span class="line">                api[<span class="string">'methods'</span>] = <span class="string">','</span>.join(rule.methods)</span><br><span class="line">                api[<span class="string">'url'</span>] = str(rule)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        api[<span class="string">'doc'</span>] = <span class="string">'Invalid api endpoint: "&#123;&#125;"!'</span>.format(endpoint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'api_docs.html'</span>, api=api)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_api_name</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""e.g. Convert 'do_work' to 'Do Work'"""</span></span><br><span class="line">    words = func.__name__.split(<span class="string">'_'</span>)</span><br><span class="line">    words = [w.capitalize() <span class="keyword">for</span> w <span class="keyword">in</span> words]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(words)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_api_doc</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func.__doc__:</span><br><span class="line">        <span class="keyword">return</span> func.__doc__</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'No doc found for this API!'</span></span><br></pre></td></tr></table></figure><p>模板的实现：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "./layout.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;API - &#123;&#123; api['name'] &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block breadcrumb_nav %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for('api.index') &#125;&#125;"</span>&gt;</span>Api Root<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; api['url'] &#125;&#125;"</span>&gt;</span>&#123;&#123; api['name'] &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block page_header %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; api['name'] | upper &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content_area %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Target:<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; api['url'] &#125;&#125;"</span>&gt;</span>&#123;&#123; api['url'] &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Allow :<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; api['methods'] &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>Usage :<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; api['doc'] &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h2 id="GitHub项目地址"><a href="#GitHub项目地址" class="headerlink" title="GitHub项目地址"></a>GitHub项目地址</h2><p>如果你想看完整的例子，可以到我的GitHub去拉一份代码。</p><blockquote><p><a href="https://github.com/tobyqin/flask_api_doc" target="_blank" rel="noopener">https://github.com/tobyqin/flask_api_doc</a></p></blockquote><p>只需要三步就可以在你的机器上运行Demo：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /path/to/flask_api/doc</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">python main.py</span><br></pre></td></tr></table></figure><p>如果你觉得Demo不错，欢迎给个Star。有建议或者想法也可以拿来讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
            <tag> api-doc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows上搭建Jekyll运行环境</title>
      <link href="posts/2018-01-26/setup-jekyll-environment-on-windows/"/>
      <url>posts/2018-01-26/setup-jekyll-environment-on-windows/</url>
      
        <content type="html"><![CDATA[<p>静态页面博客的鼻祖就是Jekyll。</p><a id="more"></a><h2 id="Jekyll-和-Hexo"><a href="#Jekyll-和-Hexo" class="headerlink" title="Jekyll 和 Hexo"></a>Jekyll 和 Hexo</h2><p>静态博客目前最流行的也就是 Hexo 和 Jekyll，我一直都是 Hexo 的粉丝和用户，相对于 Jekyll 我想大多数人选择 Hexo 的原因跟我差不多：</p><ol><li>安装本地环境简单，只需要 nodejs 和一行命令即可</li><li>官网文档非常优秀，极易上手</li><li>众多优秀的主题可选，配置功能完善</li><li>目录结构清晰易懂，内容和配置分离</li></ol><p>简单来说，Hexo 可以让你快速开始写文字，但是 Jekyll 却不见得，Jekyll 的罪状我大致列一下：</p><ol><li>本地环境在 Windows 上坑超多，很多人在这一步就放弃了，官方文档很挫</li><li>没有专门的主题目录，导致使用新主题需要覆盖安装</li><li>脚本和内容混合存放，不易管理和使用</li><li>托管后部署如果有错无法获取报错信息，如果没有本地环境根本没法调查</li></ol><p>另外，据说 Jekyll 站点的生成效率也比 Hexo 慢很多，不过我相信这对大多数人都没影响，我们的文章数量也不多。</p><p>但是，Jekyll 比 Hexo 有一个让你欲罢不能的优点，那就是天然被 GitHub Pages 支持，当然国内的 Coding Pages，OSC Pages 等等产商也直接支持 Jekyll，俨然这就是一个静态页面的标准。</p><p>使用 Jekyll，你可以不用考虑编译生成的问题，写完直接 commit，几分钟后就能看到效果。然而使用Hexo，你要么在本地生成页面后上传，要么找一个持续集成的服务（比如 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>）帮你编译后上传，不是很简单。</p><p>因为 Jekyll 那个欲罢不能的原因，今天就说说如果在 Windows 上用最快的速度准备一个Jekyll环境。</p><p>参考资料： <a href="https://jekyllrb.com/docs/windows/" target="_blank" rel="noopener">https://jekyllrb.com/docs/windows/</a></p><h2 id="通过Bash准备Jekyll环境"><a href="#通过Bash准备Jekyll环境" class="headerlink" title="通过Bash准备Jekyll环境"></a>通过Bash准备Jekyll环境</h2><p>如果你是 Windows 10，可以考虑使用 Bash 来运行Linux脚本和软件，详见 <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" target="_blank" rel="noopener">Bash on Ubuntu on Windows</a>。</p><p>启动 Bash 后，运行以下命令即可完成 Jekyll 的准备工作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update -y &amp;&amp; sudo apt-get upgrade -y</span><br><span class="line">sudo apt-add-repository ppa:brightbox/ruby-ng</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ruby2.3 ruby2.3-dev build-essential</span><br><span class="line">sudo gem update</span><br><span class="line">sudo gem install jekyll bundler</span><br></pre></td></tr></table></figure><p>可能遇到的坑：</p><ol><li><p>在 Windows 10 启用 Bash 并不容易，不是所有系统版本都支持</p></li><li><p>就算版本支持，你的 Windows 如果是盗版或者不完整也有可能装不上</p></li><li><p>就算你能装上，这个 Bash 需要 Linux 子系统是一个大家伙，会吃掉你系统盘很多空间</p></li><li><p>就算你系统盘有足够的空间，从服务器下载数GB的文件网络不一定稳定，电脑还不能随便关机</p></li></ol><p>不就是个Jekyll吗？至于嘛，Bash on Windows听起来简单，做起来就难了。</p><h2 id="通过-Ruby-Installer-安装"><a href="#通过-Ruby-Installer-安装" class="headerlink" title="通过 Ruby Installer 安装"></a>通过 Ruby Installer 安装</h2><p>Ruby 的安装包可以从 <a href="https://rubyinstaller.org/" target="_blank" rel="noopener">https://rubyinstaller.org/</a> 下载安装，如果你了解Ruby或者运气很好，选择了正确Ruby版本，那么恭喜你，一切会非常顺利。</p><p>不废话，直接说最佳答案。</p><ol><li>下载Ruby 2.3.3 x64 后双击运行安装。</li><li>下载Development KIT x64 后解压到 c:\devkit 目录</li><li>打开命令行工具，运行：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> c:\devkit</span><br><span class="line">ruby dk.rb init</span><br><span class="line">ruby dk.rb review</span><br><span class="line">ruby dk.rb install</span><br></pre></td></tr></table></figure><ol start="4"><li>安装Jekyll</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install jekyll bundler</span><br></pre></td></tr></table></figure><h2 id="在本地运行-Jekyll"><a href="#在本地运行-Jekyll" class="headerlink" title="在本地运行 Jekyll"></a>在本地运行 Jekyll</h2><p>更多命令建议参考官方文档 <a href="https://jekyllrb.com/docs/quickstart/" target="_blank" rel="noopener">https://jekyllrb.com/docs/quickstart/</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个新博客 ./myblog</span></span><br><span class="line">jekyll new myblog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入新建博客目录</span></span><br><span class="line"><span class="built_in">cd</span> myblog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装必要的依赖</span></span><br><span class="line">bundle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在本地启动预览</span></span><br><span class="line">jekyll serve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开浏览器 http://localhost:4000 即可看到效果</span></span><br></pre></td></tr></table></figure><h2 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h2><h3 id="如果有错误信息"><a href="#如果有错误信息" class="headerlink" title="如果有错误信息"></a>如果有错误信息</h3><p>错误信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR:  While executing gem ... (Encoding::UndefinedConversionError)</span><br><span class="line">U+200F to IBM862 in conversion from UTF-16LE to UTF-8 to IBM862</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>从Ruby安装目录找到registry.rb，修改默认Encoding为UTF-8。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">LOCALE = Encoding::UTF_8</span><br><span class="line"><span class="comment">#LOCALE = Encoding.find(Encoding.locale_charmap)</span></span><br></pre></td></tr></table></figure><p>错误信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compiling ruby_http_parser.c</span><br><span class="line">compiling ryah_http_parser.c</span><br><span class="line">linking shared-object ruby_http_parser.so</span><br><span class="line">c:&#x2F;devkit&#x2F;mingw&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-w64-mingw32&#x2F;4.7.2&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;x86_64-w64-mingw32&#x2F;bin&#x2F;ld.exe: cannot find -lgmp</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br><span class="line">make: *** [ruby_http_parser.so] Error 1</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>Ruby版本不对，没有gmp这个库。建议卸载掉重装2.3.3。</p><h3 id="其他的一些问题"><a href="#其他的一些问题" class="headerlink" title="其他的一些问题"></a>其他的一些问题</h3><ol><li>不要安装Ruby2.5，除非你有强烈的需求。</li><li>Ruby2.4 以后，在安装完成后会让你选择 MSYS2 Devkit，但是国内的网络环境你基本上装不了。</li><li>Ruby2.4 以后，你可以通过 <code>ridk  install</code> 安装 Devkit，国内网络环境，难。</li><li>Ruby2.4 以后，缺少Jekyll需要的依赖，目前我没办法解决。</li></ol><p>综上，不要使用Ruby2.4来准备Jekyll环境，不然你会很难过。</p><h2 id="小贴士-amp-小技巧"><a href="#小贴士-amp-小技巧" class="headerlink" title="小贴士&amp;小技巧"></a>小贴士&amp;小技巧</h2><p>很多朋友可能不知道，如果你已经初始化了Hexo或者Jekyll，后面写博时就可以完全抛开本地环境，专注于内容就行。</p><p>如果你是Hexo，安装完成后并且配置了自动化部署，以后写博客只需要在<code>/source/_posts/</code>目录下新建Markdown文件，完成后提交即可。新建的文章样式可以直接从该目录复制后修改，或者你从模板目录 <code>/scaffolds/</code> 中拷贝过来也行。</p><p>如果你是Jekyll，直接从<code>/_posts/</code>新建文件即可，操作同上。</p><p>新博客的文件名最好也都符合<code>yyyy-mm-dd-name.md</code>的样式，主要是方便排序和查阅，另外Jekyll也只认识这种样式。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ruby </tag>
            
            <tag> Jekyll </tag>
            
            <tag> Windows </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识 Python 中的 defaultdict</title>
      <link href="posts/2018-01-20/python-default-dict-intro/"/>
      <url>posts/2018-01-20/python-default-dict-intro/</url>
      
        <content type="html"><![CDATA[<p>今天我们的主角是<code>defaultdict</code>，同时也会介绍一下魔法方法<code>__missing__()</code>，本文主要来源于网友博客，分享给有需要的人。</p><a id="more"></a><h3 id="默认值可以很方便"><a href="#默认值可以很方便" class="headerlink" title="默认值可以很方便"></a>默认值可以很方便</h3><p>众所周知，在Python中如果访问字典中不存在的键，会引发KeyError异常。但是有时候，字典中的每个键都存在默认值是非常方便的。例如下面的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    counts[kw] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>该例子统计strings中某个单词出现的次数，并在counts字典中作记录。单词每出现一次，在counts相对应的键所存的值数字加1。但是事实上，运行这段代码会抛出KeyError异常，出现的时机是每个单词第一次统计的时候，因为Python的dict中不存在默认值的说法，可以在Python命令行中验证：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts = dict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>counts[<span class="string">'puppy'</span>] += <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'puppy'</span></span><br></pre></td></tr></table></figure><h3 id="使用判断语句检查"><a href="#使用判断语句检查" class="headerlink" title="使用判断语句检查"></a>使用判断语句检查</h3><p>既然如此，首先可能想到的方法是在单词第一次统计的时候，在counts中相应的键存下默认值1。这需要在处理的时候添加一个判断语句：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    <span class="keyword">if</span> kw <span class="keyword">not</span> <span class="keyword">in</span> counts:</span><br><span class="line">        counts[kw] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counts[kw] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># counts:</span></span><br><span class="line"><span class="comment"># &#123;'puppy': 5, 'weasel': 1, 'kitten': 2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用dict-setdefault-方法"><a href="#使用dict-setdefault-方法" class="headerlink" title="使用dict.setdefault()方法"></a>使用<code>dict.setdefault()</code>方法</h3><p>也可以通过<code>dict.setdefault()</code>方法来设置默认值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    counts.setdefault(kw, <span class="number">0</span>)</span><br><span class="line">    counts[kw] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>dict.setdefault()</code>方法接收两个参数，第一个参数是健的名称，第二个参数是默认值。假如字典中不存在给定的键，则返回参数中提供的默认值；反之，则返回字典中保存的值。利用<code>dict.setdefault()</code>方法的返回值可以重写for循环中的代码，使其更加简洁：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> kw <span class="keyword">in</span> strings:</span><br><span class="line">    counts[kw] = counts.setdefault(kw, <span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="使用collections-defaultdict类"><a href="#使用collections-defaultdict类" class="headerlink" title="使用collections.defaultdict类"></a>使用<code>collections.defaultdict</code>类</h3><p>以上的方法虽然在一定程度上解决了dict中不存在默认值的问题，但是这时候我们会想，有没有一种字典它本身提供了默认值的功能呢？答案是肯定的，那就是<code>collections.defaultdict</code>。</p><p>defaultdict类就好像是一个dict，但是它是使用一个类型来初始化的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;type <span class="string">'list'</span>&gt;, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>defaultdict类的初始化函数接受一个类型作为参数，当所访问的键不存在的时候，可以实例化一个值作为默认值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'foo'</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;type <span class="string">'list'</span>&gt;, &#123;<span class="string">'foo'</span>: []&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'bar'</span>].append(<span class="string">'quux'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;type <span class="string">'list'</span>&gt;, &#123;<span class="string">'foo'</span>: [], <span class="string">'bar'</span>: [<span class="string">'quux'</span>]&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是，这种形式的默认值只有在通过<code>dict[key]</code>或者<code>dict.__getitem__(key)</code>访问的时候才有效，这其中的原因在下文会介绍。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'something'</span> <span class="keyword">in</span> dd</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.pop(<span class="string">'something'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'pop(): dictionary is empty'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd.get(<span class="string">'something'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'something'</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>defaultdict类除了接受类型名称作为初始化函数的参数之外，还可以使用任何不带参数的可调用函数，到时该函数的返回结果作为默认值，这样使得默认值的取值更加灵活。下面用一个例子来说明，如何用自定义的不带参数的函数<code>zero()</code>作为defaultdict类的初始化函数的参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">zero</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(zero)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;function zero at <span class="number">0xb7ed2684</span>&gt;, &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'foo'</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd</span><br><span class="line">defaultdict(&lt;function zero at <span class="number">0xb7ed2684</span>&gt;, &#123;<span class="string">'foo'</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><p>利用<code>collections.defaultdict</code>来解决最初的单词统计问题，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">strings = (<span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>, <span class="string">'puppy'</span>,</span><br><span class="line">           <span class="string">'weasel'</span>, <span class="string">'puppy'</span>, <span class="string">'kitten'</span>, <span class="string">'puppy'</span>)</span><br><span class="line">counts = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)  <span class="comment"># 使用lambda来定义简单的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">    counts[s] += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="defaultdict类是如何实现的"><a href="#defaultdict类是如何实现的" class="headerlink" title="defaultdict类是如何实现的"></a>defaultdict类是如何实现的</h3><p>通过上面的内容，想必大家已经了解了defaultdict类的用法，那么在defaultdict类中又是如何来实现默认值的功能呢？这其中的关键是使用了看<code>__missing__()</code>这个方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> defaultdict.__missing__.__doc__</span><br><span class="line">__missing__(key) <span class="comment"># Called by __getitem__ for missing key; pseudo-code:</span></span><br><span class="line">  <span class="keyword">if</span> self.default_factory <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">  self[key] = value = self.default_factory()</span><br><span class="line">  <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>通过查看<code>__missing__()</code>方法的<code>docstring</code>，可以看出当使用<code>__getitem__()</code>方法访问一个不存在的键时<code>dict[key]</code>这种形式实际上是<code>__getitem__()</code>方法的简化形式)，会调用<code>__missing__()</code>方法获取默认值，并将该键添加到字典中去。</p><p>关于<code>__missing__()</code>方法的具体介绍可以参考Python官方文档中的”<a href="http://docs.python.org/library/stdtypes.html#dict" target="_blank" rel="noopener">Mapping Types — dict</a>“一节。</p><p>文档中介绍，从2.5版本开始，如果派生自dict的子类定义了<code>__missing__()</code>方法，当访问不存在的键时，dict[key]会调用<code>__missing__()</code>方法取得默认值。</p><p>从中可以看出，虽然dict支持<code>__missing__()</code>方法，但是在dict本身是不存在这个方法的，而是需要在派生的子类中自行实现这个方法。可以简单的验证这一点：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> dict.__missing__.__doc__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: type object <span class="string">'dict'</span> has no attribute <span class="string">'__missing__'</span></span><br></pre></td></tr></table></figure><p>同时，我们可以进一步的做实验，定义一个子类Missing并实现<code>__missing__()</code>方法:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Missing</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'missing'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Missing()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'foo'</span>]</span><br><span class="line"><span class="string">'missing'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>返回结果反映了<code>__missing__()</code>方法确实发挥了作用。在此基础上，我们稍许修改<code>__missing__()</code>方法,使得该子类同defautldict类一样为不存在的键设置一个默认值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Defaulting</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self[key] = <span class="string">'default'</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Defaulting()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'foo'</span>]</span><br><span class="line"><span class="string">'default'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'foo'</span>: <span class="string">'default'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="在旧版本的Python中实现defaultdict"><a href="#在旧版本的Python中实现defaultdict" class="headerlink" title="在旧版本的Python中实现defaultdict"></a>在旧版本的Python中实现defaultdict</h3><p>defaultdict类是从2.5版本之后才添加的，在一些旧版本中并不支持它，因此为旧版本实现一个兼容的defaultdict类是必要的。这其实很简单，虽然性能可能未必如2.5版本中自带的defautldict类好，但在功能上是一样的。</p><p>首先，<code>__getitem__()</code>方法需要在访问键失败时，调用<code>__missing__()</code>方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">defaultdict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> dict.__getitem__(self, key)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> self.__missing__(key)</span><br></pre></td></tr></table></figure><p>其次，需要实现<code>__missing__()</code>方法用来设置默认值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">defaultdict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> dict.__getitem__(self, key)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> self.__missing__(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self[key] = value = self.default_factory()</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>然后，defaultdict类的初始化函数<code>__init__()</code>需要接受类型或者可调用函数参数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">defaultdict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, default_factory=None, *a, **kw)</span>:</span></span><br><span class="line">        dict.__init__(self, *a, **kw)</span><br><span class="line">        self.default_factory = default_factory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> dict.__getitem__(self, key)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> self.__missing__(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self[key] = value = self.default_factory()</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>最后，综合以上内容，通过以下方式完成兼容新旧Python版本的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">defaultdict</span><span class="params">(dict)</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, default_factory=None, *a, **kw)</span>:</span></span><br><span class="line">          dict.__init__(self, *a, **kw)</span><br><span class="line">          self.default_factory = default_factory</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">          <span class="keyword">try</span>:</span><br><span class="line">              <span class="keyword">return</span> dict.__getitem__(self, key)</span><br><span class="line">          <span class="keyword">except</span> KeyError:</span><br><span class="line">              <span class="keyword">return</span> self.__missing__(key)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">          self[key] = value = self.default_factory()</span><br><span class="line">          <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" target="_blank" rel="noopener">https://docs.python.org/2/library/collections.html#collections.defaultdict</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> defaultdict </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>识别图片中的文字 - Tesseract 和 百度云OCR的对比</title>
      <link href="posts/2018-01-16/chinese-text-ocr-via-python/"/>
      <url>posts/2018-01-16/chinese-text-ocr-via-python/</url>
      
        <content type="html"><![CDATA[<p>当今时代人工智能都已经是烂大街的词了，OCR应该也很多人都知道。</p><a id="more"></a><blockquote><p>OCR （Optical Character Recognition，<a href="https://baike.baidu.com/item/%E5%85%89%E5%AD%A6%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB" target="_blank" rel="noopener">光学字符识别</a>）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程。</p></blockquote><p>本文主要记录了通过Python使用OCR的两次尝试。</p><h2 id="Tesseract"><a href="#Tesseract" class="headerlink" title="Tesseract"></a>Tesseract</h2><p><strong>Tesseract</strong>，一款由HP实验室开发由Google维护的开源OCR（Optical Character Recognition , 光学字符识别）引擎，特点是开源，免费，支持多语言，多平台。</p><p>项目地址：<a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></p><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>Tesseract的安装比较简单，在mac可以通过brew安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install --with-training-tools tesseract</span><br></pre></td></tr></table></figure><p>在windows可以通过exe安装包安装，下载地址可以从GitHub项目中的wiki找到。安装完成后记得将Tesseract 执行文件的目录加入到PATH中，方便后续调用。</p><p>另外，默认安装会包含英文语言训练包，如果需要支持简体中文或者繁体中文，需要在安装时勾选。</p><p><img src="https://tobyqin.github.io/images/tesseract-lang.png" alt="tesseract-lang"></p><p>或者安装结束后到项目地址下载：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></p><p>下载好的语言包放入到安装目录中的testdata下即可。在windows系统你还需要将testdata目录也加入环境变量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TESSDATA_PREFIX&#x3D;C:\Program Files (x86)\Tesseract-OCR\tessdata</span><br></pre></td></tr></table></figure><p>如果一切就绪，你在命令行中就可以使用Tesseract命令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tesseract</span><br><span class="line">Usage:</span><br><span class="line">  tesseract --help | --help-psm | --help-oem | --version</span><br><span class="line">  tesseract --list-langs [--tessdata-dir PATH]</span><br><span class="line">  tesseract --print-parameters [options...] [configfile...]</span><br><span class="line">  tesseract imagename|stdin outputbase|stdout [options...] [configfile...]</span><br><span class="line"></span><br><span class="line">OCR options:</span><br><span class="line">  --tessdata-dir PATH   Specify the location of tessdata path.</span><br><span class="line">  --user-words PATH     Specify the location of user words file.</span><br><span class="line">  --user-patterns PATH  Specify the location of user patterns file.</span><br><span class="line">  -l LANG[+LANG]        Specify language(s) used for OCR.</span><br><span class="line">  -c VAR&#x3D;VALUE          Set value for config variables.</span><br><span class="line">                        Multiple -c arguments are allowed.</span><br><span class="line">  --psm NUM             Specify page segmentation mode.</span><br><span class="line">  --oem NUM             Specify OCR Engine mode.</span><br><span class="line">NOTE: These options must occur before any configfile.</span><br></pre></td></tr></table></figure><p>通过命令行你就可以完成简单的图片文字识别任务。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tesseract test.png outfile -l chi_sim</span><br></pre></td></tr></table></figure><h3 id="通过Python调用"><a href="#通过Python调用" class="headerlink" title="通过Python调用"></a>通过Python调用</h3><p>Tesseract安装完成后可以很方便的被Python调用，你需要安装两个包。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pillow</span><br><span class="line">pip install pytesseract</span><br></pre></td></tr></table></figure><p>一个简单的图片转文字的函数实现如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Languages</span>:</span></span><br><span class="line">    CHS = <span class="string">'chi_sim'</span></span><br><span class="line">    CHT = <span class="string">'chi_tra'</span></span><br><span class="line">    ENG = <span class="string">'eng'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_str</span><span class="params">(image_path, lang=Languages.ENG)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pytesseract.image_to_string(Image.open(image_path), lang)</span><br><span class="line">  </span><br><span class="line">print(img_to_str(<span class="string">'image/test1.png'</span>, lang=Languages.CHS))</span><br><span class="line">print(img_to_str(<span class="string">'image/test2.png'</span>, lang=Languages.CHS))</span><br></pre></td></tr></table></figure><p>测试图片- <code>test1.png</code>：</p><p><img src="https://tobyqin.github.io/images/orc-test1.png" alt="test1"></p><p>识别结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process image file &quot;image&#x2F;test1.png&quot; in 1.4782530478747697 seconds</span><br><span class="line"></span><br><span class="line">8 所 调 人 , 在 - 方 。</span><br><span class="line">深 从 久 , 定 中 央</span><br><span class="line">。 所 澈 伊 人 , 圭 水 淳</span><br><span class="line">。 淇 渡 从 之 , 定 圭 北 中 坂 。</span><br><span class="line">。 所 澈 伊人 , 圭 水 浩</span><br><span class="line">从 丿 , 定 圭 水 中 沥 。</span><br></pre></td></tr></table></figure><p>测试图片 - <code>test2.png</code></p><p><img src="https://tobyqin.github.io/images/orc-test2.png" alt="test1"></p><p>识别结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process image file &quot;image&#x2F;test2.png&quot; in 1.2131140296607923 seconds</span><br><span class="line"></span><br><span class="line">清 明 时 节 雨 纷 纷 , 路 上 行 人 欲 断 魂</span><br><span class="line">信 问 酒 家 何 处 有 , 牧 奕 通 指 枪 花 村 。</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Tesseract在识别清晰的标准中文字体效果还行，稍微复杂的情况就很糟糕，而且花费的时间也很多，我个人觉得唯一的优点就是免费了。如果你不介意多花时间，可以考虑使用它提供的训练功能自定义你的语言库，那样在特定场景下识别率应该能上一个台阶。</p><h2 id="百度云OCR"><a href="#百度云OCR" class="headerlink" title="百度云OCR"></a>百度云OCR</h2><p>这是偶然的发现，百度云提供了一定额度的免费的OCR API，目前是每日500次，做做研究或者小应用还勉强够用，本文主要为了测试其效果。</p><p>文档地址：<a href="https://cloud.baidu.com/doc/OCR/OCR-Python-SDK.html" target="_blank" rel="noopener">https://cloud.baidu.com/doc/OCR/OCR-Python-SDK.html</a></p><h3 id="安装使用-1"><a href="#安装使用-1" class="headerlink" title="安装使用"></a>安装使用</h3><p>首先你需要注册一个<a href="https://cloud.baidu.com/" target="_blank" rel="noopener">百度云BCE账号</a>，然后从控制面板新建一个文字识别应用。<img src="https://tobyqin.github.io/images/baidu-ocr.png" alt="baidu-ocr"></p><p>之后你就可以获得调用API需要的 AppID，API Key 和 Secret Key。后面只要根据官方文档一步一步走就可以了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install baidu-aip</span><br></pre></td></tr></table></figure><h3 id="封装和调用"><a href="#封装和调用" class="headerlink" title="封装和调用"></a>封装和调用</h3><p>参考文档： <a href="https://cloud.baidu.com/doc/OCR/OCR-Python-SDK.html#.E6.8E.A5.E5.8F.A3.E8.AF.B4.E6.98.8E" target="_blank" rel="noopener">https://cloud.baidu.com/doc/OCR/OCR-Python-SDK.html#.E6.8E.A5.E5.8F.A3.E8.AF.B4.E6.98.8E</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'appId'</span>: <span class="string">'your-id'</span>,</span><br><span class="line">    <span class="string">'apiKey'</span>: <span class="string">'your-key'</span>,</span><br><span class="line">    <span class="string">'secretKey'</span>: <span class="string">'your-secret-key'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client = AipOcr(**config)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_str</span><span class="params">(image_path)</span>:</span></span><br><span class="line">    image = get_file_content(image_path)</span><br><span class="line">    result = client.basicGeneral(image)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'words_result'</span> <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join([w[<span class="string">'words'</span>] <span class="keyword">for</span> w <span class="keyword">in</span> result[<span class="string">'words_result'</span>]])</span><br></pre></td></tr></table></figure><p>测试图片- <code>test1.png</code>：</p><p><img src="https://tobyqin.github.io/images/orc-test1.png" alt="test1"></p><p>识别结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process image file &quot;image&#x2F;test1.png&quot; in 0.6331169034812572 seconds</span><br><span class="line"></span><br><span class="line">蒹葭</span><br><span class="line">先秦:佚名</span><br><span class="line">蒹葭苍苍,白露为霜。所谓伊人,在水一方。</span><br><span class="line">溯洄从之,道阻且长。溯游从之,宛在水中央。</span><br><span class="line">蒹葭萋萋,白露未晞。所谓伊人,在水之湄。</span><br><span class="line">溯洄从之,道阳且跻。溯游从之,宛在水中坻。</span><br><span class="line">蒹葭采采,白露未已。所谓伊人,在水之涘。</span><br><span class="line">溯洄从之,道阻且右。溯游从之,宛在水中沚。</span><br></pre></td></tr></table></figure><p>测试图片 - <code>test2.png</code></p><p><img src="https://tobyqin.github.io/images/orc-test2.png" alt="test1"></p><p>识别结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process image file &quot;image&#x2F;test2.png&quot; in 0.6621812639450142 seconds</span><br><span class="line"></span><br><span class="line">清明时节雨纷纷,路上行人欲断魂。</span><br><span class="line">借问酒家何处有,牧童遥指杏花村。</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>测试结果很明显，我只能说百度云这个OCR真是挺厉害的，一个错别字都没有，不服不行。论中文，还是百度比谷歌更懂一点。而且百度OCR提供了更多的参数让你更灵活的处理图片，比如自定义旋转，返回可信度，特定类型证件识别等等。</p><h2 id="更多的OCR"><a href="#更多的OCR" class="headerlink" title="更多的OCR"></a>更多的OCR</h2><p>除了本文提到的OCR，其实还是有不少其他选择。有一些直接提供Demo页面，你直接上传一张图片就可以直接看到识别效果，比如：</p><ul><li>微软Azure 图像识别：<a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/computer-vision/" target="_blank" rel="noopener">https://azure.microsoft.com/zh-cn/services/cognitive-services/computer-vision/</a></li><li>有道智云文字识别：<a href="http://aidemo.youdao.com/ocrdemo" target="_blank" rel="noopener">http://aidemo.youdao.com/ocrdemo</a></li><li>阿里云图文识别：<a href="https://www.aliyun.com/product/cdi/" target="_blank" rel="noopener">https://www.aliyun.com/product/cdi/</a></li><li>腾讯OCR文字识别： <a href="https://cloud.tencent.com/product/ocr" target="_blank" rel="noopener">https://cloud.tencent.com/product/ocr</a></li></ul><p>你有没有发现所有的大公司都有这样的服务？以后我们买买买就行，花大力气去发明轮子就没多大意义了。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ocr </tag>
            
            <tag> tesseract </tag>
            
            <tag> baidu-ocr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【问题】使用Python将字符串过滤并保留关键字</title>
      <link href="posts/2018-01-15/filter-string-by-keyword/"/>
      <url>posts/2018-01-15/filter-string-by-keyword/</url>
      
        <content type="html"><![CDATA[<p>Python 算法备忘。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给出一个关键词列表:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keys &#x3D; [&#39;aaa&#39;,&#39;bbb&#39;,&#39;ccc&#39;]</span><br></pre></td></tr></table></figure><p>给出一个字符串 <code>str</code>，如果字符串中有包含列表 <code>keys</code> 中的子串，则过滤并保留下来，其余部分则删除。请问可以如何实现？</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; &#39;aaaawtf he heheccc&#39;</span><br></pre></td></tr></table></figure><p>过滤后变成:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;aaa ccc&#39;</span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; &#39;aaabbb&#x2F;&amp;edfg cccaaa&#39;</span><br></pre></td></tr></table></figure><p>过滤后变成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;aaabbb cccaaa&#39;</span><br></pre></td></tr></table></figure><p>要求尽可能保留原字符串的相对位置信息，比如aaa和bbb是连在一块的，就连在一块被保留下来。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>解决这个问题可以分两步走，第一步，找出关键字位置并记录；第二步，重新组合拼接。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'aaabbb/&amp;edfg cccaaa'</span></span><br><span class="line">keys = [<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>]</span><br><span class="line"></span><br><span class="line">found = &#123;k: [] <span class="keyword">for</span> k <span class="keyword">in</span> keys&#125;</span><br><span class="line">total_length = len(str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按key依次遍历字符串，保存出现的位置</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    length, i = len(key), <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i + length &lt;= total_length:</span><br><span class="line">        s = str[i:i + length]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s == key:</span><br><span class="line">            found[key].append(i)</span><br><span class="line">            i += length</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(found)</span><br><span class="line"><span class="comment"># &#123;'aaa': [0, 16], 'bbb': [3], 'ccc': [13]&#125;</span></span><br><span class="line"></span><br><span class="line">result, next_match_index = <span class="string">''</span>, <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新组合，如果坐标重叠连接符为空，否则为空格</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_length):</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> found.items():</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> v:</span><br><span class="line">            split = <span class="string">''</span> <span class="keyword">if</span> next_match_index == i <span class="keyword">else</span> <span class="string">' '</span></span><br><span class="line"></span><br><span class="line">            result = result + split + k</span><br><span class="line">            next_match_index = i + len(k)</span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># aaabbb cccaaa</span></span><br></pre></td></tr></table></figure><h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><p>其实可以考虑以上两步可以合并一起做掉，不过代码就相对没那么好理解了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'aaaabbb/&amp;edfg cccaaa'</span></span><br><span class="line">keys = [<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>]</span><br><span class="line"></span><br><span class="line">total_length = len(str)</span><br><span class="line">result, next_match_index, skip = <span class="string">''</span>, <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_length):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> skip:</span><br><span class="line">        skip -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys:  <span class="comment"># 查找当前位置是否有match的key</span></span><br><span class="line">        length = len(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i + length &lt;= total_length:  <span class="comment"># 确保index不越界</span></span><br><span class="line">            s = str[i:i + length]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s == key:  <span class="comment"># 如果有match的key，添加到结果</span></span><br><span class="line">                split = <span class="string">''</span> <span class="keyword">if</span> next_match_index == i <span class="keyword">else</span> <span class="string">' '</span></span><br><span class="line">                result = result + split + key</span><br><span class="line"></span><br><span class="line">                next_match_index = i + length <span class="comment">#预测相邻key的位置</span></span><br><span class="line">                skip = length - <span class="number">1</span> <span class="comment">#需要跳过当前key后匹配下一个key</span></span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># 已经找到匹配key，可以结束keys的遍历</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Quiz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> quiz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【问题】从一长串数字中找到重复多次的三个数字</title>
      <link href="posts/2018-01-03/get-repeat-digits-from-a-long-number/"/>
      <url>posts/2018-01-03/get-repeat-digits-from-a-long-number/</url>
      
        <content type="html"><![CDATA[<p>Python算法备忘。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p><a href="https://stackoverflow.com/questions/47581326/given-a-string-of-a-million-numbers-return-all-repeating-3-digit-numbers" target="_blank" rel="noopener">https://stackoverflow.com/questions/47581326/given-a-string-of-a-million-numbers-return-all-repeating-3-digit-numbers</a></p></blockquote><p>假设给定一个很长的数字，比如PI精确到100万位，找到其中重复出现相邻三个数字。比如给定的数字是1233223332321234323123，那么结果应该是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 repeat 3 times</span><br><span class="line">233 repeat 2 times</span><br><span class="line">323 repeat 2 times</span><br><span class="line">332 repeat 2 times</span><br></pre></td></tr></table></figure><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>如果要统计相邻三个数字的重复次数，那么必然需要将其所有可能都列出来，通过Python的切片我们很容易实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number = <span class="string">'1233223332321234323123'</span></span><br><span class="line">split = [number[position:position + <span class="number">3</span>] <span class="keyword">for</span> position <span class="keyword">in</span> range(len(number) - <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">print(split)</span><br><span class="line"><span class="comment"># ['123', '233', '332', '322', '223', '233', '333', '332', '323', '232', '321', '212', '123', '234', '343', '432', '323', '231', '312', '123']</span></span><br></pre></td></tr></table></figure><p>接下来我们需要统计切好的序列里各个数字出现的次数，因为需要处理是3位数字，可以考虑新建一个长度为1000的空序列，如果数字出现就在对应位置加一，达到统计的目的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> split:</span><br><span class="line">    seq[int(x)] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后我们只要把新序列里统计值大于1的打印出来即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">if</span> seq[i] &gt; <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'&#123;&#125; repeat &#123;&#125; times'</span>.format(i, seq[i]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 123 repeat 3 times</span></span><br><span class="line"><span class="comment"># 233 repeat 2 times</span></span><br><span class="line"><span class="comment"># 323 repeat 2 times</span></span><br><span class="line"><span class="comment"># 332 repeat 2 times</span></span><br></pre></td></tr></table></figure><p>我们可以用更加优雅的方式来呈现以上算法，简洁但不简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">0</span>] * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> [int(number[pos:pos+<span class="number">3</span>]) <span class="keyword">for</span> pos <span class="keyword">in</span> range(len(number) - <span class="number">2</span>)]:</span><br><span class="line">    seq[val] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ([(num, seq[num]) <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1000</span>) <span class="keyword">if</span> seq[num] &gt; <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>以上便是Stack Overflow上原题的最佳答案。</p><h2 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h2><p>如果这个问题给定的不是数字，而是字符串比如abccdbadfdaabc，依然是要找到相邻的3个重复字母，你有没有好办法？</p>]]></content>
      
      
      <categories>
          
          <category> Quiz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> quiz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你使用50行Python代码刷王者荣耀金币</title>
      <link href="posts/2017-12-14/hack-way-to-get-golden-coins-for-king-of-glory/"/>
      <url>posts/2017-12-14/hack-way-to-get-golden-coins-for-king-of-glory/</url>
      
        <content type="html"><![CDATA[<p>用脚本来刷金币。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>王者荣耀的冒险模式里有个挑战模式，第一次过关可以获得比较多的金币，后面重新挑战还是会获得少量金币，这不算是bug，你不嫌烦手动蛮力也可以刷金币。</p><blockquote><p>推荐关卡：陨落的废都 - 魔女回忆</p></blockquote><p>此关卡使用纯输出英雄20秒左右可以打BOSS，50秒左右可以通关，每次重复通关可以获得奖励19金币。在开挂前建议你手动通关体验一下。此为游戏原理。</p><p>简单来说，需要执行以下步骤：</p><ol><li>界面打开至挑战关卡：陨落的废都 - 魔女回忆 【点击下一步】</li><li>进入阵容调整界面，提前安排好阵容。【点击闯关】</li><li>进入挑战界面。【点击右上角-自动-等待挑战结束】</li><li>进入挑战完成界面。【点击屏幕继续】</li><li>进入关卡奖励界面。【点击再次挑战】</li><li>进入阵容调整界面，循环至步骤1或步骤2【貌似取决于游戏区和版本】</li></ol><p>只要你能模拟屏幕点击就可以完成刷金币的脚本，在安卓模拟界面点击最简单的方式就是使用ADB发送命令，不需要root手机，不需要安装第三方软件，方便快捷。ADB命令点击屏幕坐标[x, y] 可以使用命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input tap x y</span><br></pre></td></tr></table></figure><p>IOS 是否有类似工具和命令，我不清楚，如果有那么实现自动刷金币也很简单。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>本脚本适用于安卓游戏区，需要真实安卓手机。</li><li>手机需开启USB调试模式，允许电脑调试。</li><li>电脑需安装好安卓驱动，一般豌豆荚或者各种管家可以自动帮你装好。</li><li>电脑需要有ADB工具集，很多方式可以获取。</li><li>ADB工具需要加入环境变量PATH中，方便随时调用。</li><li>电脑上需要安装Python，因为这是我选择的脚本语言。</li></ul><p>专业的开发测试人员，也可以参考我的另外两篇博客：</p><ul><li><a href="https://tobyqin.github.io/posts/2017-05-03/setup-appium-automation-test-environment/" target="_blank" rel="noopener">在 Windows 下搭建 Appium + Android 自动化测试环境</a></li><li><a href="https://tobyqin.github.io/posts/2017-12-10/setup-appium-test-environment-on-mac-osx/" target="_blank" rel="noopener">在Mac OSX 上配置Appium+Android自动化测试环境</a></li></ul><p>如果只是为了刷金币，只需要安装好驱动和ADB工具即可。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>如果万事具备，那么步骤就非常简单。</p><h3 id="环境检测"><a href="#环境检测" class="headerlink" title="环境检测"></a>环境检测</h3><ol><li>用USB连接手机，如果弹出警告，请允许电脑调试手机。</li><li>使用命令 <code>adb devices</code> 检验adb和手机状态已经就绪。</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">b******4        device</span><br></pre></td></tr></table></figure><p>模拟点击屏幕，比如你可以打开画图软件，然后运行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell input tap 500 500</span><br></pre></td></tr></table></figure><p>如果如果一切OK，那么你将看到画图软件在坐标（500,500）的位置有一个点。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>通关需要点击的屏幕位置是固定的，加上注释我们只需要不到30行代码就可以完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tap_screen</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    os.system(<span class="string">'adb shell input tap &#123;&#125; &#123;&#125;'</span>.format(x, y))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_money_work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'#0 start the game'</span>)</span><br><span class="line">    tap_screen(<span class="number">1600</span>, <span class="number">970</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'#1 ready, go!!!'</span>)</span><br><span class="line">    tap_screen(<span class="number">1450</span>, <span class="number">910</span>)</span><br><span class="line">    sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'#2 auto power on!'</span>)</span><br><span class="line">    tap_screen(<span class="number">1780</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">25</span>):</span><br><span class="line">        tap_screen(<span class="number">1000</span>, <span class="number">500</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'#3 do it again...\n'</span>)</span><br><span class="line">    tap_screen(<span class="number">1430</span>, <span class="number">980</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>然后我们写一个主函数来循环刷钱。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(repeat_times):</span><br><span class="line">        print(<span class="string">'round #&#123;&#125;'</span>.format(i + <span class="number">1</span>))</span><br><span class="line">        do_money_work()</span><br></pre></td></tr></table></figure><h3 id="拿来主义"><a href="#拿来主义" class="headerlink" title="拿来主义"></a>拿来主义</h3><p>如果你喜欢拿来主义，请访问本文项目地址： </p><ul><li><a href="https://github.com/tobyqin/kog-money" target="_blank" rel="noopener">https://github.com/tobyqin/kog-money</a></li></ul><p>然后：</p><ol><li>下载项目中的 <code>kog.py</code> 到本地。</li><li>将游戏打开，进入挑战模式，魔女回忆，阵容调整界面。</li><li>根据手机性能和分辨率，调整<code>kog.py</code>中的参数。（手机分辨率，刷金次数等等）</li><li>运行以下命令，手机上就可以查看实时运行效果。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python kog.py</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>每周金币上限4200，需要接近4个小时，不建议一次刷满，手机和你都要休息。</li><li>铭文，手机性能，英雄选择都会影响通关速度，自己微调等待时间。</li><li>如果你不想被USB数据线束缚，可以考虑<a href="/posts/2017-12-12/connect-adb-via-wifi/">使用无线连接Android真机</a>。</li></ol><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本脚本纯属娱乐和探索的心得，如果你因为违反了游戏规则导致被封号，我概不负责。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> android </tag>
            
            <tag> adb </tag>
            
            <tag> kog </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ADB无线连接Android真机进行调试</title>
      <link href="posts/2017-12-12/connect-adb-via-wifi/"/>
      <url>posts/2017-12-12/connect-adb-via-wifi/</url>
      
        <content type="html"><![CDATA[<p>其实这已经是一个很古老的知识了，记录一下备忘。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>手机和电脑需要在同一个局域网内</li><li>电脑上已经安装好ADB工具，可以是Mac或者Windows</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-打开手机端口"><a href="#1-打开手机端口" class="headerlink" title="1. 打开手机端口"></a>1. 打开手机端口</h3><p>让手机在指定的端口可以接收到TCP/IP连接。</p><ol><li>确保手机开启了usb调试</li><li>用usb线把手机和电脑连接起来</li><li>执行命令：<code>adb tcpip 5555</code></li></ol><p>执行成功后就可以把usb线拔掉了，端口可以不是5555，这个官方默认使用的。</p><h3 id="2-找到手机的IP地址"><a href="#2-找到手机的IP地址" class="headerlink" title="2. 找到手机的IP地址"></a>2. 找到手机的IP地址</h3><p>一般在 设置-关于手机-状态信息-IP地址可以找到。</p><p>比如，我这里看到手机的IP地址是192.168.1.100</p><h3 id="3-通过IP地址连接手机"><a href="#3-通过IP地址连接手机" class="headerlink" title="3. 通过IP地址连接手机"></a>3. 通过IP地址连接手机</h3><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect 192.168.1.100:5555</span><br></pre></td></tr></table></figure><p>如果提示：</p><blockquote><p>connected to 192.160.1.100:5555</p></blockquote><p>则表示连接成功，如果端口号是5555可以省略，直接：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect 192.168.1.100</span><br></pre></td></tr></table></figure><h3 id="4-如果没有连接成功"><a href="#4-如果没有连接成功" class="headerlink" title="4. 如果没有连接成功"></a>4. 如果没有连接成功</h3><p>如果确定你的网络和端口都没问题，可以尝试重启一下adb服务：</p><blockquote><p>adb kill-server</p></blockquote><p>然后再进行连接，实在还是不行就Google吧。</p><h3 id="5-连接成功"><a href="#5-连接成功" class="headerlink" title="5. 连接成功"></a>5. 连接成功</h3><p>如果连接成功的话，执行以下命令查看当前连接的设备列表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>可以看到连接的设备，像这样</p><blockquote><p>$ adb devices<br>List of devices attached<br>192.168.1.100:5555    device</p></blockquote><p>以后没有数据线也可以调试手机或者在上面运行自动化测试了。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>更换一个网络环境需要使用新IP重新connect即可。</li><li>但是如果手机重启了，就需要重新连接数据线再次开启端口。</li><li>开启端口可以通过adb，也可以直接在手机上打开，但一般需要root权限和特殊软件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> automation </tag>
            
            <tag> adb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Mac OSX 上配置 Appium + Android 自动化测试环境</title>
      <link href="posts/2017-12-10/setup-appium-test-environment-on-mac-osx/"/>
      <url>posts/2017-12-10/setup-appium-test-environment-on-mac-osx/</url>
      
        <content type="html"><![CDATA[<p>Appium是手机端自动化测试的必备知识。</p><a id="more"></a><h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>开始正文之前，你需要准备好一些基本条件：</p><ol><li>安装好Mac OSX 操作系统的设备</li><li>能够访问中国局域网以外资源的方法（没有也行，但很痛苦）</li><li>已经安装好 <a href="https://brew.sh/" target="_blank" rel="noopener">homebrew</a></li><li>已经安装好 Python3.x，可以通过brew安装</li><li>已经安装好 Java Runtime Environment，可以通过brew安装</li></ol><h2 id="安装-Android-Studio-SDK"><a href="#安装-Android-Studio-SDK" class="headerlink" title="安装 Android Studio / SDK"></a>安装 Android Studio / SDK</h2><p>本文主要为了测试安卓应用，那么这里我们就需要安装Android Studio或者Android SDK。</p><ul><li>Android Studio - 完整的开发以及测试工具，需要梯子</li><li>Android SDK + Platform Tools - 足够完成自动化测试，通过homebrew安装</li></ul><p>如果只是为了自动化测试建议安装SDK足矣，使用brew命令轻松搞定。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install android-sdk</span><br><span class="line">brew cask install android-platform-tools</span><br></pre></td></tr></table></figure><p>在国内使用brew可以事先配置好国内源，速度会快很多。</p><p>如果有梯子可以选择Android Studio，安装方法很简单，官网下载后一路Next，启动后会让你把SDK等等一系列依赖都装好，一步到位。</p><h2 id="准备Android-模拟器或者使用真机"><a href="#准备Android-模拟器或者使用真机" class="headerlink" title="准备Android 模拟器或者使用真机"></a>准备Android 模拟器或者使用真机</h2><p>如果SDK已经安装完毕，应该可以使用adb命令来检查可用的模拟器或者已经连接到电脑上的实体手机。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>如果不知道adb工具在哪，可以先在命令行里通过find搜索。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;Users -name adb  # 搜索用户目录</span><br><span class="line">find &#x2F; -name adb  # 搜索全盘</span><br></pre></td></tr></table></figure><p>找到之后可以把 adb 目录加入PATH，方便后续使用。一般在 <code>~/Library/Android/sdk/platform-tools/adb</code>，如果通过brew安装，会自动建立软链接后加入PATH。</p><p>模拟器可以使用官方模拟器（Android Studio自带），或者口碑较好的 <a href="https://www.genymotion.com/" target="_blank" rel="noopener">Genymotion</a>，具体请查阅其他文章，搭模拟器其实也挺不容易的。</p><h2 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h2><p>Appium 可以通过多种方式安装。</p><h3 id="方式一：使用-NodeJS-安装"><a href="#方式一：使用-NodeJS-安装" class="headerlink" title="方式一：使用 NodeJS 安装"></a>方式一：使用 NodeJS 安装</h3><p>首先通过brew安装nodejs：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>配置国内源，在个人目录下新建一个.npmrc文件，写入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><p>开始安装Appium：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g appium</span><br><span class="line">npm install -g appium-doctor</span><br></pre></td></tr></table></figure><p>Appium-doctor 可以帮你诊断测试环境，建议安装。</p><h3 id="方式二：下载Appium桌面版安装"><a href="#方式二：下载Appium桌面版安装" class="headerlink" title="方式二：下载Appium桌面版安装"></a>方式二：下载Appium桌面版安装</h3><p>官方的Appium桌面安装包可以从github下载，需要梯子。</p><ul><li><a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a></li></ul><p>下载到的dmg文件双击装载，把Appium拖到Application里完成安装。</p><h2 id="安装-Appium-Client"><a href="#安装-Appium-Client" class="headerlink" title="安装 Appium-Client"></a>安装 Appium-Client</h2><p>本文只讨论Python实现的Appium测试，所以你只需要允许以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Appium-Python-Client</span><br></pre></td></tr></table></figure><p>如果需要使用其他编程语言，下表供参考：</p><table><thead><tr><th>语言/框架</th><th>Github版本库以及安装指南</th></tr></thead><tbody><tr><td>Ruby</td><td><a href="https://github.com/appium/ruby_lib" target="_blank" rel="noopener">https://github.com/appium/ruby_lib</a></td></tr><tr><td>Python</td><td><a href="https://github.com/appium/python-client" target="_blank" rel="noopener">https://github.com/appium/python-client</a></td></tr><tr><td>Java</td><td><a href="https://github.com/appium/java-client" target="_blank" rel="noopener">https://github.com/appium/java-client</a></td></tr><tr><td>JavaScript (Node.js)</td><td><a href="https://github.com/admc/wd" target="_blank" rel="noopener">https://github.com/admc/wd</a></td></tr><tr><td>Objective C</td><td><a href="https://github.com/appium/selenium-objective-c" target="_blank" rel="noopener">https://github.com/appium/selenium-objective-c</a></td></tr><tr><td>PHP</td><td><a href="https://github.com/appium/php-client" target="_blank" rel="noopener">https://github.com/appium/php-client</a></td></tr><tr><td>C# (.NET)</td><td><a href="https://github.com/appium/appium-dotnet-driver" target="_blank" rel="noopener">https://github.com/appium/appium-dotnet-driver</a></td></tr><tr><td>RobotFramework</td><td><a href="https://github.com/jollychang/robotframework-appiumlibrary" target="_blank" rel="noopener">https://github.com/jollychang/robotframework-appiumlibrary</a></td></tr></tbody></table><h2 id="必要的环境变量设置"><a href="#必要的环境变量设置" class="headerlink" title="必要的环境变量设置"></a>必要的环境变量设置</h2><p>如果你已经安装了appium-doctor，那么你只要运行appium-doctor命令就可以知道你还需要设置哪些环境变量，比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tobyqin@CatBook ~&gt; appium-doctor</span><br><span class="line">info AppiumDoctor Appium Doctor v.1.4.3</span><br><span class="line">info AppiumDoctor ### Diagnostic starting ###</span><br><span class="line">info AppiumDoctor  ✔ The Node.js binary was found at: /usr/local/bin/node</span><br><span class="line">info AppiumDoctor  ✔ Node version is 7.10.0</span><br><span class="line">info AppiumDoctor  ✔ Xcode is installed at: /Applications/Xcode.app/Contents/Developer</span><br><span class="line">WARN AppiumDoctor  ✖ Xcode Command Line Tools are NOT installed!</span><br><span class="line">info AppiumDoctor  ✔ DevToolsSecurity is enabled.</span><br><span class="line">info AppiumDoctor  ✔ The Authorization DB is set up properly.</span><br><span class="line">WARN AppiumDoctor  ✖ Carthage was NOT found!</span><br><span class="line">info AppiumDoctor  ✔ HOME is set to: /Users/tobyqin</span><br><span class="line">info AppiumDoctor  ✔ ANDROID_HOME is set to: /Users/tobyqin/Library/Android/sdk/</span><br><span class="line">info AppiumDoctor  ✔ JAVA_HOME is set to: /Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home</span><br><span class="line">info AppiumDoctor  ✔ adb exists at: /Users/tobyqin/Library/Android/sdk/platform-tools/adb</span><br><span class="line">info AppiumDoctor  ✔ android exists at: /Users/tobyqin/Library/Android/sdk/tools/android</span><br><span class="line">info AppiumDoctor  ✔ emulator exists at: /Users/tobyqin/Library/Android/sdk/tools/emulator</span><br><span class="line">info AppiumDoctor  ✔ Bin directory of $JAVA_HOME is set</span><br><span class="line">info AppiumDoctor ### Diagnostic completed, 2 fixes needed. ###</span><br><span class="line">info AppiumDoctor</span><br><span class="line">info AppiumDoctor ### Manual Fixes Needed ###</span><br><span class="line">info AppiumDoctor The configuration cannot be automatically fixed, please do the following first:</span><br><span class="line">WARN AppiumDoctor - Please install Carthage. Visit https://github.com/Carthage/Carthage#installing-carthage for more information.</span><br><span class="line">info AppiumDoctor ###</span><br><span class="line">info AppiumDoctor</span><br><span class="line">info AppiumDoctor Bye! Run appium-doctor again when all manual fixes have been applied!</span><br></pre></td></tr></table></figure><p>其实你不一定需要把通过所有检查项，如果只是为了完成Android的Appium测试，只要确保ANDROID_HOME 和 JAVA_HOME 正确配置，另外SDK Tools 和Platform Tools都加入PATH就基本完成了。可以参考我个人目录下的.bash_profile设置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ANDROID_HOME=~/Library/Android/sdk/</span><br><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home</span><br><span class="line"></span><br><span class="line">export PATH=~/bin:$PATH:/usr/local/bin:$ANDROID_HOME/platform-tools/:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><h2 id="开始编写自动化测试"><a href="#开始编写自动化测试" class="headerlink" title="开始编写自动化测试"></a>开始编写自动化测试</h2><p>终于到了开始写代码的时候了，相信你已经迫不及待了，别急，你还要准备以下条件：</p><ol><li>模拟器或者测试机必须是Ready的状态，每次启动模拟器都很费时间，所以建议模拟器不要关闭，通过代码来启动模拟器是一个办法，但是时间成本有点高。</li><li>如果是调试代码阶段，建议保持Appium桌面版长期运行，但是Appium和uiautomator有冲突，只能二选一。</li><li>Appium会根据你的测试代码去寻找符合要求的设备，如果你启动了多台虚拟机或者连接了多台实体机，请显式地在代码中指定设备名称或者版本号。</li></ol><p>自动化测试代码例子如下，启动内置拨号软件，搜索关键字。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">desired_caps = &#123;&#125;</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'7.1.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'Android Emulator'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.dialer'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'DialtactsActivity'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">driver.find_element_by_id(<span class="string">'com.android.dialer:id/search_box_collapsed'</span>).click()</span><br><span class="line">search_box = driver.find_element_by_id(<span class="string">'com.android.dialer:id/search_view'</span>)</span><br><span class="line">search_box.click()</span><br><span class="line">search_box.send_keys(<span class="string">'hello toby'</span>)</span><br></pre></td></tr></table></figure><p>恭喜你，解锁了移动应用测试的新成就！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="/posts/2017-05-03/setup-appium-automation-test-environment/">在 Windows 下搭建 Appium + Android 自动化测试环境</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> appium </tag>
            
            <tag> mac </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Python优雅地处理时间数据</title>
      <link href="posts/2017-09-26/excellent-python-time-ultility-arrow/"/>
      <url>posts/2017-09-26/excellent-python-time-ultility-arrow/</url>
      
        <content type="html"><![CDATA[<p>Python处理时间数据的好方法。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>很多时候我们不得不和时间打交道，但在Python标准库中处理时间的模块其实设计的不是很友好，为什么我会这么说？因为我相信大部分人几乎每次在处理时间数据时一而再，再而三的去查文档，比如时间和文本格式互转，时间增减等看起来非常基本的操作，在Python中处理起来并不轻松。</p><p>最要命的是，在Python标准库中居然有两个名字差不多的模块可以处理时间，一个叫time，另外一个叫datetime，里面提供了类似的方法但是两个完全不是一回事。到这还没完，标准库里还有一个叫calendar的模块，也是用来处理时间的。你是不是纠结到底该用哪一个？</p><p>今天我不带大家去理解他们三者的关系，因为现在你记住了不代表你以后不会忘记。今天的主角是一个优雅到我不能放弃的时间处理库 - arrow。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>arrow是一个专门处理时间和日期的轻量级Python库，它提供了一种<strong>合理、智能</strong>的方式来创建、操作、格式化、转换时间和日期。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install arrow</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们直接看代码，注释既分割线。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> arrow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = arrow.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2017</span><span class="number">-05</span><span class="number">-11</span>T21:<span class="number">23</span>:<span class="number">58.970460</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc = utc.shift(days=+<span class="number">1</span>, hours=<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc</span><br><span class="line">&lt;Arrow [<span class="number">2017</span><span class="number">-05</span><span class="number">-12</span>T20:<span class="number">23</span>:<span class="number">58.970460</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc.replace(hour=<span class="number">4</span>, minute=<span class="number">40</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2017</span><span class="number">-05</span><span class="number">-12</span>T04:<span class="number">40</span>:<span class="number">58.970460</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换时区</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local = utc.to(<span class="string">'US/Pacific'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local</span><br><span class="line">&lt;Arrow [<span class="number">2017</span><span class="number">-05</span><span class="number">-11</span>T13:<span class="number">23</span>:<span class="number">58.970460</span><span class="number">-07</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文本转为时间对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(<span class="string">'2017-05-11T21:23:58.970460+00:00'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2017</span><span class="number">-05</span><span class="number">-11</span>T21:<span class="number">23</span>:<span class="number">58.970460</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(<span class="number">1367900664</span>)</span><br><span class="line">&lt;Arrow [<span class="number">2017</span><span class="number">-05</span><span class="number">-07</span>T04:<span class="number">24</span>:<span class="number">24</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arrow.get(<span class="string">'June was born in May 1980'</span>, <span class="string">'MMMM YYYY'</span>)</span><br><span class="line">&lt;Arrow [<span class="number">1980</span><span class="number">-05</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取时间戳</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local.timestamp</span><br><span class="line"><span class="number">1368303838</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local.format()</span><br><span class="line"><span class="string">'2017-05-11 13:23:58 -07:00'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local.format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>)</span><br><span class="line"><span class="string">'2017-05-11 13:23:58'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>local.humanize()</span><br><span class="line"><span class="string">'an hour ago'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为标准库对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.date()</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.time()</span><br><span class="line">datetime.time(<span class="number">4</span>, <span class="number">38</span>, <span class="number">15</span>, <span class="number">447644</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>arrow是不是很智能很易用？如果以后你的Python项目需要处理时间，请果断抛弃标准库，arrow将拯救你无数脑细胞。</p><p>附上arrow官方文档，更多酷炫用法还是前往官网。</p><ul><li><a href="http://arrow.readthedocs.io/en/latest/" target="_blank" rel="noopener">http://arrow.readthedocs.io/en/latest/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> arrow </tag>
            
            <tag> datetime </tag>
            
            <tag> pypi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让你的项目模板化和专业化 - Cookiecutter</title>
      <link href="posts/2017-08-16/cookiecutter-intro/"/>
      <url>posts/2017-08-16/cookiecutter-intro/</url>
      
        <content type="html"><![CDATA[<p>如果快速应用优秀模板或者框架到你的项目？</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Cookiecutter英文的意思大概是饼干模型这么一类东西，可以让你快速做出某种形状的饼干。实际上你在google搜索到的cookiecutter是一个托管在GitHub的开源项目。</p><ul><li><a href="https://github.com/audreyr/cookiecutter" target="_blank" rel="noopener">https://github.com/audreyr/cookiecutter</a></li></ul><p>这是一个就算你不用也应该了解的工具，cookiecutter可以让你快速从各种模板中建立工程，这个项目本身是python写的，但是支持的模板跨越了多种语言和各种领域，看图说话。</p><p><img src="https://tobyqin.github.io/images/cookiecutter-categories.png" alt="cookiecutter-categories"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这是一个命令行工具，需要python支持，所以你要确保python已经正确安装，版本可以是2.x或者3.x。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U cookiecutter</span><br></pre></td></tr></table></figure><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><p>首先你要确定新建的项目是何种类型，这是一个很严肃的问题。一般IDE会提供新建项目的功能，为什么我们还要cookiecutter？此新建非彼新建。IDE的新建项目一般指的是空项目，而cookiecutter新建的项目一般是已经有一定完成度的框架。</p><p>举一个简单例子，你可以从IDE新建一个django项目，新建的项目可以直接运行，但也仅仅是能运行。如果你从cookiecutter新建一个django项目你可以有很多选择，比如是否使用bootstrap，是否集成rest framework，是否要发布到aws，是否使用docker，测试框架使用什么等等。</p><p>IDE建房子是从地基开始，cookiecutter可以帮你把架子也搭好。</p><p>第一步，确定你要新建的项目类型，假设我要新建一个使用bootstrap的flask项目。从cookiecutter的GitHub页面找到我心仪的模板 （Ctrl + F）。 </p><p>第二步，启动命令行，输入 <code>cookiecutter [template-path/url/zip]</code>，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cookiecutter https:&#x2F;&#x2F;github.com&#x2F;sloria&#x2F;cookiecutter-flask.git</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/cookiecutter-questions.png" alt="cookiecutter-flask"></p><p>第三步，按照模板预设的问题一路next，你就新建了一个标准和专业的Flask工程。</p><p><img src="https://tobyqin.github.io/images/cookiecutter-flask.png" alt="cookiecutter-flask"></p><h2 id="优点和局限"><a href="#优点和局限" class="headerlink" title="优点和局限"></a>优点和局限</h2><p>cookiecutter的主要局限来自于它的优点，太模板化的东西会导致灵活性不足。而且目前可用的各种模板质量参差不齐，不过主流的项目模板都是非常棒的，比如各种前后端框架，机器学习等等，有很多人在维护和更新。</p><p>一个框架搭到什么程度比较合适，这就不能一概而论了。</p><p>如果你要做一个Django应用，模板里默认就集成了用户注册和登录功能，有时候你觉得太棒了我刚好需要，有时候你觉得我没这样的需求，还得从新建好的项目一点一点删掉没用的代码还可能改错导致跑不起来。</p><p>其实我认为cookiecutter也是一个很好的学习渠道，使用cookiecutter新建项目你可以看到别人是如何组织代码，如何管理配置，如何管理依赖等等，比如Python写的项目，理论上你可以把代码扔在任何目录，大拿扔的好看，自己扔的就很丑。</p><p>最后再提一点，cookiecutter支持自定义模板，你也可以把自己常用的项目功能打包成模板，后续只要有重用需求，cookiecutter一下，立马开始业务功能的cooding，岂不妙哉？</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> cookiecutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xmind2testlink - 快速设计测试案例并导入TestLink</title>
      <link href="posts/2017-07-27/use-xmind-to-design-testcase/"/>
      <url>posts/2017-07-27/use-xmind-to-design-testcase/</url>
      
        <content type="html"><![CDATA[<p>前面我有介绍过思维导图和xmind，现在我们再往前一步，让生活再美好一些。</p><a id="more"></a><blockquote><p>上集回顾：<a href="https://tobyqin.github.io/posts/2017-07-26/the-power-of-mindmap/" target="_blank" rel="noopener">你听说过思维导图吗？</a></p><p>原文链接： <a href="https://tobyqin.github.io/posts/2017-07-26/the-power-of-mindmap/" target="_blank" rel="noopener">https://tobyqin.github.io/posts/2017-07-26/the-power-of-mindmap/</a></p></blockquote><p>本文我们将使用xmind设计测试案例，并导入到TestCase管理系统TestLink。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Xmind生成的思维导图以 .xmind 为扩展名，其实这本质上是一个zip压缩文件。这里略带一点小知识。</p><blockquote><p>zip这一世界通用压缩标准是美国20世纪80年代著名程序员Phil Katz 发明的。当时为了对抗商业压缩软件ARC（缺钱买不起），Philip Katz 制作出了PKZIP，因为免费而且开放，越来越多的软件都内嵌支持zip，包括Windows操作系统。</p><p>你可以使用任何一种文本编辑器打开zip文件，文件的头两个字母为 PK。</p></blockquote><p>xmind解压以后，里面主要由一些xml文件构成，解析content.xml 和 comment.xml 就可以获得思维导图的结构和主要文字内容。</p><h2 id="xmind2testlink"><a href="#xmind2testlink" class="headerlink" title="xmind2testlink"></a>xmind2testlink</h2><p>这是一个我使用Python实现对xmind进行解析的PyPI包，有了它你可以很方便地将xmind转化成其他系统使用的格式，比如TestLink。</p><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>使用pip可以快速安装xmind2testlink。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install xmind2testlink -U</span><br></pre></td></tr></table></figure><p>安装后默认就提供了命令行转换功能，可以将xmind转成可以导入testlink的xml文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmind2testlink &#x2F;path&#x2F;to&#x2F;testcase.xmind</span><br><span class="line">Generated: testcase.xml</span><br></pre></td></tr></table></figure><p>如果你想自己编程使用中间对象，可以导入xmind_parser或者testlink_parser中的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xmind2testlink.xmind_parser <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> xmind2testlink.testlink_parser <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># do your stuff</span></span><br></pre></td></tr></table></figure><h3 id="使用须知-v1"><a href="#使用须知-v1" class="headerlink" title="使用须知 v1"></a>使用须知 v1</h3><p>并不是所有的xmind都可以顺利被xmind2testlink识别，因为我是按照一定规律去分析xmind结构的，所以如果你要使用这个小工具，那么请你遵循一些简单的游戏规则。</p><p><img src="https://github.com/tobyqin/xmind2testlink/raw/master/web/static/guide/xmind2testlink_v1.png" alt="xmind2testlink_v1"></p><p>输出结果：</p><p><img src="https://github.com/tobyqin/xmind2testlink/raw/master/web/static/guide/xmind2testlink_v1_out.png" alt="xmind2testlink_v1_out"></p><p>如图，你的xmind应该和上图结构一致：</p><ol><li>默认的中心主题不会被转换，默认从第一层子主题开始转换。</li><li>第一层子主题会被识别为 TestSuite。</li><li>TestSuite 的子主题 会被识别为 TestCase。</li><li>TestCase 的下级分支为 TestStep 和 Expected Result。</li><li>你可以给 TestSuite，TestCase加上 Note，这会被识别为Summary 字段。</li><li>你可以给TestCase 加上 Comment，这会被识别为 Preconception 字段。</li><li>你可以使用数字Marker来为TestCase定义优先级。</li><li>你可以使用感叹号<code>!</code>来注释掉不想导入的任意分支。</li></ol><p>如果觉得太复杂了，可以下载示例的xmind文件（<a href="https://github.com/tobyqin/xmind2testlink/blob/master/web/static/guide/test_case_by_xmind_v1.xmind" target="_blank" rel="noopener">Test case by xmind v1.xmind</a>），看一眼就懂了。</p><h3 id="使用须知-v2"><a href="#使用须知-v2" class="headerlink" title="使用须知 v2"></a>使用须知 v2</h3><p>在使用V1的规则一段时间后，发现不是特别xmind，xmind真正强大的地方在于发散思维整理，如果按照前面的规则使用xmind，会有很大的限制，于是我升级了xmind2testlink，称之为V2。看图：</p><p><img src="https://github.com/tobyqin/xmind2testlink/raw/master/web/static/guide/xmind2testlink_v2.png" alt="xmind2testlink_v2"></p><p>输出结果：</p><p><img src="https://github.com/tobyqin/xmind2testlink/raw/master/web/static/guide/xmind2testlink_v2_out.png" alt="xmind2testlink_v2_out"></p><p>基于V1，补充的规则如下：</p><ol><li>根主题必须加上一个小星星，这是用来区分V1和V2的标识。</li><li>第一层子主题还是会被识别为 TestSuite。</li><li>之后的主题可以自由扩展，如果一个主题被标记了priority那么意味着case到此结束。</li><li>如果没有主题被标记priority，默认case取到最后一个主题。</li><li>默认使用空格连接case子主题，你可以指定其他连接符（根主题的最后一个字符）。</li><li>TestCase 的下级分支为 TestStep 和 Expected Result。</li><li>所有case子主题的Summary和Preconception会被连接起来。</li><li>你可以给 TestSuite，TestCase加上 Note，这会被识别为Summary 字段。</li><li><code>!</code>开头的所有主题都会被自动忽略，可以用来隐藏或者注释某些不想导入的内容。</li></ol><p>照旧，这里有一个示例文件（<a href="https://github.com/tobyqin/xmind2testlink/blob/master/web/static/guide/test_case_by_xmind_v2.xmind" target="_blank" rel="noopener">Test case by xmind v2.xmind</a>），看一下就明白了。其实Github上的<a href="https://github.com/tobyqin/xmind2testlink" target="_blank" rel="noopener">英文文档</a>描述更清楚一下，有能力的你还是去看一下。</p><h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>可能不是每个人都了解Python或者安装了Python，那么这是你可以将xmind2testlink部署成一个网站，步骤也非常简单。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># clone this git repo ahead</span><br><span class="line">cd &#x2F;path&#x2F;to&#x2F;xmind2testlink&#x2F;web</span><br><span class="line">pip install -r requirements.txt -U</span><br><span class="line">python application.py</span><br><span class="line"></span><br><span class="line">* Running on http:&#x2F;&#x2F;127.0.0.1:5000&#x2F; (Press CTRL+C to quit)</span><br><span class="line">* Restarting with stat</span><br></pre></td></tr></table></figure><p>这时你启动浏览器就可以看到一个web版的转换界面。</p><p><img src="https://raw.githubusercontent.com/tobyqin/xmind2testlink/master/web/static/guide/web.png" alt="xmind2testlink web"></p><p>这是一个由Flask写的简单程序，你可以将其部署到专门的服务器，详情请查阅官方文档。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实在实现一个小工具的过程中，从构思想法到实现，有很多内容和未知需要去探索。xmind2testlink 涉及到的知识点也不少，比如 PyPI 打包发布，python读取zip文件，解析xml，Flask，网站前后期，服务器部署，持续集成，单元测试等等，我个人收获不小。</p><p>如果你工作或生活也有各种想法，不如动手去做，失败了没啥大不了的，万一成功了呢。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xmind </tag>
            
            <tag> testlink </tag>
            
            <tag> QA </tag>
            
            <tag> xmind2testlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你听说过思维导图吗？</title>
      <link href="posts/2017-07-26/the-power-of-mindmap/"/>
      <url>posts/2017-07-26/the-power-of-mindmap/</url>
      
        <content type="html"><![CDATA[<p>如果你没听说过思维导图，那么你可能错过了很美妙的一个工具。不过没关系，现在了解一下也不算迟。</p><a id="more"></a><blockquote><p>思维导图又叫心智导图是表达发散性思维的有效的图形思维工具 ，它简单却又极其有效，是一种革命性的思维工具。</p></blockquote><p>名词解释大家都不爱看，所谓的思维导图其实就是类似于下面这样一张图。</p><p><img src="https://tobyqin.github.io/images/mindmap.jpg" alt="传统思维导图"></p><p>是不是觉得好复杂，徒手画图？我可没说。我们现在接触到的文档大多数都是电子化的，所以你经常看到的思维导图应该像这个样子。</p><p><img src="https://tobyqin.github.io/images/xmind-example.png" alt="电子化的思维导图"></p><p>是不是挺清晰易懂的？思维导图也叫 MindMap，脑图等等。作为一个头脑风暴的工具，灵活运用「思维导图」将会对你在学习和工作帮助甚大！上面这张思维导图就是我在分享从Python2迁移到Python3的知识点总结。</p><h2 id="思维导图有用吗"><a href="#思维导图有用吗" class="headerlink" title="思维导图有用吗"></a>思维导图有用吗</h2><p>这玩意有用吗？这是你在学习任何一个东西之前都必须弄明白的一件事。</p><p>建议阅读知乎问答：<a href="https://www.zhihu.com/question/20273625" target="_blank" rel="noopener">思维导图真的有效吗？</a>。简单总结一下：</p><ol><li>作为一种工具它当然有效，但必然有它擅长和不擅长的事</li><li>但不要高估它的价值，它不是万能的</li><li>思维导图主要用于激发思维，整理思路，系统分析等脑力劳动上</li></ol><p>举例说明它擅长的事：</p><ul><li>问题解决，项目计划，知识管理，思考写作，做笔记，项目演示，做计划</li></ul><p>缺点也提一下：</p><ul><li>结构固定，一般用于主题或者树状信息整理，不适合交互复杂的信息处理</li><li>制图费时，尤其是手动绘图，时间成本很高</li></ul><p>所以说，我们尽量用它的长处，避免用它的短处。说到绘制思维导图的学习和时间成本，其实不能一口咬死这玩意真的很难画，关键是你有没有选对工具。</p><h2 id="思维导图工具"><a href="#思维导图工具" class="headerlink" title="思维导图工具"></a>思维导图工具</h2><p>当你在电脑上使用思维导图工具绘制思维导图时，你会发现，真的很不费事，甚至是自然而然，因为你只需要记住两个快捷键：</p><ul><li>TAB - 添加子主题</li><li>ENTER - 发散思维</li></ul><p>基本上99%的思维导图软件都使用了以上两个快捷键，当你的手指放在键盘上时，你只要集中精力去整理思路，不需要去关心图是怎么画出来的。使用TAB进行大纲整理，使用ENTER添加平行内容。</p><p><img src="https://tobyqin.github.io/images/xmind-create.gif" alt="使用快捷键创建思维导图"></p><p>在这里我推荐大家尝试使用Xmind来制作思维导图，它提供免费版，跨平台而且兼容很多其他同类软件的文件格式。</p><p><img src="https://tobyqin.github.io/images/xmind-intro.jpg" alt="xmind 简介"></p><p>Xmind可谓是杀人越货，居家必备之良品，优点多多，可以用下面这张思维导图来总结。</p><p><img src="https://tobyqin.github.io/images/xmind-good.png" alt="xmind的优点"></p><p>如果你不想或者没条件在每台电脑上都装Xmind，那么网页版也有不少选择方案。我特别推荐ProcessOn和百度脑图。</p><ul><li>ProcessOn：<a href="https://www.processon.com/" target="_blank" rel="noopener">https://www.processon.com/</a></li><li>百度脑图：<a href="http://naotu.baidu.com/" target="_blank" rel="noopener">http://naotu.baidu.com/</a></li></ul><h2 id="思维导图实例"><a href="#思维导图实例" class="headerlink" title="思维导图实例"></a>思维导图实例</h2><p>思维导图主要还是用于思维发散或者思路整理，我举一些我在实际工作中用到思维导图的例子。</p><h3 id="做工作计划"><a href="#做工作计划" class="headerlink" title="做工作计划"></a>做工作计划</h3><p>思维导图非常适合做规划类的事情，因为规划需要有条理和步骤，需要细化和调整。当你用Xmind做好一个初步计划后，可以通过鼠标去拖动子项目来调整顺序优先级，并且还可以添加一些图标来标注状态或者优先级，例如下图。</p><p><img src="https://tobyqin.github.io/images/xmind-plan.png" alt="xmind 做计划"></p><h3 id="做知识梳理"><a href="#做知识梳理" class="headerlink" title="做知识梳理"></a>做知识梳理</h3><p>当你需要做读书笔记或者归纳总结知识点时，思维导图也十分有效。下图是我开始学习Python后做的思维导图，里面包含了读书笔记和经验总结，通过思维导图我能很方便的回顾各个知识点，查缺补漏。</p><p><img src="https://tobyqin.github.io/images/xmind-learn-python.png" alt="xmind 做知识梳理"></p><h3 id="协助软件开发"><a href="#协助软件开发" class="headerlink" title="协助软件开发"></a>协助软件开发</h3><p>软件开发过程中你需要了解业务，设计模型，整理API，其实思维导图也是一个不错的帮手。<br><img src="https://tobyqin.github.io/images/xmind-design-app.png" alt="xmind 协助软件开发"></p><h3 id="设计测试案例"><a href="#设计测试案例" class="headerlink" title="设计测试案例"></a>设计测试案例</h3><p>不知道你发现没有，其实设计测试案例（TestCase Desgin）其实就是发散思维的一个典型应用。作为测试人员你需要尽可能多的考虑测试路径，如果用图来表示测试案例，那么其实就是一棵树，树的根节点就是你要测试的功能，发散出来的分支就是你要考虑的各种情况。用思维导图来设计测试案例再合适不过。</p><p><img src="https://tobyqin.github.io/images/test_case_by_xmind.png" alt="xmind 设计测试案例"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>写到这应该收尾了，如果你对思维导图感兴趣，不如现在就动手起来，应用到你的生活或者工作中去，实践才是检验真理的唯一办法。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xmind </tag>
            
            <tag> ideas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows UI自动化测试的XPATH实现 - WPATH</title>
      <link href="posts/2017-07-23/xpath-for-windows-desktop-ui-automation---wpath/"/>
      <url>posts/2017-07-23/xpath-for-windows-desktop-ui-automation---wpath/</url>
      
        <content type="html"><![CDATA[<p>从事Windows 桌面应用自动化测试也有一些年了，现在谈这个话题并不流行。</p><a id="more"></a><p>因为除了企业级应用，很少有公司会只选择Windows桌面作为目标用户平台，一般都会考虑跨平台的浏览器解决方案，桌面应用的地位渐渐下降，这是事实。</p><p>当年初入测试行业时就被外包公司看上了，在微软的圈子里一待就是4年，时间真快。不得不说，一个大学刚毕业的毛头小子看到微软里各种技术和工具真像极了刘姥姥进大观园，那时候还没有iPhone，也没有Android，微软一统天下。</p><p>本文主要介绍一下我对Windows UI自动化的一些看法以及WPATH的实现和应用，如果你还在从事Windows桌面应用的自动化测试，应该能有一些帮助。</p><h2 id="为何发明WPATH"><a href="#为何发明WPATH" class="headerlink" title="为何发明WPATH"></a>为何发明WPATH</h2><p>Windows UI 自动化，顾名思义就是在Windows平台实现软件的界面自动化，比如自动打开Excel填入一些数据，输入公式，获取结果。正经的用途就是软件自动化测试，避免重复的手工操作；不正经的用途就是写外挂，各种投机取巧的工具等等。</p><p>最简单粗暴的实现方案就是录制回放，优点很明显，简单快速；缺点也一样明显，不可靠因素太多。主要的代表就是QTP，来自HP公司，这应该是很多同学都听过的一款测试工具。</p><p>进阶的方案就是使用微软提供的自动化工具集：<a href="https://docs.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-overview" target="_blank" rel="noopener">UI Automation</a>。UI Automation是Microsoft .NET 3.0框架下提供的一种用于自动化测试的技术，是在MSAA基础上建立的，MSAA就是Microsoft Active Accessibility。</p><p>如果你使用过.NET 提供的UI Automation相关的类库，应该有一个直观的感受，就是非常啰嗦，举一个例子：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">AutomationElement ControlTypeComboBox = grdClassBook.FindFirst(</span><br><span class="line">  TreeScope.Children,</span><br><span class="line">  <span class="keyword">new</span> PropertyCondition(AutomationElement.ControlTypeProperty, ControlType.ComboBox));</span><br><span class="line"></span><br><span class="line">AutomationElement cellElement = ControlTypeComboBox.FindFirst(</span><br><span class="line">  TreeScope.Children,</span><br><span class="line">  <span class="keyword">new</span> PropertyCondition(AutomationElement.AutomationIdProperty, <span class="string">"ListBox"</span>));</span><br></pre></td></tr></table></figure><p>每当你尝试去获取一个UI元素时，都需要使用<code>FindFirst</code>之类的方法去查询指定的<code>PropertyCondition</code>，而<code>PropertyCondition</code>使用起来也不简单，特别是当你需要拼接多个AND或者OR多个条件时。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btnCondition = <span class="keyword">new</span> AndCondition(</span><br><span class="line">  <span class="keyword">new</span> PropertyCondition(AutomationElement.ControlTypeProperty, ControlType.Button),</span><br><span class="line">  <span class="keyword">new</span> PropertyCondition(AutomationElement.NameProperty, <span class="string">"ok"</span>));</span><br></pre></td></tr></table></figure><p>才两个条件就这么多代码了？你看看搞Web自动化的同学都可以用XPATH，快速定位和查询元素 <code>/div[@id=&#39;ok&#39;]</code>，多好。既然我们那么羡慕XPATH，那我们就搞一个出来，让做Windows桌面自动化的同学也可以High一把。</p><h2 id="WPATH实现原理"><a href="#WPATH实现原理" class="headerlink" title="WPATH实现原理"></a>WPATH实现原理</h2><p>具体代码我就不在此展开，想刨根的同学可以直接移步至Github：<a href="https://github.com/tobyqin/wpath。" target="_blank" rel="noopener">https://github.com/tobyqin/wpath。</a></p><p>WPATH的主要原理就是通过反射的方式去获取当前方法或者属性的Attribute，在Attribute中我们可以定义类似于XPATH的语法，我 且称之为WPATH。最后经过表达式解析转换成对应的Find方法和Condition，举一个例子说明：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">WPath(<span class="meta-string">"/Edit[@id='txtId' or @Class='TextBox']"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> AutomationElement EditControl</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.AppElement.FindByWPath(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>FindByWPath()</code>时，该属性上的WPath Attribute就会被解析出来，其中的 <code>/</code>会被解析成FindFirst，<code>Edit</code>会被解析成ControlType.Edit，中括号里的条件最后被组合起来，调用的最终结果大致如下：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AutomationElement EditControl</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.AppElement.FindFirst(TreeScope.Children,</span><br><span class="line">       <span class="keyword">new</span> AndCondition(</span><br><span class="line">          <span class="keyword">new</span> PropertyCondition(AutomationElement.ControlTypeProperty, ControlType.Edit),</span><br><span class="line">          <span class="keyword">new</span> OrCondition(</span><br><span class="line">            <span class="keyword">new</span> PropertyCondition(AutomationElement.AutomationId, <span class="string">"txtId"</span>),</span><br><span class="line">            <span class="keyword">new</span> PropertyCondition(AutomationElement.Class, <span class="string">"TextBox"</span>))));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 痛苦的感觉一下减轻许多，有没有？</p><h2 id="更详细的WPATH用法"><a href="#更详细的WPATH用法" class="headerlink" title="更详细的WPATH用法"></a>更详细的WPATH用法</h2><p>如果你要在项目中使用WPATH，可以通过nuget包安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PM&gt; Install-Package WPath</span><br></pre></td></tr></table></figure><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><ol><li>WPath 和 XPath 类似，以 ‘/‘ 开头。</li><li>可以使用多个 ‘/‘ 来定位目标元素。</li><li>节点名字来自于MSDN定义好的 <a href="https://docs.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-control-types" target="_blank" rel="noopener">control type</a>。</li><li>目前WPath支持的查询属性如下:</li></ol><ul><li><code>Name</code> (NameProperty)</li><li><code>ID</code> (AutomationIdProperty)</li><li><code>Class</code> (ClassNameProperty)</li><li><code>Enabled</code> (IsEnabledProperty)</li><li><code>FrameworkID</code> (FrameworkIdProperty)</li></ul><h3 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h3><blockquote><p><code>/Group/Button</code></p></blockquote><ul><li>获取第一个Group下的第一个Button。</li></ul><blockquote><p><code>//Button[@Name=&#39;Save&#39;]</code></p></blockquote><ul><li>在子孙节点中获取第一个Name为 “Save” 的元素。</li></ul><blockquote><p><code>/[@Name=&#39;TabContainer&#39;]/Button[2]</code></p></blockquote><ul><li>获取Name为 “TabContainer”的控件下的第二个Button，注意，控件类型名称可以为空。</li></ul><blockquote><p><code>/Button[@ID=&#39;AddButton&#39; and @Name=&#39;Add&#39;]</code></p></blockquote><ul><li>获取一个automation ID 为 ‘AddButton’ <strong>且</strong> name 为 ‘Add’ 的Button。</li></ul><blockquote><p><code>/Button[@ID=&#39;AddButton&#39; or @Name=&#39;Add&#39;]</code></p></blockquote><ul><li>获取一个automation ID 为 ‘AddButton’ <strong>或</strong> name 为’Add’的Button。</li></ul><blockquote><p><code>/Button[first()]</code></p></blockquote><ul><li>获取当前元素下第一个Button。</li></ul><blockquote><p><code>/Button[last()]</code></p></blockquote><ul><li>获取当前元素下最后一个Button。</li></ul><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>推荐使用Attribute的方式进行调用，可用于类方法或者属性。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">WPath(<span class="meta-string">"/Edit[@id='txtId' or @Class='TextBox']"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> AutomationElement EditControl</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.AppElement.FindByWPath(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">WPath(<span class="meta-string">"/Button[first()]"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> AutomationElement <span class="title">GetFirstButton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.AppElement.FindByWPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接调用 <code>FindByWPath(path)</code> 来定位目标元素。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="string">"/Edit[3]"</span>;</span><br><span class="line"><span class="keyword">var</span> e = <span class="keyword">this</span>.AppElement.FindByWPath(path);</span><br><span class="line">Assert.AreEqual(<span class="string">"txtKey"</span>, e.Current.AutomationId);</span><br><span class="line">Assert.AreEqual(ControlType.Edit, e.Current.ControlType);</span><br><span class="line"></span><br><span class="line">path = <span class="string">"/Button[@name='OK']/Text[1]"</span>;</span><br><span class="line">e = <span class="keyword">this</span>.AppElement.FindByWPath(path);</span><br><span class="line">Assert.AreEqual(<span class="string">"OK"</span>, e.Current.Name);</span><br><span class="line">Assert.AreEqual(ControlType.Text, e.Current.ControlType);</span><br></pre></td></tr></table></figure><h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3><ul><li>元素类型节点是大小写不敏感的，比如：<ul><li>@name = @Name</li><li>/edit = /Edit</li></ul></li><li>父节点定位 <code>../</code> 目前不支持，因为有点复杂。</li></ul><p>更多的说明建议还是去看Github中的说明文档，或者直接看<a href="https://github.com/tobyqin/wpath/blob/master/WPath.Tests/UnitTests.cs" target="_blank" rel="noopener">单元测试</a>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>Windows UI 自动化的坑还是挺深的，填坑的人也不少，我推荐有需要的同学去学习和了解一下 <a href="https://github.com/TestStack/White" target="_blank" rel="noopener">White</a>。White是一个非常好UI Automation 封装框架，相信我，能省下你不少时间。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows UIAutomation </tag>
            
            <tag> XPATH </tag>
            
            <tag> WPATH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款优秀的代码高亮库 - rainbow.js</title>
      <link href="posts/2017-07-17/rainbow-js-highlight-lib/"/>
      <url>posts/2017-07-17/rainbow-js-highlight-lib/</url>
      
        <content type="html"><![CDATA[<p>介绍一个优秀的js库。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>代码高亮的js库也不少，最知名的莫过于 <a href="https://highlightjs.org/" target="_blank" rel="noopener">highlightjs</a>，支持你听过的没听过的各种编程语言，兼容你用过没用过的各种浏览器，有着多姿多彩的配色方案。然而，唯有一点我还是选择放弃了它，因为它不能很方便的自定义高亮语言。</p><p>现在我的需求是是这样的，有一个自动化测试结果的页面，里面会显示一个测试案例运行的数据，比如控制台输出 stdout， 我需要高亮控制台输出的一些信息，例如：INFO 级别是默认色，WARN 级别是橙色，ERROR 级别是红色。一句话，我需要自定义日志输出高亮。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">2017-07-14 11:53:55,668 INFO   : Go to my account page</span><br><span class="line">2017-07-14 11:53:58,071 DEBUG  : Now check: MyAccountPage</span><br><span class="line">2017-07-14 11:53:59,804 WARNING: Page loaded time &gt; 2000 ms</span><br><span class="line">2017-07-14 11:54:01,535 ERROR  : Test failed!!!</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>像这样的需求使用 highlightjs 来实现就显得不够灵活，甚至有点无从下手。</p><h2 id="初试-RainbowJS"><a href="#初试-RainbowJS" class="headerlink" title="初试 RainbowJS"></a>初试 RainbowJS</h2><blockquote><p>RainbowJS 项目地址： <a href="https://github.com/ccampbell/rainbow" target="_blank" rel="noopener">https://github.com/ccampbell/rainbow</a></p></blockquote><p>RainbowJS 虽然简单而且支持的编程语言也不多（压缩后大小只有不到3kb），但是恰恰能满足自定义高亮的需求。入门只需要三步即可：</p><h3 id="1-导入配色文件-css"><a href="#1-导入配色文件-css" class="headerlink" title="1. 导入配色文件 - css"></a>1. 导入配色文件 - css</h3><p>官方的github 仓库里提供了 20 多种配色，常见主题配色都可以找到。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/rainbow/css/theme.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-使用-lt-pre-gt-lt-code-gt-包住你的代码"><a href="#2-使用-lt-pre-gt-lt-code-gt-包住你的代码" class="headerlink" title="2. 使用 &lt;pre&gt;&lt;code&gt; 包住你的代码"></a>2. 使用 <code>&lt;pre&gt;&lt;code&gt;</code> 包住你的代码</h3><p>在 <code>code</code> 标签里你可以使用<code>data-language</code> 指定代码语言。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">data-language</span>=<span class="string">"python"</span>&gt;</span>def openFile(path):</span><br><span class="line">    file = open(path, "r")</span><br><span class="line">    content = file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    return content<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-开始高亮你的代码"><a href="#3-开始高亮你的代码" class="headerlink" title="3. 开始高亮你的代码"></a>3. 开始高亮你的代码</h3><p>如果整个过程是同步的，那么你只需要在页面最后导入RainbowJS和你需要的高亮语言库，就可以自动高亮代码块。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/rainbow.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/language/generic.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/language/python.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你的代码块是异步生成的，你可以选择提前引入Rainbow及相关语言的js文件，然后调用<code>Rainbow.color()</code>方法来给代码块着色。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load rainbow js and language support</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// call your function to generate dyanmc code blocks</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// finally, highligh your code blocks</span></span><br><span class="line">Rainbow.color();</span><br><span class="line"><span class="comment">// optionally, you can pass in a callback function in color()</span></span><br><span class="line"><span class="comment">// for example:</span></span><br><span class="line">Rainbow.color(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The new blocks are now highlighted!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="高亮自定义语言"><a href="#高亮自定义语言" class="headerlink" title="高亮自定义语言"></a>高亮自定义语言</h2><p>从前面的例子可以看到rainbow的上手还是很简单的，如果要自定义高亮规则应该怎么办？非常简单，只要调用<code>extend</code>方法即可。比如给<code>True</code>，<code>False</code>，<code>None</code>添加<code>constant</code>的css类：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Rainbow.extend(<span class="string">'python'</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'constant'</span>,</span><br><span class="line">        pattern: <span class="regexp">/True|False|None/g</span></span><br><span class="line">    &#125;</span><br><span class="line">], <span class="string">'generic'</span>);</span><br></pre></td></tr></table></figure><p>用<code>extend</code>方法可以给指定语言添加高亮规则，规则的名字就是即将添加的css类的名字，只要匹配了规则中指定的正则表达式，RainbowJS就会给匹配的结果添加上对应的css类。</p><p>接下来我们要给log添加高亮规则，为了避免去写新的css类，我们可以重用主题配色里已经存在的类，根据主题颜色我们暂定高亮规则如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. debug - 灰色 - css: comment</span><br><span class="line">2. info  - 白色 - css: support</span><br><span class="line">3. warn  - 橙色 - css: string</span><br><span class="line">4. error - 红色 - css: keyword</span><br><span class="line">5. 时间日期格式 - 灰色 - css: comment</span><br></pre></td></tr></table></figure><p>对应的extend实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.js</span></span><br><span class="line">Rainbow.extend(<span class="string">'log'</span>, [</span><br><span class="line">    <span class="comment">// debug level</span></span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'comment'</span>,</span><br><span class="line">        pattern: <span class="regexp">/([^ ]*debug).*/gi</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// info level</span></span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'support.tag'</span>,</span><br><span class="line">        pattern: <span class="regexp">/([^ ]*info).*/gi</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// warn level</span></span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'string'</span>,</span><br><span class="line">        pattern: <span class="regexp">/([^ ]*warn).*/gi</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error level</span></span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'keyword'</span>,</span><br><span class="line">        pattern: <span class="regexp">/([^ ]*error[^(]).*|([^ ]*fatal).*|([^ ]*failure).*|([^ ]*failed).*|([^ ]*exception[^(]).*/gi</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// time format</span></span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'comment'</span>,</span><br><span class="line">        pattern: <span class="regexp">/\b([\d\-:,]+)\b/gi</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">], <span class="string">'python'</span>);</span><br></pre></td></tr></table></figure><p>当log行正确匹配后就会被添加上对应规则的css类，并且所有高亮规则继承自python语言，因为我的log是从python程序中记录的，当中可能会有一些python代码，我希望这些代码也能正常被着色。</p><p>最后就是在网页中生成对应的代码块，指定高亮语言为log：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">data-language</span>=<span class="string">"log"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">2017-07-14 11:53:55,668 INFO   : Go to my account page</span><br><span class="line">2017-07-14 11:53:58,071 DEBUG  : Now check: MyAccountPage</span><br><span class="line">2017-07-14 11:53:59,804 WARNING: Page loaded time &gt; 2000 ms</span><br><span class="line">2017-07-14 11:54:01,535 ERROR  : Test failed!!!</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://tobyqin.github.io/images/log-highlight.png" alt="自定义Log高亮"></p><h2 id="一些改进方法"><a href="#一些改进方法" class="headerlink" title="一些改进方法"></a>一些改进方法</h2><p>在页面中加载多个js文件的写法挺不方便也不好维护，而且也会影响页面加载的速度。比如上文的例子中如果是直接把<code>&lt;script&gt;</code>片段写到页面里会是这个样子。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> /&gt;</span><span class="tag">&lt;<span class="name">code</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/rainbow.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/language/generic.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/language/python.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/language/log.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个改进的建议是就是当页面加载完成后再加载RainbowJS，然后调用高亮函数，你可以这样写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// page html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(highlightLog);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ app.js</span></span><br><span class="line"><span class="regexp">function highlightLog()&#123;</span></span><br><span class="line"><span class="regexp">    $.getScript('/</span>libs/rainbow/rainbow.min.js<span class="string">', function () &#123;</span></span><br><span class="line"><span class="string">        $.getScript('</span>/libs/rainbow/language/generic.js<span class="string">', function () &#123;</span></span><br><span class="line"><span class="string">            $.getScript('</span>/libs/rainbow/language/python.js<span class="string">', function () &#123;</span></span><br><span class="line"><span class="string">                $.getScript('</span>/libs/rainbow/language/log.js<span class="string">', function () &#123;</span></span><br><span class="line"><span class="string">                    Rainbow.color();</span></span><br><span class="line"><span class="string">                    &#125;);</span></span><br><span class="line"><span class="string">                &#125;);</span></span><br><span class="line"><span class="string">            &#125;);</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br></pre></td></tr></table></figure><p>虽然有点丑，但是功能没问题。如果你使用的是比较流行的<a href="http://www.requirejs.org/" target="_blank" rel="noopener">requirejs</a>，那么可以这样使用RainbowJS：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.js</span></span><br><span class="line">requirejs.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'/libs'</span>,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        rainbow: &#123;</span><br><span class="line">            exports: <span class="string">'Rainbow'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        rainbow_generic: &#123;</span><br><span class="line">            deps: [<span class="string">'rainbow'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        rainbow_python: &#123;</span><br><span class="line">            deps: [<span class="string">'rainbow_generic'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        rainbow_log: &#123;</span><br><span class="line">            deps: [<span class="string">'rainbow_python'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        rainbow: <span class="string">'rainbow/rainbow'</span>,</span><br><span class="line">        rainbow_generic: <span class="string">'rainbow/language/generic'</span>,</span><br><span class="line">        rainbow_python: <span class="string">'rainbow/language/python'</span>,</span><br><span class="line">        rainbow_log: <span class="string">'rainbow/language/log'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">highlightLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'rainbow'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">Rainbow</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.Rainbow = Rainbow; <span class="comment">// must</span></span><br><span class="line">        <span class="built_in">require</span>([<span class="string">'rainbow_log'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            Rainbow.color();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// page embeded</span></span><br><span class="line">&lt;script src=<span class="string">"/require.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    require(['/config.js'], function () &#123;</span></span><br><span class="line"><span class="regexp">        require(['app'], function (app) &#123;</span></span><br><span class="line"><span class="regexp">            app.highlightLog();</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>再或者先通过js的压缩和打包工具将写好的代码进行优化，亦是目前比较流行和推荐的做法。本文旨在介绍和使用RainbowJS，不做过多拓展，希望对你有所启发和帮助。</p><p>如果需要完整的演示代码，可以查看我得GitHub项目：<a href="https://github.com/tobyqin/testcube" target="_blank" rel="noopener">https://github.com/tobyqin/testcube</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> code-highlight </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Windows 下搭建 Appium + Android 自动化测试环境</title>
      <link href="posts/2017-05-03/setup-appium-automation-test-environment/"/>
      <url>posts/2017-05-03/setup-appium-automation-test-environment/</url>
      
        <content type="html"><![CDATA[<p>Appium是移动端自动化测试的必学内容。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来并不打算写这么一篇文章，但是实践下来发现网上的各种教程里大致有两个问题。一是文章有些跟不上时代，目前android开发和测试的技术更新都比较快，内容有些过期。二是细节部分不是太完整，拼拼凑凑也能完成，但对新手来说就比较痛苦。那么，我也来试着总结一下自己踩过的坑。</p><p><strong>备注：</strong>Android自动化测试环境和开发环境并不完全相同，测试环境可以很简单粗暴，很多工具可以不用安装，比如JDK，SDK Tools，测试脚本用C#，Python都可以完成；但是开发环境一般都是需要JDK和不少编译工具。</p><h2 id="实践平台"><a href="#实践平台" class="headerlink" title="实践平台"></a>实践平台</h2><p>Windows 10 Pro 64bit + Python 3.5.3</p><h2 id="安装-JAVA-环境"><a href="#安装-JAVA-环境" class="headerlink" title="安装 JAVA 环境"></a>安装 JAVA 环境</h2><p>如果只是自动化测试用，安装JRE就可以了，如果需要开发或者调试APK，那么请安装JDK。</p><ol><li>JRE = JVM + Java SE 标准类库，相当于Java程序最基本的运行环境。</li><li>JDK = JRE + 开发工具集，包括javac编译工具等等。</li></ol><p>JRE只有50多MB，JDK则接近200MB，请前往<a href="https://www.java.com/en/download/" target="_blank" rel="noopener">Java官网</a>下载最新版安装，选择64位。</p><h2 id="安装-Android-Studio-SDK"><a href="#安装-Android-Studio-SDK" class="headerlink" title="安装 Android Studio / SDK"></a>安装 Android Studio / SDK</h2><p>以前的教程里都会让你去装 Android SDK，但现在你从Google或者Bing里很难搜索到 Android SDK的下载链接，因为目前<a href="https://developer.android.com" target="_blank" rel="noopener">官网</a>推荐的做法有两个：</p><ol><li>安装Android Studio （包含 Android SDK） – 推荐</li><li>仅安装Android SDK 命令行工具</li></ol><p>新版本的Android SDK和以前也不太一样，以前我们有一个 SDK Manager.exe 的工具用于更新和下载各版本的API，还有一个 AVD Manager.exe 的工具可以模拟各种型号的安卓设备。最新的 SDK 工具把UI 界面基本都去掉了，只留下命令行工具，具体的使用可以参阅官方文档：</p><ul><li><a href="https://developer.android.com/studio/releases/sdk-tools.html" target="_blank" rel="noopener">https://developer.android.com/studio/releases/sdk-tools.html</a></li></ul><p>那么多一事不如少一事，我建议推荐你直接安装Android Studio，这样不仅省事，而且万一你想写个App玩玩，也是极其方便的。</p><p><img src="https://tobyqin.github.io/images/android-sdk-download.png" alt="android-sdk-download"></p><p>下载地址：<a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">https://developer.android.com/studio/index.html</a></p><p>安装过程非常简单，双击后一路Next，中间你也可以另外指定SDK的安装目标路径（不建议修改）。安装好之后，直接启动 Android Studio，首先会提示你联网下载一些必要的工具（你需要一个好的网络和梯子）。</p><p>一切就绪后，你可以在启动界面就可以打开 SDK Manager。</p><p><img src="https://tobyqin.github.io/images/sdk-manager-from-launch.png" alt="sdk-manager-from-launch"></p><p>或者新建一个工程，从工程界面打开SDK Manager。</p><p><img src="https://tobyqin.github.io/images/sdk-manager-from-project.png" alt="sdk-manager-from-project"></p><p>SDK Manager 打开之后，使用的方法就一目了然了。这就是个让你更新API和各种开发工具的工具。</p><p><img src="https://tobyqin.github.io/images/sdk-manager-usage.png" alt="sdk-manager-usage"></p><p>如果只是为了自动化测试其实你只要记住SDK安装目录就可以了，不需要安装任何多余的工具。SDK的安装目录在配置环境变量时需要用到。</p><p>如果你的网络不畅通，那么需要先设置代理。接下来才能安装你想要的SDK版本和开发者工具。</p><h2 id="安装-Android-模拟器"><a href="#安装-Android-模拟器" class="headerlink" title="安装 Android 模拟器"></a>安装 Android 模拟器</h2><p>如果你已经安装了Android Studio，模拟器也已经有了，从工程界面找到AVD Manager的按钮，按照下图三个步骤就可以添加并启动一个模拟器。</p><p><img src="https://tobyqin.github.io/images/avd-manager.png" alt="avd-manager"></p><p>每当你安装新版本的模拟器都是需要翻墙或者代理的，最开始启动Android Studio时它已经给你下一个最新版的Android，我当前模拟器中的Android版本是7.1.1。</p><p>如果一切顺利，那么当你启动模拟器后，你就可以看到一台虚拟的Android设备了，手动测试基本条件已经达成，自动化测试指日可待。</p><p><img src="https://tobyqin.github.io/images/android-avd-start.png" alt="android-avd-start"></p><p>多说几句，除了使用 Android SDK 自带的模拟器外，我们还有两个选择，一是使用真机，速度和体验上会更好。另外一个选择就选择别的模拟器产品，比如 <a href="">Genymotion</a>，因为是商业软件，所以对个人用户（免费）会有诸多限制，尽管如此，其成熟度也比Android SDK自带的模拟器高很多。因为这两个方案的具体实现涉及到的内容比较多，故不在本文讨论。</p><h2 id="安装-Appium"><a href="#安装-Appium" class="headerlink" title="安装 Appium"></a>安装 Appium</h2><p>Appium是开源的自动化测试框架，主要用于iOS，Android以及Windows apps等移动平台的自动化测试。官网的介绍说是它实现一套适用于移动端的WebDriver协议，所以使用Appium时用的还是依赖于Selenium，和Web自动化测试的主要区别就在Driver不一样。</p><p>举一个例子，如果我们需要用Google Chrome来跑Selenium的自动化测试，那么首先需要一个ChromeDriver。如果需要跑在IE上，那么需要一个IEDriver。那么现在需要在移动端比如Android里跑Selenium，这时候你需要一个Appium就够了，它担当了Driver的角色。Appium实现了一套标准的WebDriver，只要Appium服务起来之后，你的代码只需要和Appium交互，Appium会去告诉设备该干嘛干嘛。这里提到的设备可以是iOS或者Android，甚至是Windows Phone 和Firefox OS。</p><p>Appium 官网： <a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io/</a></p><h3 id="安装方式一：-使用NodeJS-安装"><a href="#安装方式一：-使用NodeJS-安装" class="headerlink" title="安装方式一： 使用NodeJS 安装"></a>安装方式一： 使用NodeJS 安装</h3><p>首先到<a href="">NodeJS官网</a>下载安装最新的NodeJS，Windows下属于傻瓜安装。安装好之后你可以配置NodeJS的安装源，在国内一般都用taobao的镜像，速度还不错。</p><p>在个人目录下新建一个 .npmrc 文件，写入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure><p>然后使用npm命令安装 Appium</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g appium</span><br></pre></td></tr></table></figure><p>建议顺便安装一下appium-doctor，通过运行appium-doctor命令可以快速检查appium的环境问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g appium-doctor</span><br></pre></td></tr></table></figure><p>如果安装成功，那么就可以通过 <code>appium</code> 命令启动appium server。</p><p><img src="https://tobyqin.github.io/images/appium-start.png" alt="appium-start"></p><p>关闭命令行或者按 Ctrl - C 就可以停止 Appium Server。</p><h3 id="安装方式二：-使用Appium安装包"><a href="#安装方式二：-使用Appium安装包" class="headerlink" title="安装方式二： 使用Appium安装包"></a>安装方式二： 使用Appium安装包</h3><p>网上很多教程所引导的Appium安装包一般在百度网盘或者bitbucket里，其实这两者都不是最新的。最新版的安装包应该从官网下载，Appium 目前托管在github，正确的下载地址应该为：</p><ul><li><a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a></li></ul><p>最新版的Appium 桌面安装后启动是这样的。</p><p><img src="https://tobyqin.github.io/images/appium-desktop.png" alt="appium-desktop"></p><p>功能上和老的版本没太大区别，但是日志和UI显示更加清晰，一旦错误发生让你更容易找到问题所在。</p><p><img src="https://tobyqin.github.io/images/appium-desktop-error.png" alt="appium-desktop-error"></p><p>注意，你可以不安装Appium 桌面版，但是命令行版应该还是需要安装的，因为自动化测试运行时一般都是通过命令启动和关闭Appium，桌面版并不提供命令行功能，只是为了调试方便。</p><p>关于Appium的介绍，这里有一份非常好的文档：<a href="http://appium.io/slate/cn/master" target="_blank" rel="noopener">http://appium.io/slate/cn/master</a></p><h3 id="安装-Appium-Client"><a href="#安装-Appium-Client" class="headerlink" title="安装 Appium-Client"></a>安装 Appium-Client</h3><p>本文只讨论Python实现的Appium测试，所以你只需要允许以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install Appium-Python-Client</span><br></pre></td></tr></table></figure><p>如果需要使用其他编程语言，下表供参考：</p><table><thead><tr><th>语言/框架</th><th>Github版本库以及安装指南</th></tr></thead><tbody><tr><td>Ruby</td><td><a href="https://github.com/appium/ruby_lib" target="_blank" rel="noopener">https://github.com/appium/ruby_lib</a></td></tr><tr><td>Python</td><td><a href="https://github.com/appium/python-client" target="_blank" rel="noopener">https://github.com/appium/python-client</a></td></tr><tr><td>Java</td><td><a href="https://github.com/appium/java-client" target="_blank" rel="noopener">https://github.com/appium/java-client</a></td></tr><tr><td>JavaScript (Node.js)</td><td><a href="https://github.com/admc/wd" target="_blank" rel="noopener">https://github.com/admc/wd</a></td></tr><tr><td>Objective C</td><td><a href="https://github.com/appium/selenium-objective-c" target="_blank" rel="noopener">https://github.com/appium/selenium-objective-c</a></td></tr><tr><td>PHP</td><td><a href="https://github.com/appium/php-client" target="_blank" rel="noopener">https://github.com/appium/php-client</a></td></tr><tr><td>C# (.NET)</td><td><a href="https://github.com/appium/appium-dotnet-driver" target="_blank" rel="noopener">https://github.com/appium/appium-dotnet-driver</a></td></tr><tr><td>RobotFramework</td><td><a href="https://github.com/jollychang/robotframework-appiumlibrary" target="_blank" rel="noopener">https://github.com/jollychang/robotframework-appiumlibrary</a></td></tr></tbody></table><h2 id="必要的环境变量设置"><a href="#必要的环境变量设置" class="headerlink" title="必要的环境变量设置"></a>必要的环境变量设置</h2><p>如果你已经安装了appium-doctor，那么你只要运行appium-doctor命令就可以知道你还需要设置哪些环境变量，比如：</p><p><img src="https://tobyqin.github.io/images/appium-doctor.png" alt="appium-doctor"></p><p>不要慌，其实你只需要设置以下环境变量：</p><table><thead><tr><th>环境变量</th><th>值</th></tr></thead><tbody><tr><td>ANDROID_HOME</td><td>Android SDK 的安装位置</td></tr><tr><td>JAVA_HOME</td><td>JDK 或者 JRE 的安装位置</td></tr><tr><td>加入 PATH</td><td>%ANDROID_HOME%\tools</td></tr><tr><td>加入 PATH</td><td>%ANDROID_HOME%\platform-tools</td></tr><tr><td>加入 PATH</td><td>%JAVA_HOME%\bin</td></tr><tr><td>加入 PATH</td><td>%ANDROID_HOME%\build-tools??version?? (可选)</td></tr></tbody></table><p>最后一个环境变量是为了更方便地使用aapt这个工具，完成环境变量配置后你可以再次运行appium-doctor进行检查。不出意外，你应该能通过检查。</p><h2 id="完成第一个自动化测试"><a href="#完成第一个自动化测试" class="headerlink" title="完成第一个自动化测试"></a>完成第一个自动化测试</h2><p>终于来到了动真刀真枪的时候了，很多人一开始就放弃了，更多人开始了之后就放弃了，走到这一步真的挺不容易的。</p><p>开始写代码之前有些事情你应该清楚：</p><ol><li>模拟器或者测试机必须是Ready的状态，每次启动模拟器都很费时间，所以建议模拟器不要关闭，通过代码来启动模拟器是一个办法，但是时间成本有点高。</li><li>如果是调试代码阶段，建议保持Appium桌面版长期运行，远程运行时再通过代码自动启动和关闭Appium。</li><li>Appium会根据你的测试代码去寻找符合要求的设备，如果你启动了多台虚拟机或者连接了多台实体机，请显式地在代码中指定设备名称或者版本号。</li></ol><p>第一个自动化测试需求很就简单，就是启动内置的拨号软件，搜索 “hello toby”。代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">desired_caps = &#123;&#125;</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'7.1.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'Android Emulator'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.dialer'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'DialtactsActivity'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</span><br><span class="line">driver.find_element_by_id(<span class="string">'com.android.dialer:id/search_box_collapsed'</span>).click()</span><br><span class="line">search_box = driver.find_element_by_id(<span class="string">'com.android.dialer:id/search_view'</span>)</span><br><span class="line">search_box.click()</span><br><span class="line">search_box.send_keys(<span class="string">'hello toby'</span>)</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://tobyqin.github.io/images/appium-hello.gif" alt="appium-hello"></p><p>恭喜你，你已经开始进入移动端的自动化测试的大门了！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="/posts/2017-12-10/setup-appium-test-environment-on-mac-osx/">在Mac OSX 上配置Appium+Android自动化测试环境</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> selenium </tag>
            
            <tag> appium </tag>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何开发一个 PyCharm 插件</title>
      <link href="posts/2017-04-01/steps-to-create-a-pycharm-plugin/"/>
      <url>posts/2017-04-01/steps-to-create-a-pycharm-plugin/</url>
      
        <content type="html"><![CDATA[<p>PyCharm 是很多 Python 开发者优先选择的 IDE，功能强大，跨平台，提供免费社区版，非常良心。如果你想自己给PyCharm添加一些功能怎么办呢？</p><a id="more"></a> <p>有两个办法：</p><ol><li>通过提需求实现，到 JetBrains 的 <a href="https://github.com/JetBrains/intellij-community/" target="_blank" rel="noopener">github</a> 去提issue或者自己发Pull Request请他们merge。</li><li>通过安装插件实现，你可以查找现有的<a href="https://plugins.jetbrains.com/" target="_blank" rel="noopener">插件仓库</a>，或者，自己写一个。</li></ol><p>今天我们说说怎么搭建环境自己写一个 PyCharm 插件。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>先普及一下知识，开发 PyCharm 插件和开发 IntellJ IDEA 插件需要的环境是一样的，因为 PyCharm 本身就是 IDEA 的一个子集，说白了就是 IDEA 上套了一个 Python 语言支持的插件。其他系列的 IDEA IDE 其实也是一样的道理，都是套了对应语言支持的框架外加一点外观修改，就成了新的产品，比如 WebStrom，PhpStorm，RubyMine。到这里你应该有个印象，JetBrains 这个公司太能玩了，就一个 IDEA 能整出那么多产品来，很厉害吧？</p><p><strong>开发 PyCharm 插件你需要：</strong></p><ul><li><p>对 Java  语言有一定了解，因为你只能用 Java 开发插件</p></li><li><p>安装最新版的 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a></p></li><li><p>安装 PyCharm Community Edition 到本地</p></li><li><p>确保 IntelliJ 安装并启用了 <code>Plugin DevKit</code> 插件，默认自带</p></li><li><p>配置 IntelliJ Platform SDK， 下文会涉及相关步骤</p></li><li><p>（非必需）将<a href="https://github.com/JetBrains/intellij-community/" target="_blank" rel="noopener">IntellJ IDEA Community Edition</a> 的代码克隆到本地，方便调试</p></li></ul><p>如果你英文还可以，也可以阅读官方的帮助文档。</p><ul><li><a href="http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started.html" target="_blank" rel="noopener">http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started.html</a></li></ul><h2 id="新建插件工程"><a href="#新建插件工程" class="headerlink" title="新建插件工程"></a>新建插件工程</h2><p>从文件菜单选择 <strong>New Project</strong>， 选择 <strong>IntelliJ Platform Plugin</strong>，如果你没有配置<strong>SDK</strong>，点击<strong>New</strong> 菜单。</p><p><img src="https://tobyqin.github.io/images/idea-plugin-sdk-1.png" alt="idea-plugin-sdk-1"></p><p>选择你本地 PyCharm Community Edition（社区版）的安装路径作为SDK目录，Java SDK 选择 1.8 以上的版本。</p><blockquote><p>请注意，你也可以使用 PyCharm Professional (旗舰版) 的安装路径作为SDK目录，不过当你调试插件碰到核心代码时，社区版你可以一步一步跟到最里面，但旗舰版不行，因为旗舰版并不是开源的，你拿不到源代码。</p></blockquote><p><img src="https://tobyqin.github.io/images/idea-plugin-sdk-2.png" alt="idea-plugin-sdk-2"></p><p>回到 <strong>New Project</strong> 的界面，点击 <strong>Next</strong>，输入 <strong>Project name</strong> 和 <strong>Project location</strong>，点击完成。</p><p><img src="https://tobyqin.github.io/images/idea-new-project.png" alt="idea-new-project"></p><p><strong>小贴士：</strong>如果你是打开别人的写的插件，那么你直接选择打开工程目录是没有用的，因为 IntelliJ IDEA 不认为这是个插件工程，所以你没法运行和调试这个插件，一个不怎么优雅的办法就是<strong>从现有代码新建一个插件工程</strong>，StackOverflow 关于这个的吐槽问题你搜到，如果你有更好的办法请告诉我。当你换一台机器把插件代码克隆下来之后应该就知道我在说什么了。</p><h2 id="插件工程目录结构"><a href="#插件工程目录结构" class="headerlink" title="插件工程目录结构"></a>插件工程目录结构</h2><p>一个典型的插件目录结构就像下图。</p><p><img src="https://tobyqin.github.io/images/idea-project-structure.png" alt="idea-project-structure"></p><ul><li><strong>.idea</strong> 目录 - JetBrains IDE 生成的工程都会有这么一个目录，存放用户配置和缓存，无需关心。</li><li><strong>doc</strong> 目录 - 插件的文档，可选。</li><li><strong>out</strong> 目录 - 编译后的代码字节，无需关心。</li><li><strong>resources</strong> 目录 - 资源存放目录，插件的配置文件在此。</li><li><strong>src</strong> 目录 - 代码存放的位置。</li><li><strong>*.iml</strong> 文件 - 项目的配置文件。</li></ul><h2 id="修改插件信息"><a href="#修改插件信息" class="headerlink" title="修改插件信息"></a>修改插件信息</h2><p>打开 <code>/resources/META-INF/plugin.xml</code>， 更新插件信息，举例说明。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span> <span class="attr">version</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>com.eflabs.plugin.efcommon<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>EF Common for PyCharm<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">"toby.qin@live.com"</span>&gt;</span>Toby Qin<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      &lt;b&gt;Able to run and debug ef common tests easily.&lt;/b&gt;&lt;br&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;Support run/debug ef-common tests via context menu.&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;Show run button in the line of test case.&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">change-notes</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      &lt;b&gt;v3.0&lt;/b&gt;&lt;br&gt;</span><br><span class="line">      &lt;p&gt;Support PyCharm 171.*&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;Support nested ef-common project.&lt;/p&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line"></span><br><span class="line">      &lt;b&gt;Early version&lt;/b&gt;&lt;br&gt;</span><br><span class="line">      &lt;p&gt;Bug fix: failed to get run.template in resource.&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;The baby version.&lt;/p&gt;</span><br><span class="line">      &lt;br&gt;]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">change-notes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">idea-version</span> <span class="attr">since-build</span>=<span class="string">"171.1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- please see http://confluence.jetbrains.com/display/IDEADEV/Plugin+Compatibility+with+IntelliJ+Platform+Products</span></span><br><span class="line"><span class="comment">         on how to target different products --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.python<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">"com.intellij"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationType</span> <span class="attr">implementation</span>=<span class="string">"com.eflabs.efcommon.runConfiguration.EfCommonConfigurationType"</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">order</span>=<span class="string">"FIRST"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">runConfigurationProducer</span> <span class="attr">implementation</span>=<span class="string">"com.eflabs.efcommon.runConfiguration.EfCommonConfigurationProducer"</span></span></span><br><span class="line"><span class="tag">                                  <span class="attr">order</span>=<span class="string">"FIRST"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">runLineMarkerContributor</span></span></span><br><span class="line"><span class="tag">                <span class="attr">implementationClass</span>=<span class="string">"com.eflabs.efcommon.runLineMarker.EfCommonRunLineMarkerContributor"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">language</span>=<span class="string">"Python"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置文件里有几点要注意的：</p><ol><li><code>&lt;id&gt;</code>和<code>&lt;version&gt;</code> 用于声明你的插件唯一标识，同id和version的插件不能够重复上传。</li><li><code>&lt;depends&gt;</code> 节点声明了此插件的依赖条件，如果是PyCharm 适用的，那么就写 <code>com.intellij.modules.python</code></li><li><code>&lt;extenstions</code> 节点用于声明你要扩展的类，只要继承和实现对应的接口就可以了。</li><li><code>&lt;actions&gt;</code> 节点用于注册你要实现的 Action，比如你先写一些 Action，然后<a href="http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/creating_an_action.html" target="_blank" rel="noopener">注册到某个菜单</a>。</li></ol><h2 id="实现具体的业务代码"><a href="#实现具体的业务代码" class="headerlink" title="实现具体的业务代码"></a>实现具体的业务代码</h2><p>这里我略过最核心的部分，因为每个人的需求和代码能力都不一样，这应该去查阅Java编程规范。</p><p>简而言之，就是根据你自己的需求用Java实现一些接口和方法。</p><h2 id="运行和调试你的插件"><a href="#运行和调试你的插件" class="headerlink" title="运行和调试你的插件"></a>运行和调试你的插件</h2><p>如果你的代码已经实现了，那么运行和调试就比较简单。</p><ul><li>使用 <strong>Run | Run</strong> 菜单来运行你的插件，这时候会启动一个新的PyCharm，默认安装好你的插件。</li><li>使用 <strong>Run | Debug</strong>  菜单来调试你的插件，你可以设置断点进行调试。</li></ul><h2 id="发布你的插件"><a href="#发布你的插件" class="headerlink" title="发布你的插件"></a>发布你的插件</h2><p>你可以选择本地发布你的插件，也可以选择上传到 JetBrains 的插件仓库。</p><h3 id="本地发布安装"><a href="#本地发布安装" class="headerlink" title="本地发布安装"></a>本地发布安装</h3><p>如果你的插件是内部小范围使用，并且可能带有敏感信息，那么这样的方式会比较适合你。从主菜单选择 <strong>Build &gt; Prepare plugin ‘my_plugin’ For Deployment</strong>。</p><p><img src="https://tobyqin.github.io/images/idea-deploy-local.png" alt="idea-deploy-local"></p><p>如果成功那么在工程目录就会生成一个同名的 jar 文件。</p><p><img src="https://tobyqin.github.io/images/idea-deploy-local-2.png" alt="idea-deploy-local-2"></p><p>将这个文件 copy 到目标机器就可以通过 *<em>Install Plugin from disk … *</em> 完成安装。</p><h3 id="发布插件到-JetBrains-Plugin-仓库"><a href="#发布插件到-JetBrains-Plugin-仓库" class="headerlink" title="发布插件到 JetBrains Plugin 仓库"></a>发布插件到 JetBrains Plugin 仓库</h3><p>生成插件的步骤和本地发布是一样的，唯一不同的就是你需要到 JetBrains Plugins 网站去注册一个账号。</p><ul><li><a href="https://plugins.jetbrains.com/" target="_blank" rel="noopener">https://plugins.jetbrains.com/</a></li></ul><p>登录之后选择 <strong>UPLOAD PLUGIN</strong> 菜单，上传之后大概需要2个工作日审核。</p><p><img src="https://tobyqin.github.io/images/idea-deploy-remote.png" alt="idea-deploy-remote"></p><p>审核通过后其他用户就可以直接从 <strong>Browse Repositories…</strong> 里搜索到你的插件并安装。通过插件仓库安装的插件，一旦有新版本发布，用户将收到更新提示。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>关于如何实现具体的插件业务代码，一个偷懒的办法就是去看现有功能大概是怎么实现的，你既然可以拿到 PyCharm Community Edition 的所有代码，还有啥看不到的，看懂只是时间问题。再或者去 github 搜搜看，万一有惊喜呢？</p><p>就 PyCharm 本身来说，我觉得作为 IDE 提供的功能已经很丰富了，为啥还要写插件呢？对啊，哪里来的需求，会不会是一个伪需求呢。写插件前请你想一想这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pycharm </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows平台使用IIS部署Flask网站</title>
      <link href="posts/2017-03-27/deploy-flask-to-iis/"/>
      <url>posts/2017-03-27/deploy-flask-to-iis/</url>
      
        <content type="html"><![CDATA[<p>在 Windows 平台<strong>部署</strong>基于 Python 的网站是一件非常折腾的事情，Linux/Unix 平台下有很多选择，本文记录了 Flask 部署到 IIS 的主要步骤，希望对你有所帮助。</p><a id="more"></a><h2 id="涉及工具和平台"><a href="#涉及工具和平台" class="headerlink" title="涉及工具和平台"></a>涉及工具和平台</h2><ul><li>Windows 7 x64</li><li>Python 3.4+</li><li>Flask</li></ul><h2 id="完成-Hello-Flask-网站"><a href="#完成-Hello-Flask-网站" class="headerlink" title="完成 Hello Flask 网站"></a>完成 Hello Flask 网站</h2><p>这是一个最简单的 Flask 网站：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app=Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/',methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello Flask!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>运行<code>python hello.py</code>后没有错误说明你的 Python 环境一切正常，可以继续后面的步骤。</p><h2 id="安装-IIS，启用-CGI"><a href="#安装-IIS，启用-CGI" class="headerlink" title="安装 IIS，启用 CGI"></a>安装 IIS，启用 CGI</h2><p>在控制面板中找到<em>打开或者关闭 Windows 功能</em>，安装 IIS 和 CGI，如下图。</p><p><img src="https://tobyqin.github.io/images/iis+cgi.png" alt="iis+cgi"></p><h2 id="安装-URL-重写组件"><a href="#安装-URL-重写组件" class="headerlink" title="安装 URL 重写组件"></a>安装 URL 重写组件</h2><p>IIS 需要安装 URL 重写组件，这个可以通过<a href="https://www.microsoft.com/web/downloads/platform.aspx" target="_blank" rel="noopener">Microsoft Web Platform Installer</a>来安装。下载<a href="https://www.microsoft.com/web/downloads/platform.aspx" target="_blank" rel="noopener">Microsoft Web Platform Installer</a>后运行，搜索<code>url</code>，分别安装。</p><p><img src="https://tobyqin.github.io/images/wpi-url.png" alt="wpi-url"></p><p><em>注：据说 Windows10 上的 IIS 10 现在不支持 url 重写？待验证</em></p><h2 id="安装-wfastcgi"><a href="#安装-wfastcgi" class="headerlink" title="安装 wfastcgi"></a>安装 wfastcgi</h2><p>通过pip就可以安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install wfastcgi</span><br></pre></td></tr></table></figure><h2 id="启用-wfastcgi"><a href="#启用-wfastcgi" class="headerlink" title="启用 wfastcgi"></a>启用 wfastcgi</h2><p>剩下的事情就只有一些配置了。首先以管理员身份运行<code>wfastcgi-enable</code>来在IIS上启用wfastcgi，这个命令位于<code>c:\python_dir\scripts</code>，也就是你需要确保此目录在系统的PATH里，或者你需要cd到这个目录后再执行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> to python_dir\scripts <span class="keyword">if</span> it is not <span class="keyword">in</span> PATH</span></span><br><span class="line">wfastcgi-enable</span><br></pre></td></tr></table></figure><p>记住命令执行成功后返回的信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Python34\Scripts&gt; wfastcgi-enable</span><br><span class="line">Applied configuration changes to section &quot;system.webServer&#x2F;fastCgi&quot; for &quot;MACHINE&#x2F;WEBROOT&#x2F;APPHOST&quot; at configuration commit path &quot;MACHINE&#x2F;WEBROOT&#x2F;APPHOST&quot;</span><br><span class="line">&quot;C:\Python34\python.exe|C:\Python34\lib\site-packages\wfastcgi.py&quot; can now be used as a FastCGI script processor</span><br></pre></td></tr></table></figure><p> “C:\Python34\python.exe|C:\Python34\lib\site-packages\wfastcgi.py” 在下文的配置文件中需要使用。</p><p><em>Tips: 使用命令 <code>wfastcgi-disable</code> 可以将其移除。</em></p><h2 id="创建-web-config-文件"><a href="#创建-web-config-文件" class="headerlink" title="创建 web.config 文件"></a>创建 web.config 文件</h2><p>下面是一个<code>web.config</code>文件的例子，你只需要修改对应部分就可以使用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">handlers</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- scriptProcessor 的值来自命令行工具 wfastcgi-enable --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">add</span> <span class="attr">name</span>=<span class="string">"FlaskFastCGI"</span> <span class="attr">path</span>=<span class="string">"*"</span> <span class="attr">verb</span>=<span class="string">"*"</span> <span class="attr">modules</span>=<span class="string">"FastCgiModule"</span> <span class="attr">scriptProcessor</span>=<span class="string">"C:\Python34\python.exe|C:\Python34\lib\site-packages\wfastcgi.py"</span> <span class="attr">resourceType</span>=<span class="string">"Unspecified"</span> <span class="attr">requireAccess</span>=<span class="string">"Script"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">handlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- URL 重写中的特殊字符，比如加号+等等 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">requestFiltering</span> <span class="attr">allowDoubleEscaping</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">requestFiltering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">appSettings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Required settings --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里指定Falsk app在模块中的具体位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"WSGI_HANDLER"</span> <span class="attr">value</span>=<span class="string">"hello.app"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"PYTHONPATH"</span> <span class="attr">value</span>=<span class="string">"~/"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Optional settings --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 需要先创建日志目录，否则报错 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"WSGI_LOG"</span> <span class="attr">value</span>=<span class="string">"C:\logs\oboeqa_web.log"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"WSGI_RESTART_FILE_REGEX"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appSettings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置-IIS-目录及权限"><a href="#配置-IIS-目录及权限" class="headerlink" title="配置 IIS 目录及权限"></a>配置 IIS 目录及权限</h2><p>假设你的 Flask 程序将部署在 C:\website\hello 下面，那么你的目录结构大致如此。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\WEBSITE</span><br><span class="line">└───hello</span><br><span class="line">        hello.py</span><br><span class="line">        web.config</span><br></pre></td></tr></table></figure><p>现在你需要让IIS用户拥有访问和执行你的网站脚本的权限，进入 C:\website 目录，执行下面两条命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd C:\website</span><br><span class="line">icacls . &#x2F;grant &quot;NT AUTHORITY\IUSR:(OI)(CI)(RX)&quot;</span><br><span class="line">icacls . &#x2F;grant &quot;Builtin\IIS_IUSRS:(OI)(CI)(RX)&quot;</span><br></pre></td></tr></table></figure><h2 id="创建并访问你的网站"><a href="#创建并访问你的网站" class="headerlink" title="创建并访问你的网站"></a>创建并访问你的网站</h2><p>现在你离成功只差一步之遥，打开 IIS 管理面板，新建一个网站。</p><p><img src="https://tobyqin.github.io/images/iis-add-web-site.png" alt="iis-add-web-site"></p><p>你只需要填上网站名称，物理地址和相应的端口号，点击确认。</p><p><img src="https://tobyqin.github.io/images/iis-website-config.png" alt="iis-website-config"></p><p>打开浏览器，就可以访问你配置好的网站。如果有错误，可以去检查 <code>web.config</code> 中配置的日志文件。</p><p><img src="https://tobyqin.github.io/images/iis-web-site-ok.png" alt="iis-web-site-ok"></p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>写完之后发现其实要完成的步骤并不是特别复杂，但是从摸索到实践的过程确实不易。本文仅讨论了部署的主要步骤，其实真正的生产环境你要考虑的问题可能更多，比如使用virtualenv 对网站进行隔离，安全问题，静态文件解析等等。</p><h2 id="最后的惊喜"><a href="#最后的惊喜" class="headerlink" title="最后的惊喜"></a>最后的惊喜</h2><p><strong>据说</strong>部署Python 网站到 IIS 还有更简单的办法，那就是安装宇宙最强的IDE - <a href="https://www.visualstudio.com/" target="_blank" rel="noopener">Visual Studio 2015</a> （VS2017 暂不支持 Python 开发），个人开发者可以免授权使用社区版。在 VS 中你可以使用 <a href="https://microsoft.github.io/PTVS/" target="_blank" rel="noopener">PTVS</a> 来快捷开发<strong>并部署</strong>Python 程序，真正让你一键无忧。</p><p><img src="https://tobyqin.github.io/images/ptvs-web.png" alt="ptvs-web"></p><p>PTVS 支持了常见的 Python Web 框架，比如 Flask，Django，Bottle，Jade 等等，调试的时候只需要按 F5，部署右键选择 publish，跟着向导一步两步你就可以完成魔鬼的步伐。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://stackoverflow.com/questions/5072166/how-do-i-deploy-a-flask-application-in-iis" target="_blank" rel="noopener">http://stackoverflow.com/questions/5072166/how-do-i-deploy-a-flask-application-in-iis</a></li><li><a href="http://stackoverflow.com/questions/20134329/how-to-deploy-a-flask-application-in-iis-8-windows-server-2012" target="_blank" rel="noopener">http://stackoverflow.com/questions/20134329/how-to-deploy-a-flask-application-in-iis-8-windows-server-2012</a></li><li><a href="http://blog.csdn.net/firefox1/article/details/46438769" target="_blank" rel="noopener">http://blog.csdn.net/firefox1/article/details/46438769</a></li><li><a href="http://www.cnblogs.com/liulixiang/p/4999608.html" target="_blank" rel="noopener">http://www.cnblogs.com/liulixiang/p/4999608.html</a></li><li><a href="http://www.cnblogs.com/xiaolecn/p/5111076.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaolecn/p/5111076.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
            <tag> iis </tag>
            
            <tag> deployment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Git Diff 命令</title>
      <link href="posts/2017-03-09/git-diff-tip/"/>
      <url>posts/2017-03-09/git-diff-tip/</url>
      
        <content type="html"><![CDATA[<p>你确定自己会<code>git diff</code> 吗？</p><a id="more"></a><p>在git提交过程中，存在三大环节：</p><ul><li>working tree</li><li>index file (staged)</li><li>commit</li></ul><p>这三大环节中，你应该有一个大概的了解：</p><ol><li><strong>working tree</strong>：就是你所工作在的目录，每当你在代码中进行了修改，working tree的状态就改变了。</li><li><strong>index file</strong>：是索引文件，它是连接<code>working tree</code>和<code>commit</code>的桥梁，每当我们使用<code>git add</code>命令来登记修改的文件后，<code>index file</code>的内容就改变了，此时<code>index file</code>就和<code>working tree</code>同步了。</li><li><strong>commit</strong>：这是提交更改完成的最后阶段，commit后我们的代码才真正进入了git仓库。我们使用<code>git commit</code>就是将<code>index file</code>里的内容提交到<code>commit</code>中。</li></ol><p>总结一下：</p><ul><li><strong>git diff</strong>：是查看<code>working tree</code>与<code>index file</code>的差别。</li><li><strong>git diff –cached</strong>：是查看<code>index file</code>与<code>commit</code>的差别。</li><li><strong>git diff HEAD</strong>：是查看<code>working tree</code>和<code>commit</code>的差别。（你一定没有忘记，HEAD代表的是最近的一次commit的信息）</li></ul><p>参考文档： <a href="http://www.cnblogs.com/Alight/p/3571042.html" target="_blank" rel="noopener">http://www.cnblogs.com/Alight/p/3571042.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传并发布你自己发明的轮子 - Python PyPI 实践</title>
      <link href="posts/2017-03-09/upload-your-pypi-package/"/>
      <url>posts/2017-03-09/upload-your-pypi-package/</url>
      
        <content type="html"><![CDATA[<p>Pypi的发布实践。</p><a id="more"></a><p>本文仅讨论上传相关的步骤，关于如何给写一个<code>setup.py</code> 请参阅官方文档：</p><ul><li><a href="https://docs.python.org/2/distutils/setupscript.html" target="_blank" rel="noopener">https://docs.python.org/2/distutils/setupscript.html</a></li></ul><h2 id="上传前的注意事项"><a href="#上传前的注意事项" class="headerlink" title="上传前的注意事项"></a>上传前的注意事项</h2><ul><li>假设你的包已经开发完成，并且根目录必须要有一个<a href="https://github.com/pypa/sampleproject/blob/master/setup.py" target="_blank" rel="noopener">setup.py</a>。</li><li>最好有一个<a href="https://github.com/pypa/sampleproject/blob/master/README.rst" target="_blank" rel="noopener">README.rst</a> 用来描述你的轮子，虽然这不是必须的，但文档就像内裤，你最好还是要有的。</li><li>如果你需要打包代码文件夹以外的文件，比如版权信息等等，你还需要写一个 <a href="https://github.com/pypa/sampleproject/blob/master/MANIFEST.in" target="_blank" rel="noopener">MANIFEST.in</a>。</li></ul><h2 id="关于setup-py的补充说明"><a href="#关于setup-py的补充说明" class="headerlink" title="关于setup.py的补充说明"></a>关于<code>setup.py</code>的补充说明</h2><ul><li><code>name</code> 必须是唯一的，允许使用数字和字母，推荐使用中划线（-）而不是下划线（_），因为pip安装只支持中划线，比如<code>pip install my-pkg</code>，为了不给自己找麻烦请听话。</li><li><code>version</code>推荐遵循<a href="https://packaging.python.org/distributing/#semantic-versioning-preferred" target="_blank" rel="noopener">语义化版本号</a>规则，简单说就像这样：1.2.0</li><li>作者姓名和邮箱地址不一定要和你的PyPI账号一致。</li></ul><h2 id="测试本地打包命令"><a href="#测试本地打包命令" class="headerlink" title="测试本地打包命令"></a>测试本地打包命令</h2><p>如果上面的都没问题，在本地目录执行以下命令应该能成功在dist目录下生成*.tar.gz的包文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py sdist</span><br></pre></td></tr></table></figure><h2 id="上传并发布包文件到PyPI"><a href="#上传并发布包文件到PyPI" class="headerlink" title="上传并发布包文件到PyPI"></a>上传并发布包文件到PyPI</h2><h3 id="创建-PyPI账号"><a href="#创建-PyPI账号" class="headerlink" title="创建 PyPI账号"></a>创建 PyPI账号</h3><p>非常简单，直接通过官网注册 <a href="https://pypi.python.org/pypi?%3Aaction=register_form，" target="_blank" rel="noopener">https://pypi.python.org/pypi?%3Aaction=register_form，</a> 但是需要验证邮件并确认激活。</p><h3 id="创建用户验证文件-pypirc"><a href="#创建用户验证文件-pypirc" class="headerlink" title="创建用户验证文件 ~/.pypirc"></a>创建用户验证文件 <code>~/.pypirc</code></h3><p>在自己的用户目录下新建一个空白文件命名为<code>.pypirc</code>，内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[distutils]</span><br><span class="line">index-servers&#x3D;pypi</span><br><span class="line"></span><br><span class="line">[pypi]</span><br><span class="line">repository &#x3D; https:&#x2F;&#x2F;upload.pypi.org&#x2F;legacy&#x2F;</span><br><span class="line">username &#x3D; &lt;username&gt;</span><br><span class="line">password &#x3D; &lt;password&gt;</span><br></pre></td></tr></table></figure><p>用户名和密码就是上一步骤所创建的，直接明文输入。如果你觉得明文密码不安全也可以留空，在后面的上传过程中会提示你手动输入。</p><h3 id="注册你的包"><a href="#注册你的包" class="headerlink" title="注册你的包"></a>注册你的包</h3><p>你需要到PyPI注册并验证你的包，之后才能开始真正上传，注册的方式有以下几种。</p><ol><li>使用命令<code>python setup.py register</code>，最简单但官网不推荐，因为使用的是HTTP未加密，有可能会被攻击人嗅探到你的密码。</li><li>通过<a href="https://pypi.python.org/pypi?%3Aaction=submit_form" target="_blank" rel="noopener">PyPI网站提交表单</a>完成注册验证。</li><li>安装 <code>pip install twine</code> 然后在通过命令 <code>twine register dist/mypkg.whl</code> 完成注册。</li></ol><h3 id="上传并完成发布"><a href="#上传并完成发布" class="headerlink" title="上传并完成发布"></a>上传并完成发布</h3><p>你可以任选以下两种方式之一发布你的轮子。</p><ol><li>使用命令：<code>python setup.py sdist upload</code>，还是和上面一样，最简单但是有安全隐患。</li><li>使用 <a href="https://packaging.python.org/key_projects/#twine" target="_blank" rel="noopener">twine</a>： <code>twine upload dist/*</code></li></ol><h3 id="管理你的包"><a href="#管理你的包" class="headerlink" title="管理你的包"></a>管理你的包</h3><p>如果你的包已经上传成功，那么当你登录PyPI网站后应该能在右侧导航栏看到管理入口。</p><p><img src="https://tobyqin.github.io/images/pypi_manage.png" alt="pypi_manage"></p><p>点击包名进去后你可以对你的包进行管理，当然你也可以从这里删除这个包。</p><h3 id="让别人使用你的包"><a href="#让别人使用你的包" class="headerlink" title="让别人使用你的包"></a>让别人使用你的包</h3><p>包发布完成后，其他人只需要使用pip就可以安装你的包文件。比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install package-name</span><br></pre></td></tr></table></figure><p>如果你更新了包，别人可以可以通过<code>--update</code>参数来更新：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install package-name --update</span><br></pre></td></tr></table></figure><h2 id="可能遇到的错误"><a href="#可能遇到的错误" class="headerlink" title="可能遇到的错误"></a>可能遇到的错误</h2><h3 id="Upload-failed-403-Invalid-or-non-existent-authentication-information"><a href="#Upload-failed-403-Invalid-or-non-existent-authentication-information" class="headerlink" title="Upload failed (403): Invalid or non-existent authentication information."></a>Upload failed (403): Invalid or non-existent authentication information.</h3><p>错误的用户验证信息，你需要创建一个用户验证文件 <code>~/.pypirc</code>。请参阅上文。</p><h3 id="Upload-failed-403-You-are-not-allowed-to-edit-‘xxx’-package-information"><a href="#Upload-failed-403-You-are-not-allowed-to-edit-‘xxx’-package-information" class="headerlink" title="Upload failed (403): You are not allowed to edit ‘xxx’ package information"></a>Upload failed (403): You are not allowed to edit ‘xxx’ package information</h3><p>你需要先注册你的包才可以开始上传，运行注册命令：<code>python setup.py register</code></p><h3 id="Server-response-401-Incomplete-registration-check-your-email"><a href="#Server-response-401-Incomplete-registration-check-your-email" class="headerlink" title="Server response (401): Incomplete registration; check your email"></a>Server response (401): Incomplete registration; check your email</h3><p>你的PyPI账户还没完成邮箱验证，你需要去注册邮箱找到一封验证邮件完成验证后再重试失败的步骤。</p><h3 id="Server-response-400-Invalid-classifier-“Topic-Software-Development-Utilities”"><a href="#Server-response-400-Invalid-classifier-“Topic-Software-Development-Utilities”" class="headerlink" title="Server response (400): Invalid classifier “Topic :: Software Development :: Utilities”"></a>Server response (400): Invalid classifier “Topic :: Software Development :: Utilities”</h3><p>你的setup.py文件中的<strong>classifier</strong>信息有误，请按<a href="https://pypi.python.org/pypi?%3Aaction=browse" target="_blank" rel="noopener">官网</a>的正确分类书写<strong>classifier</strong>.</p><h3 id="error-No-dist-file-created-in-earlier-command"><a href="#error-No-dist-file-created-in-earlier-command" class="headerlink" title="error: No dist file created in earlier command"></a>error: No dist file created in earlier command</h3><p>你还没打包就开始了上传命令，建议打包和上传的操作放在一起做，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python setup sdist upload</span><br></pre></td></tr></table></figure><h3 id="error-Upload-failed-499-Client-Disconnected"><a href="#error-Upload-failed-499-Client-Disconnected" class="headerlink" title="error: Upload failed (499): Client Disconnected"></a>error: Upload failed (499): Client Disconnected</h3><p>这应该是网络问题，多重试几次。</p><h3 id="Upload-failed-400-File-already-exists"><a href="#Upload-failed-400-File-already-exists" class="headerlink" title="Upload failed (400): File already exists"></a>Upload failed (400): File already exists</h3><p>文件已经存在了，你每一次上次都应该更新版本号。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://packaging.python.org/distributing/" target="_blank" rel="noopener">https://packaging.python.org/distributing/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PyPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Move on to Python 3</title>
      <link href="posts/2017-02-06/move-on-to-python-3/"/>
      <url>posts/2017-02-06/move-on-to-python-3/</url>
      
        <content type="html"><![CDATA[<p>Do we want to move on to Python 3? </p><a id="more"></a><p>Well, what is your concerns? Here is a slide made by me probably can help you out.  <em>(Use the <strong>left/right</strong> arrow key to navigate <strong>back/forward</strong>.)</em></p><h3 id="Slides"><a href="#Slides" class="headerlink" title="Slides"></a>Slides</h3><iframe src="/files/slides/move-on-to-python-3.html" width="100%" height="440px" frameborder="0" scrolling="no"> </iframe><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><ul><li>View the slide in full screen: <a href="/files/slides/move-on-to-python-3.html">Move on to python 3</a></li><li>Download the mindmap file: <a href="/files/Move-on-to-python3.xmind">move on to python 3.xmind</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python 3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结：Python中的异常处理</title>
      <link href="posts/2016-12-04/Python-exception-handling/"/>
      <url>posts/2016-12-04/Python-exception-handling/</url>
      
        <content type="html"><![CDATA[<p>异常处理在任何一门编程语言里都是值得关注的一个话题，良好的异常处理可以让你的程序更加健壮，清晰的错误信息更能帮助你快速修复问题。</p><a id="more"></a><p>在Python中，和不部分高级语言一样，使用了try/except/finally语句块来处理异常，如果你有其他编程语言的经验，实践起来并不难。</p><h2 id="异常处理语句-try…excpet…finally"><a href="#异常处理语句-try…excpet…finally" class="headerlink" title="异常处理语句 try…excpet…finally"></a>异常处理语句 try…excpet…finally</h2><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(a / b)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">"Error: b should not be 0 !!"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Unexpected Error: &#123;&#125;"</span>.format(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Run into else only when everything goes well'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'Always run into finally block.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tests</span></span><br><span class="line">div(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">div(<span class="number">2</span>, <span class="string">'bad type'</span>)</span><br><span class="line">div(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutiple exception in one line</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(a / b)</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Except block is optional when there is finally</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    open(database)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    close(database)</span><br><span class="line"></span><br><span class="line"><span class="comment"># catch all errors and log it</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_work()</span><br><span class="line"><span class="keyword">except</span>:    </span><br><span class="line">    <span class="comment"># get detail from logging module</span></span><br><span class="line">    logging.exception(<span class="string">'Exception caught!'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># get detail from sys.exc_info() method</span></span><br><span class="line">    error_type, error_value, trace_back = sys.exc_info()</span><br><span class="line">    print(error_value)</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><h3 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下"></a>总结如下</h3><ol><li><code>except</code>语句不是必须的，<code>finally</code>语句也不是必须的，但是二者必须要有一个，否则就没有<code>try</code>的意义了。</li><li><code>except</code>语句可以有多个，Python会按<code>except</code>语句的顺序依次匹配你指定的异常，如果异常已经处理就不会再进入后面的<code>except</code>语句。</li><li><code>except</code>语句可以以元组形式同时指定多个异常，参见实例代码。</li><li><code>except</code>语句后面如果不指定异常类型，则默认捕获所有异常，你可以通过logging或者sys模块获取当前异常。</li><li>如果要捕获异常后要重复抛出，请使用<code>raise</code>，后面不要带任何参数或信息。</li><li>不建议捕获并抛出同一个异常，请考虑重构你的代码。</li><li>不建议在不清楚逻辑的情况下捕获所有异常，有可能你隐藏了很严重的问题。</li><li>尽量使用内置的异常处理语句来 替换try/except语句，比如<code>with</code>语句，<code>getattr()</code>方法。</li></ol><h2 id="抛出异常-raise"><a href="#抛出异常-raise" class="headerlink" title="抛出异常 raise"></a>抛出异常 raise</h2><p>如果你需要自主抛出异常一个异常，可以使用<code>raise</code>关键字，等同于C#和Java中的<code>throw</code>语句，其语法规则如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError(<span class="string">"bad name!"</span>)</span><br></pre></td></tr></table></figure><p><code>raise</code>关键字后面需要指定你抛出的异常类型，一般来说抛出的异常越详细越好，Python在<code>exceptions</code>模块内建了很多的异常类型，通过使用<code>dir()</code>函数来查看<code>exceptions</code>中的异常类型，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> exceptions</span><br><span class="line"></span><br><span class="line"><span class="comment"># ['ArithmeticError', 'AssertionError'.....]</span></span><br><span class="line"><span class="keyword">print</span> dir(exceptions)</span><br></pre></td></tr></table></figure><p>当然你也可以查阅Python的文档库进行更详细的了解。</p><ul><li><a href="https://docs.python.org/2.7/library/exceptions.html#bltin-exceptions" target="_blank" rel="noopener">https://docs.python.org/2.7/library/exceptions.html#bltin-exceptions</a></li></ul><h2 id="自定义异常类型"><a href="#自定义异常类型" class="headerlink" title="自定义异常类型"></a>自定义异常类型</h2><p>Python中也可以自定义自己的特殊类型的异常，只需要要从<code>Exception</code>类继承(直接或间接)即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCustomException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>一般你在自定义异常类型时，需要考虑的问题应该是这个异常所应用的场景。如果内置异常已经包括了你需要的异常，建议考虑使用内置 的异常类型。比如你希望在函数参数错误时抛出一个异常，你可能并不需要定义一个<code>InvalidArgumentError</code>，使用内置的<code>ValueError</code>即可。</p><h2 id="经验案例"><a href="#经验案例" class="headerlink" title="经验案例"></a>经验案例</h2><h3 id="传递异常-re-raise-Exception"><a href="#传递异常-re-raise-Exception" class="headerlink" title="传递异常 re-raise Exception"></a>传递异常 re-raise Exception</h3><p>捕捉到了异常，但是又想重新引发它（传递异常），使用不带参数的<code>raise</code>语句即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f1()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span>  <span class="comment"># don't raise e !!!</span></span><br><span class="line"></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure><p>在Python2中，为了保持异常的完整信息，那么你捕获后再次抛出时千万不能在<code>raise</code>后面加上异常对象，否则你的<strong><code>trace</code>信息就会从此处截断</strong>。以上是最简单的重新抛出异常的做法。</p><p>还有一些技巧可以考虑，比如抛出异常前对异常的信息进行更新。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f1()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        e.args += (<span class="string">'more info'</span>,)</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>如果你有兴趣了解更多，建议阅读这篇博客。</p><ul><li><a href="http://www.ianbicking.org/blog/2007/09/re-raising-exceptions.html" target="_blank" rel="noopener">http://www.ianbicking.org/blog/2007/09/re-raising-exceptions.html</a></li></ul><p>Python3对重复传递异常有所改进，你可以自己尝试一下，不过建议还是同上。</p><h3 id="Exception-和-BaseException"><a href="#Exception-和-BaseException" class="headerlink" title="Exception 和 BaseException"></a>Exception 和 BaseException</h3><p>当我们要捕获一个通用异常时，应该用<code>Exception</code>还是<code>BaseException</code>？我建议你还是看一下<a href="https://docs.python.org/2.7/library/exceptions.html#bltin-exceptions" target="_blank" rel="noopener"> 官方文档说明</a>，这两个异常到底有啥区别呢？ 请看它们之间的继承关系。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration...</span><br><span class="line">      +-- StandardError...</span><br><span class="line">      +-- Warning...</span><br></pre></td></tr></table></figure><p>从<code>Exception</code>的层级结构来看，<code>BaseException</code>是最基础的异常类，<code>Exception</code>继承了它。<code>BaseException</code>除了包含所有的<code>Exception</code>外还包含了<code>SystemExit</code>，<code>KeyboardInterrupt</code>和<code>GeneratorExit</code>三个异常。</p><p>有此看来你的程序在捕获所有异常时更应该使用<code>Exception</code>而不是<code>BaseException</code>，因为另外三个异常属于更高级别的异常，合理的做法应该是交给Python的解释器处理。</p><h3 id="except-Exception-as-e和-except-Exception-e"><a href="#except-Exception-as-e和-except-Exception-e" class="headerlink" title="except Exception as e和 except Exception, e"></a>except Exception as e和 except Exception, e</h3><p>代码示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:  <span class="comment"># should</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> KeyError, e:  <span class="comment"># should not</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在Python2的时代，你可以使用以上两种写法中的任意一种。在Python3中你只能使用第一种写法，第二种写法被废弃掉了。第一个种写法可读性更好，而且为了程序的兼容性和后期移植的成本，请你也抛弃第二种写法。</p><h3 id="raise-“Exception-string”"><a href="#raise-“Exception-string”" class="headerlink" title="raise “Exception string”"></a>raise “Exception string”</h3><p>把字符串当成异常抛出看上去是一个非常简洁的办法，但其实是一个非常不好的习惯。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> is_work_done():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> <span class="string">"Work is not done!"</span> <span class="comment"># not cool</span></span><br></pre></td></tr></table></figure><p>上面的语句如果抛出异常，那么会是这样的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/demo/exception_hanlding.py"</span>, line <span class="number">48</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> <span class="string">"Work is not done!"</span></span><br><span class="line">TypeError: exceptions must be old-style classes <span class="keyword">or</span> derived <span class="keyword">from</span> BaseException, <span class="keyword">not</span> str</span><br></pre></td></tr></table></figure><p>这在Python2.4以前是可以接受的做法，但是没有指定异常类型有可能会让下游没办法正确捕获并处理这个异常，从而导致你的程序挂掉。简单说，这种写法是是封建时代的陋习，应该扔了。</p><h3 id="使用内置的语法范式代替try-except"><a href="#使用内置的语法范式代替try-except" class="headerlink" title="使用内置的语法范式代替try/except"></a>使用内置的语法范式代替try/except</h3><p>Python 本身提供了很多的语法范式简化了异常的处理，比如<code>for</code>语句就处理的<code>StopIteration</code>异常，让你很流畅地写出一个循环。</p><p><code>with</code>语句在打开文件后会自动调用<code>finally</code>中的关闭文件操作。我们在写Python代码时应该尽量避免在遇到这种情况时还使用try/except/finally的思维来处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># should not</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(a_file)</span><br><span class="line">    do_something(f)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># should </span></span><br><span class="line"><span class="keyword">with</span> open(a_file) <span class="keyword">as</span> f:</span><br><span class="line">    do_something(f)</span><br></pre></td></tr></table></figure><p>再比如，当我们需要访问一个不确定的属性时，有可能你会写出这样的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test = Test()</span><br><span class="line">    name = test.name  <span class="comment"># not sure if we can get its name</span></span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    name = <span class="string">'default'</span></span><br></pre></td></tr></table></figure><p>其实你可以使用更简单的<code>getattr()</code>来达到你的目的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = getattr(test, <span class="string">'name'</span>, <span class="string">'default'</span>)</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>最佳实践不限于编程语言，只是一些规则和填坑后的收获。</p><ol><li>只处理你知道的异常，避免捕获所有 异常然后吞掉它们。</li><li>抛出的异常应该说明原因，有时候你知道异常类型也猜不出所以然的。</li><li>避免在catch语句块中干一些没意义的事情。</li><li>不要使用异常来控制流程，那样你的程序会无比难懂和难维护。</li><li>如果有需要，切记使用finally来释放资源。</li><li>如果有需要，请不要忘记在处理异常后做清理工作或者回滚操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> exception handling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gif截屏工具 - GifCam</title>
      <link href="posts/2016-11-23/gif-screenshot-tool-gifcam/"/>
      <url>posts/2016-11-23/gif-screenshot-tool-gifcam/</url>
      
        <content type="html"><![CDATA[<p>如果你需要录制截屏并保存成gif图片格式，那么你一定不能错过GifCam这个神奇的小工具。它虽然只有600K，但功能不可小觑。</p><a id="more"></a><p>GifCam (Gif相机) 是一款免费且非常优秀的视频录制/剪辑的GIF动画制作软件，它的使用非常简单直观，譬如想要将某一小段视频录制成Gif图片，你只需将其窗口的<strong>取景框</strong>拖放到视频播放的区域，然后按下录制按钮即开始录制。它就像一个摄像机一样能将<strong>取景框</strong>拍摄下来并保存成GIF图片。</p><p><img src="https://tobyqin.github.io/images/demo.gif" alt="demo"></p><p>借助GifCam你可以快速方便地制作演示教程或者将视频一些搞笑经典片段制作成动画图片。你也可以将录制的屏幕导出成avi的视频格式，并根据指定的码率做压缩。</p><p>GifCam官网：<a href="http://blog.bahraniapps.com/gifcam/#download" target="_blank" rel="noopener">http://blog.bahraniapps.com/gifcam/#download</a><br>从本站下载：<a href="/files/GifCam.zip">/files/GifCam.zip</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器的另类用法</title>
      <link href="posts/2016-10-30/python-decorator-more/"/>
      <url>posts/2016-10-30/python-decorator-more/</url>
      
        <content type="html"><![CDATA[<p>之前有比较系统介绍过Python的装饰器（请查阅《<a href="https://tobyqin.github.io/posts/2016-10-27/python-decorator/" target="_blank" rel="noopener">详解Python装饰器</a>》），本文算是一个补充。今天我们一起探讨一下装饰器的另类用法。</p><a id="more"></a><h2 id="语法回顾"><a href="#语法回顾" class="headerlink" title="语法回顾"></a>语法回顾</h2><p>开始之前我们再将Python装饰器的语法回顾一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>等同于:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(...)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f = decorate(f)</span><br></pre></td></tr></table></figure><p>@语法的好处在于：</p><ul><li>相同的函数名只出现一次，避免了<code>f = decorate(f)</code>这样的语句。</li><li>可读性更高，让读代码的人一眼就明白这个函数被装饰了哪些功能。</li></ul><h2 id="call-装饰器"><a href="#call-装饰器" class="headerlink" title="@call()装饰器"></a>@call()装饰器</h2><p>假设你要创建一个整数平方的列表，你可以这样写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(table), table[<span class="number">3</span>]</span><br><span class="line">(<span class="number">5</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>也可以使用列表表达式，因为比较简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(table), table[<span class="number">3</span>]</span><br><span class="line">(<span class="number">5</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>但是假如这个列表的逻辑比较复杂的时候，最好是写成一个方法，这样会更好维护。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    value = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="meta">... </span>        value.append(i*i)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> value</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = table(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>注意看最后一句，是不是很符合装饰器的语法规则？什么情况下你会写这样的代码呢？</p><ol><li>你需要把相对复杂业务写成一个方法。</li><li>这个方法和返回值可以同名，而且你不希望对外公开此方法，只公开结果。</li><li>你想尽量使用装饰器。（无厘头的理由）</li></ol><p>那么这时候<code>@call()</code>装饰器就登场了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_fn</span><span class="params">(fn)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> call_fn</span><br></pre></td></tr></table></figure><p>这个装饰器会把你传入的参数送给目标函数然后直接执行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@call(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span><span class="params">(n)</span>:</span></span><br><span class="line">    value = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        value.append(i*i)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> len(table), table[<span class="number">3</span>]  <span class="comment"># 5 9</span></span><br></pre></td></tr></table></figure><p><code>@call()</code>装饰器适用于任何函数，你传入的参数会被直接使用然后结果赋值给同名函数。这样避免了你重新定义一个变量来存储结果。</p><h2 id="list-装饰器"><a href="#list-装饰器" class="headerlink" title="@list 装饰器"></a>@list 装饰器</h2><p>假如你有一个这样一个生成器函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure><p>当你要生成<code>n=5</code>的序列时，可以直接调用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = table(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> table  <span class="comment"># &lt;generator object table at 0x027DAC10&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>@call()</code>装饰器，也能得到一样的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@call(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> table  <span class="comment"># &lt;generator object table at 0x0340AC10&gt;</span></span><br></pre></td></tr></table></figure><p>你还可以直接将其转换成列表。（使用<code>list(generator_object)</code>函数）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@list</span></span><br><span class="line"><span class="meta">@call(5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">table</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> table  <span class="comment"># [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>这等同于列表表达式，但是可读性也许差了不少。例子本身只是演示了装饰器的一种用法，但不是推荐你就这样使用装饰器。你这样用也许会被其他同事拖到墙角里打死。</p><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>在Python 2.6以前，还不支持类装饰器。也就是说，你不能使用这样的写法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>你必须这样写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">MyClass = decorator(MyClass)</span><br></pre></td></tr></table></figure><p>也就是说，@语法对类是做了特殊处理的，类不一定是一个callable对象（尽管它有构造函数），但是也允许使用装饰器。那么基于以上语法，你觉得类装饰器能实现什么功能呢？</p><p>举一个例子，<a href="https://pypi.python.org/pypi/ptest" target="_blank" rel="noopener">ptest</a>中的<code>@TestClass()</code>用于声明一个测试类，其源代码大致如此。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TestClass</span><span class="params">(enabled=True, run_mode=<span class="string">"singleline"</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tracer</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.__pd_type__ =<span class="string">'test'</span></span><br><span class="line">        cls.__enabled__ = enabled</span><br><span class="line">        cls.__run_mode__ = run_mode.lower()</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> tracer</span><br></pre></td></tr></table></figure><p>当我们在写一个测试类时，发生了什么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestClass()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCases</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># your test case ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> TestCases.__dict__  <span class="comment"># &#123;'__module__': '__main__', '__enabled__': True, '__pd_type__': 'test', '__run_mode__': 'singleline', ...&#125;</span></span><br></pre></td></tr></table></figure><p>居然装饰器的参数全都变成了变成这个类的属性，好神奇！我们把语法糖一一展开。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCases</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">decorator = TestClass()</span><br><span class="line"><span class="keyword">print</span> decorator  <span class="comment"># &lt;function tracer at 0x033128F0&gt;</span></span><br><span class="line"></span><br><span class="line">TestCases = decorator(TestCases)</span><br><span class="line"><span class="keyword">print</span> TestCases  <span class="comment"># &lt;class '__main__.TestCases'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> TestCases.__dict__  <span class="comment"># &#123;'__module__': '__main__', '__enabled__': True, '__pd_type__': 'test', '__run_mode__': 'singleline', ...&#125;</span></span><br></pre></td></tr></table></figure><p>当装饰器在被使用时，<code>TestClass()</code>函数会马上被执行并返回一个装饰器函数，这个函数是一个闭包函数，保存了<code>enabled</code>和<code>run_mode</code>两个变量。另外它还接受一个类作为参数，并使用之前保存的变量为这个类添加属性，最后返回。所以经过<code>@TestClass()</code>装饰过的类都会带上<code>__enabled__</code>、<code>__pd_type__</code>以及<code>__run_mode__</code>的属性。</p><p>由此可见，类装饰器可以完成和Java类似的注解功能，而且要比注解强大的多。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>装饰器就是一个语法糖，当你看不懂一个装饰器时，可以考虑将其依次展开，分别带入。这个语法糖给了我们不少方便，但是也要慎用。毕竟可维护的代码才是高质量的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Python的装饰器</title>
      <link href="posts/2016-10-27/python-decorator/"/>
      <url>posts/2016-10-27/python-decorator/</url>
      
        <content type="html"><![CDATA[<p>Python中的装饰器是你进入Python大门的一道坎，不管你跨不跨过去它都在那里。</p><a id="more"></a><h2 id="为什么需要装饰器"><a href="#为什么需要装饰器" class="headerlink" title="为什么需要装饰器"></a>为什么需要装饰器</h2><p>我们假设你的程序实现了<code>say_hello()</code>和<code>say_goodbye()</code>两个函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello!"</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_goodbye</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello!"</span>  <span class="comment"># bug here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure><p>但是在实际调用中，我们发现程序出错了，上面的代码打印了两个hello。经过调试你发现是<code>say_goodbye()</code>出错了。老板要求调用每个方法前都要记录进入函数的时间和名称，比如这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DEBUG] 2016-10-27 11:11:11 - Enter say_hello()</span><br><span class="line">Hello!</span><br><span class="line">[DEBUG] 2016-10-27 11:11:11 - Enter say_goodbye()</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure><p>好，小A是个毕业生，他是这样实现的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG]: enter say_hello()"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_goodbye</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG]: enter say_goodbye()"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure><p>很low吧？ 嗯是的。小B工作有一段时间了，他告诉小A应该这样写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> inspect</span><br><span class="line">    caller_name = inspect.stack()[<span class="number">1</span>][<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(caller_name)   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></span><br><span class="line">    debug()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_goodbye</span><span class="params">()</span>:</span></span><br><span class="line">    debug()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"goodbye!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure><p>是不是好一点？那当然，但是每个业务函数里都要调用一下<code>debug()</code>函数，是不是很难受？万一老板说say相关的函数不用debug，do相关的才需要呢？</p><p>那么装饰器这时候应该登场了。</p><blockquote><p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p></blockquote><p>概括的讲，装饰器的作用就是<strong>为已经存在的函数或对象添加额外的功能</strong>。</p><h2 id="怎么写一个装饰器"><a href="#怎么写一个装饰器" class="headerlink" title="怎么写一个装饰器"></a>怎么写一个装饰器</h2><p>在早些时候 (Python Version &lt; 2.4，2004年以前)，为一个函数添加额外功能的写法是这样的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello!"</span></span><br><span class="line"></span><br><span class="line">say_hello = debug(say_hello)  <span class="comment"># 添加功能并保持原函数名不变</span></span><br></pre></td></tr></table></figure><p>上面的debug函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。因为这样写实在不太优雅，在后面版本的Python中支持了@语法糖，下面代码等同于早期的写法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello!"</span></span><br></pre></td></tr></table></figure><p>这是最简单的装饰器，但是有一个问题，如果被装饰的函数需要传入参数，那么这个装饰器就坏了。因为返回的函数并不能接受参数，你可以指定装饰器函数<code>wrapper</code>接受和原函数一样的参数，比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(something)</span>:</span>  <span class="comment"># 指定一毛一样的参数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(something)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装过函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello &#123;&#125;!"</span>.format(something)</span><br></pre></td></tr></table></figure><p>这样你就解决了一个问题，但又多了N个问题。因为函数有千千万，你只管你自己的函数，别人的函数参数是什么样子，鬼知道？还好Python提供了可变参数<code>*args</code>和关键字参数<code>**kwargs</code>，有了这两个参数，装饰器就可以用于任意目标函数了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 指定宇宙无敌参数</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(func.__name__)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Prepare and say...'</span>,</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello &#123;&#125;!"</span>.format(something)</span><br></pre></td></tr></table></figure><p>至此，你已完全掌握初级的装饰器写法。</p><h2 id="高级一点的装饰器"><a href="#高级一点的装饰器" class="headerlink" title="高级一点的装饰器"></a>高级一点的装饰器</h2><p>带参数的装饰器和类装饰器属于进阶的内容。在理解这些装饰器之前，最好对函数的闭包和装饰器的接口约定有一定了解。(参见 <a href="https://tobyqin.cn/posts/2016-10-22/python-closure/">https://tobyqin.cn/posts/2016-10-22/python-closure/</a>)</p><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出log信息，而且还需指定log的级别，那么装饰器就会是这样的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment"># say = logging(level='INFO')(say)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"do &#123;&#125;..."</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say(<span class="string">'hello'</span>)</span><br><span class="line">    do(<span class="string">"my work"</span>)</span><br></pre></td></tr></table></figure><p>是不是有一些晕？你可以这么理解，当带参数的装饰器被打在某个函数上时，比如<code>@logging(level=&#39;DEBUG&#39;)</code>，它其实是一个函数，会马上被执行，只要这个它返回的结果是一个装饰器时，那就没问题。细细再体会一下。</p><h3 id="基于类实现的装饰器"><a href="#基于类实现的装饰器" class="headerlink" title="基于类实现的装饰器"></a>基于类实现的装饰器</h3><p>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了<code>__call__()</code>方法，那么这个对象就是callable的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call me!'</span></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t()  <span class="comment"># call me</span></span><br></pre></td></tr></table></figure><p>像<code>__call__</code>这样前后都带下划线的方法在Python中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p><p>回到装饰器上的概念上来，装饰器要求接受一个callable对象，并返回一个callable对象（不太严谨，详见后文）。那么用类来实现也是也可以的。我们可以让类的构造函数<code>__init__()</code>接受一个函数，然后重载<code>__call__()</code>并返回一个函数，也可以达到装饰器函数的效果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">            func=self.func.__name__)</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br></pre></td></tr></table></figure><h3 id="带参数的类装饰器"><a href="#带参数的类装饰器" class="headerlink" title="带参数的类装饰器"></a>带参数的类装饰器</h3><p>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接受的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载<code>__call__</code>方法是就需要接受一个函数并返回一个函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level=<span class="string">'INFO'</span>)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span> <span class="comment"># 接受函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment">#返回函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br></pre></td></tr></table></figure><h3 id="内置的装饰器"><a href="#内置的装饰器" class="headerlink" title="内置的装饰器"></a>内置的装饰器</h3><p>内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象，所以更难理解一些。</p><h4 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h4><p>在了解这个装饰器前，你需要知道在不使用装饰器怎么写一个属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    self._x = value</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a property</span></span><br><span class="line">x = property(getx, setx, delx, <span class="string">"I am doc for x property"</span>)</span><br></pre></td></tr></table></figure><p>以上就是一个Python属性的标准写法，其实和Java挺像的，但是太罗嗦。有了@语法糖，能达到一样的效果但看起来更简单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">x = property(x)</span><br></pre></td></tr></table></figure><p>属性有三个装饰器：<code>setter</code>, <code>getter</code>, <code>deleter</code> ，都是在<code>property()</code>的基础上做了一些封装，因为<code>setter</code>和<code>deleter</code>是<code>property()</code>的第二和第三个参数，不能直接套用@语法。<code>getter</code>装饰器和不带<code>getter</code>的属性装饰器效果是一样的，估计只是为了凑数，本身没有任何存在的意义。经过<code>@property</code>装饰过的函数返回的不再是一个函数，而是一个<code>property</code>对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>property()</span><br><span class="line">&lt;property object at <span class="number">0x10ff07940</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="staticmethod，-classmethod"><a href="#staticmethod，-classmethod" class="headerlink" title="@staticmethod，@classmethod"></a>@staticmethod，@classmethod</h4><p>有了<code>@property</code>装饰器的了解，这两个装饰器的原理是差不多的。<code>@staticmethod</code>返回的是一个<code>staticmethod</code>类对象，而<code>@classmethod</code>返回的是一个<code>classmethod</code>类对象。他们都是调用的是各自的<code>__init__()</code>构造函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classmethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    classmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">    """</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, function)</span>:</span> <span class="comment"># for @classmethod decorator</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    staticmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, function)</span>:</span> <span class="comment"># for @staticmethod decorator</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>装饰器的@语法就等同调用了这两个类的构造函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等同于 bar = staticmethod(bar)</span></span><br></pre></td></tr></table></figure><p>至此，我们上文提到的装饰器接口定义可以更加明确一些，装饰器必须接受一个callable对象，其实它并不关心你返回什么，可以是另外一个callable对象（大部分情况），也可以是其他类对象，比如property。</p><h2 id="装饰器里的那些坑"><a href="#装饰器里的那些坑" class="headerlink" title="装饰器里的那些坑"></a>装饰器里的那些坑</h2><p>装饰器可以让你代码更加优雅，减少重复，但也不全是优点，也会带来一些问题。</p><h3 id="位置错误的代码"><a href="#位置错误的代码" class="headerlink" title="位置错误的代码"></a>位置错误的代码</h3><p>让我们直接看示例代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">html_tags</span><span class="params">(tag_name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'begin outer function.'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"begin of inner wrapper function."</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            content = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"&lt;&#123;tag&#125;&gt;&#123;content&#125;&lt;/&#123;tag&#125;&gt;"</span>.format(tag=tag_name, content=content)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'end of inner wrapper function.'</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'end of outer function'</span></span><br><span class="line">    <span class="keyword">return</span> wrapper_</span><br><span class="line"></span><br><span class="line"><span class="meta">@html_tags('b')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name=<span class="string">'Toby'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello &#123;&#125;!'</span>.format(name)</span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>在装饰器中我在各个可能的位置都加上了print语句，用于记录被调用的情况。你知道他们最后打印出来的顺序吗？如果你心里没底，那么最好不要在装饰器函数之外添加逻辑功能，否则这个装饰器就不受你控制了。以下是输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin outer function.</span><br><span class="line">end of outer function</span><br><span class="line">begin of inner wrapper function.</span><br><span class="line">end of inner wrapper function.</span><br><span class="line">&lt;b&gt;Hello Toby!&lt;&#x2F;b&gt;</span><br><span class="line">&lt;b&gt;Hello Toby!&lt;&#x2F;b&gt;</span><br></pre></td></tr></table></figure><h3 id="错误的函数签名和文档"><a href="#错误的函数签名和文档" class="headerlink" title="错误的函数签名和文档"></a>错误的函数签名和文档</h3><p>装饰器装饰过的函数看上去名字没变，其实已经变了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""print log before a function."""</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG] &#123;&#125;: enter &#123;&#125;()"</span>.format(datetime.now(), func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="string">"""say something"""</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> say.__name__  <span class="comment"># wrapper</span></span><br></pre></td></tr></table></figure><p>为什么会这样呢？只要你想想装饰器的语法糖@代替的东西就明白了。@等同于这样的写法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">say = logging(say)</span><br></pre></td></tr></table></figure><p><code>logging</code>其实返回的函数名字刚好是<code>wrapper</code>，那么上面的这个语句刚好就是把这个结果赋值给<code>say</code>，<code>say</code>的<code>__name__</code>自然也就是<code>wrapper</code>了，不仅仅是<code>name</code>，其他属性也都是来自<code>wrapper</code>，比如<code>doc</code>，<code>source</code>等等。</p><p>使用标准库里的<code>functools.wraps</code>，可以<strong>基本</strong>解决这个问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""print log before a function."""</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[DEBUG] &#123;&#125;: enter &#123;&#125;()"</span>.format(datetime.now(), func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="string">"""say something"""</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> say.__name__  <span class="comment"># say</span></span><br><span class="line"><span class="keyword">print</span> say.__doc__ <span class="comment"># say something</span></span><br></pre></td></tr></table></figure><p>看上去不错！主要问题解决了，但其实还不太完美。因为函数的签名和源码还是拿不到的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">print</span> inspect.getargspec(say)  <span class="comment"># failed</span></span><br><span class="line"><span class="keyword">print</span> inspect.getsource(say)  <span class="comment"># failed</span></span><br></pre></td></tr></table></figure><p>如果要彻底解决这个问题可以借用第三方包，比如<code>wrapt</code>。后文有介绍。</p><h3 id="不能装饰-staticmethod-或者-classmethod"><a href="#不能装饰-staticmethod-或者-classmethod" class="headerlink" title="不能装饰@staticmethod 或者 @classmethod"></a>不能装饰@staticmethod 或者 @classmethod</h3><p>当你想把装饰器用在一个静态方法或者类方法时，不好意思，报错了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></span><br><span class="line">        self.model = model</span><br><span class="line"></span><br><span class="line"><span class="meta">    @logging  # 装饰实例方法，OK</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&#123;&#125; is running!"</span>.format(self.model)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @logging  # 装饰静态方法，Failed</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_model_for</span><span class="params">(obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, Car):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"The model of your car is &#123;&#125;"</span>.format(obj.model)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"&#123;&#125; is not a car!"</span>.format(obj)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">  File "example_4.py", line 10, in logging</span></span><br><span class="line"><span class="string">    @wraps(func)</span></span><br><span class="line"><span class="string">  File "C:\Python27\lib\functools.py", line 33, in update_wrapper</span></span><br><span class="line"><span class="string">    setattr(wrapper, attr, getattr(wrapped, attr))</span></span><br><span class="line"><span class="string">AttributeError: 'staticmethod' object has no attribute '__module__'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>前面已经解释了<code>@staticmethod</code>这个装饰器，其实它返回的并不是一个callable对象，而是一个<code>staticmethod</code>对象，那么它是不符合装饰器要求的（比如传入一个callable对象），你自然不能在它之上再加别的装饰器。要解决这个问题很简单，只要把你的装饰器放在<code>@staticmethod</code>之前就好了，因为你的装饰器返回的还是一个正常的函数，然后再加上一个<code>@staticmethod</code>是不会出问题的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></span><br><span class="line">        self.model = model</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @logging  # 在@staticmethod之前装饰，OK</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_model_for</span><span class="params">(obj)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="如何优化你的装饰器"><a href="#如何优化你的装饰器" class="headerlink" title="如何优化你的装饰器"></a>如何优化你的装饰器</h2><p>嵌套的装饰函数不太直观，我们可以使用第三方包类改进这样的情况，让装饰器函数可读性更好。</p><h3 id="decorator-py"><a href="#decorator-py" class="headerlink" title="decorator.py"></a>decorator.py</h3><p><a href="http://pythonhosted.org/decorator/documentation.html" target="_blank" rel="noopener">decorator.py</a> 是一个非常简单的装饰器加强包。你可以很直观的先定义包装函数<code>wrapper()</code>，再使用<code>decorate(func, wrapper)</code>方法就可以完成一个装饰器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""print log before a function."""</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG] &#123;&#125;: enter &#123;&#125;()"</span>.format(datetime.now(), func.__name__)</span><br><span class="line">    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> decorate(func, wrapper)  <span class="comment"># 用wrapper装饰func</span></span><br></pre></td></tr></table></figure><p>你也可以使用它自带的<code>@decorator</code>装饰器来完成你的装饰器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG] &#123;&#125;: enter &#123;&#125;()"</span>.format(datetime.now(), func.__name__)</span><br><span class="line">    <span class="keyword">return</span> func(*args, **kwargs)</span><br></pre></td></tr></table></figure><p><code>decorator.py</code>实现的装饰器能完整保留原函数的<code>name</code>，<code>doc</code>和<code>args</code>，唯一有问题的就是<code>inspect.getsource(func)</code>返回的还是装饰器的源代码，你需要改成<code>inspect.getsource(func.__wrapped__)</code>。</p><h3 id="wrapt"><a href="#wrapt" class="headerlink" title="wrapt"></a>wrapt</h3><p><a href="http://wrapt.readthedocs.io/en/latest/quick-start.html" target="_blank" rel="noopener">wrapt</a>是一个功能非常完善的包，用于实现各种你想到或者你没想到的装饰器。使用wrapt实现的装饰器你不需要担心之前inspect中遇到的所有问题，因为它都帮你处理了，甚至<code>inspect.getsource(func)</code>也准确无误。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wrapt</span><br><span class="line"></span><br><span class="line"><span class="comment"># without argument in decorator</span></span><br><span class="line"><span class="meta">@wrapt.decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(wrapped, instance, args, kwargs)</span>:</span>  <span class="comment"># instance is must</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[DEBUG]: enter &#123;&#125;()"</span>.format(wrapped.__name__)</span><br><span class="line">    <span class="keyword">return</span> wrapped(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>使用wrapt你只需要定义一个装饰器函数，但是函数签名是固定的，必须是<code>(wrapped, instance, args, kwargs)</code>，注意第二个参数<code>instance</code>是必须的，就算你不用它。当装饰器装饰在不同位置时它将得到不同的值，比如装饰在类实例方法时你可以拿到这个类实例。根据<code>instance</code>的值你能够更加灵活的调整你的装饰器。另外，<code>args</code>和<code>kwargs</code>也是固定的，注意前面<strong>没有星号</strong>。在装饰器内部调用原函数时才带星号。</p><p>如果你需要使用wrapt写一个带参数的装饰器，可以这样写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line"><span class="meta">    @wrapt.decorator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(wrapped, instance, args, kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[&#123;&#125;]: enter &#123;&#125;()"</span>.format(level, wrapped.__name__)</span><br><span class="line">        <span class="keyword">return</span> wrapped(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level="INFO")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(work)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>关于wrapt的使用，建议查阅官方文档，在此不在赘述。</p><ul><li><a href="http://wrapt.readthedocs.io/en/latest/quick-start.html" target="_blank" rel="noopener">http://wrapt.readthedocs.io/en/latest/quick-start.html</a></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Python的装饰器和Java的注解（Annotation）并不是同一回事，和C#中的特性（Attribute）也不一样，完全是两个概念。</p><p>装饰器的理念是对原函数、对象的加强，相当于重新封装，所以一般装饰器函数都被命名为<code>wrapper()</code>，意义在于包装。函数只有在被调用时才会发挥其作用。比如<code>@logging</code>装饰器可以在函数执行时额外输出日志，<code>@cache</code>装饰过的函数可以缓存计算结果等等。</p><p>而注解和特性则是对目标函数或对象添加一些属性，相当于将其分类。这些属性可以通过反射拿到，在程序运行时对不同的特性函数或对象加以干预。比如带有<code>Setup</code>的函数就当成准备步骤执行，或者找到所有带有<code>TestMethod</code>的函数依次执行等等。</p><p>至此我所了解的装饰器已经讲完，但是还有一些内容没有提到，比如装饰类的装饰器。有机会再补充。谢谢观看。</p><blockquote><p>本文源码 <a href="https://github.com/tobyqin/python_decorator" target="_blank" rel="noopener">https://github.com/tobyqin/python_decorator</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说Python中的闭包 - Closure</title>
      <link href="posts/2016-10-23/python-closure/"/>
      <url>posts/2016-10-23/python-closure/</url>
      
        <content type="html"><![CDATA[<p>Python中的闭包不是一个一说就能明白的概念，但是随着你往学习的深入，无论如何你都需要去了解这么一个东西。</p><a id="more"></a><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>我们尝试从概念上去理解一下闭包。</p><blockquote><p>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。<br>—— <a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>用比较容易懂的人话说，就是当某个<strong>函数</strong>被当成对象返回时，<strong>夹带了外部变量</strong>，就形成了一个闭包。看例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_printer</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> msg  <span class="comment"># 夹带私货（外部变量）</span></span><br><span class="line">    <span class="keyword">return</span> printer  <span class="comment"># 返回的是函数，带私货的函数</span></span><br><span class="line"></span><br><span class="line">printer = make_printer(<span class="string">'Foo!'</span>)</span><br><span class="line">printer()</span><br></pre></td></tr></table></figure><p>支持将函数当成对象使用的编程语言，一般都支持闭包。比如Python, JavaScript。</p><h2 id="如何理解闭包"><a href="#如何理解闭包" class="headerlink" title="如何理解闭包"></a>如何理解闭包</h2><p>闭包存在有什么意义呢？为什么需要闭包？</p><p>我个人认为，闭包存在的意义就是它夹带了外部变量（私货），如果它不夹带私货，它和普通的函数就没有任何区别。<strong>同一个的函数</strong>夹带了<strong>不同的私货</strong>，就实现了不同的功能。其实你也可以这么理解，闭包和面向接口编程的概念很像，可以把闭包理解成轻量级的接口封装。</p><blockquote><p>接口定义了一套对方法签名的约束规则。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(tag_name)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_tag</span><span class="params">(content)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;&#123;0&#125;&gt;&#123;1&#125;&lt;/&#123;0&#125;&gt;"</span>.format(tag_name, content)</span><br><span class="line">    <span class="keyword">return</span> add_tag</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line">add_tag = tag(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">print</span> add_tag(content)</span><br><span class="line"><span class="comment"># &lt;a&gt;Hello&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line">add_tag = tag(<span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">print</span> add_tag(content)</span><br><span class="line"><span class="comment"># &lt;b&gt;Hello&lt;/b&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子里，我们想要一个给<code>content</code>加<code>tag</code>的功能，但是具体的<code>tag_name</code>是什么样子的要根据实际需求来定，对外部调用的接口已经确定，就是<code>add_tag(content)</code>。如果按照面向接口方式实现，我们会先把<code>add_tag</code>写成接口，指定其参数和返回类型，然后分别去实现a和b的<code>add_tag</code>。</p><p>但是在闭包的概念中，<code>add_tag</code>就是一个函数，它需要<code>tag_name</code>和<code>content</code>两个参数，只不过<code>tag_name</code>这个参数是打包带走的。所以一开始时就可以告诉我怎么打包，然后带走就行。</p><p>上面的例子不太生动，其实在我们生活和工作中，闭包的概念也很常见。比如说手机拨号，你只关心电话打给谁，而不会去纠结每个品牌的手机是怎么实现的，用到了哪些模块。再比如去餐馆吃饭，你只要付钱就可以享受到服务，你并不知道那桌饭菜用了多少地沟油。这些都可以看成闭包，返回来的是一些功能或者服务（打电话，用餐），但是这些功能使用了外部变量（天线，地沟油等等）。</p><p>你也可以把一个类实例看成闭包，当你在构造这个类时，使用了不同的参数，这些参数就是闭包里的包，这个类对外提供的方法就是闭包的功能。但是类远远大于闭包，因为闭包只是一个可以执行的函数，但是类实例则有可能提供很多方法。</p><h2 id="何时使用闭包"><a href="#何时使用闭包" class="headerlink" title="何时使用闭包"></a>何时使用闭包</h2><p>其实闭包在Python中很常见，只不过你没特别注意这就是一个闭包。比如Python中的装饰器Decorator，假如你需要写一个带参数的装饰器，那么一般都会生成闭包。</p><p>为什么？因为Python的装饰器是一个固定的函数接口形式。它要求你的装饰器函数（或装饰器类）必须接受一个函数并返回一个函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># how to define</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func1)</span>:</span>  <span class="comment"># 接受一个callable对象</span></span><br><span class="line">    <span class="keyword">return</span> func2  <span class="comment"># 返回一个对象，一般为函数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># how to use</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target_func</span><span class="params">(args)</span>:</span> <span class="comment"># 目标函数</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式一，直接包裹</span></span><br><span class="line">result = wrapper(target_func)(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式二，使用@语法，等同于方式一</span></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target_func</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">result = target_func()</span><br></pre></td></tr></table></figure><p>那么如果你的装饰器如果带参数呢？那么你就需要在原来的装饰器上再包一层，用于接收这些参数。这些参数（私货）传递到内层的装饰器里后，闭包就形成了。所以说当你的装饰器需要自定义参数时，一般都会形成闭包。（类装饰器例外）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">html_tags</span><span class="params">(tag_name)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            content = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;&#123;tag&#125;&gt;&#123;content&#125;&lt;/&#123;tag&#125;&gt;"</span>.format(tag=tag_name, content=content)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper_</span><br><span class="line"></span><br><span class="line"><span class="meta">@html_tags('b')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name=<span class="string">'Toby'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello &#123;&#125;!'</span>.format(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用@的写法如下</span></span><br><span class="line"><span class="comment"># hello = html_tag('b')(hello)</span></span><br><span class="line"><span class="comment"># html_tag('b') 是一个闭包，它接受一个函数，并返回一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hello()  <span class="comment"># &lt;b&gt;Hello Toby!&lt;/b&gt;</span></span><br><span class="line"><span class="keyword">print</span> hello(<span class="string">'world'</span>)  <span class="comment"># &lt;b&gt;Hello world!&lt;/b&gt;</span></span><br></pre></td></tr></table></figure><p>关于装饰器的更深入剖析，可以看我写的另外一篇博客。</p><h2 id="再深入一点"><a href="#再深入一点" class="headerlink" title="再深入一点"></a>再深入一点</h2><p>其实也不必太深入，理解这上面的概念，很多看起来头疼的代码也不过如此。</p><p>下面让我们来了解一下闭包的包到底长什么样子。其实闭包函数相对与普通函数会多出一个<code>__closure__</code>的属性，里面定义了一个元组用于存放所有的<code>cell</code>对象，每个<code>cell</code>对象一一保存了这个闭包中所有的外部变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_printer</span><span class="params">(msg1, msg2)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> msg1, msg2</span><br><span class="line">    <span class="keyword">return</span> printer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printer = make_printer(<span class="string">'Foo'</span>, <span class="string">'Bar'</span>)  <span class="comment"># 形成闭包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printer.__closure__   <span class="comment"># 返回cell元组</span></span><br><span class="line">(&lt;cell at <span class="number">0x03A10930</span>: str object at <span class="number">0x039DA218</span>&gt;, &lt;cell at <span class="number">0x03A10910</span>: str object at <span class="number">0x039DA488</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printer.__closure__[<span class="number">0</span>].cell_contents  <span class="comment"># 第一个外部变量</span></span><br><span class="line"><span class="string">'Foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>printer.__closure__[<span class="number">1</span>].cell_contents  <span class="comment"># 第二个外部变量</span></span><br><span class="line"><span class="string">'Bar'</span></span><br></pre></td></tr></table></figure><p>原理就是这么简单。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.the5fire.com/closure-in-python.html" target="_blank" rel="noopener">https://www.the5fire.com/closure-in-python.html</a></li><li><a href="http://stackoverflow.com/questions/4020419/why-arent-python-nested-functions-called-closures" target="_blank" rel="noopener">http://stackoverflow.com/questions/4020419/why-arent-python-nested-functions-called-closures</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improve Assertion In Python</title>
      <link href="posts/2016-10-20/assertion-in-python-en/"/>
      <url>posts/2016-10-20/assertion-in-python-en/</url>
      
        <content type="html"><![CDATA[<p>Assertion is the basics of testing.</p><a id="more"></a><h3 id="Why-not-using-Python-Assert"><a href="#Why-not-using-Python-Assert" class="headerlink" title="Why not using Python Assert"></a>Why not using Python Assert</h3><p>Assertion in Python is pretty simple, you can assert any condition by <code>assert</code> statement.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> isinstance(<span class="string">'Hello'</span>, str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> isinstance(<span class="string">'Hello'</span>, int)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure><p>It is great that <code>assert</code> can stop your application/tests when something goes wrong. However, it is not good enough that the <strong>AssertionError</strong> does not expose more information. In above example, we received the error message only with file name and line number, you have to start debugger to discover more. </p><h3 id="Improved-Solution-1"><a href="#Improved-Solution-1" class="headerlink" title="Improved Solution #1"></a>Improved Solution #1</h3><p>An improved solution is always appending message in your assertion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"nothin is impossible."</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = <span class="string">"nothing"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> key <span class="keyword">in</span> s, <span class="string">"Key: '&#123;&#125;' is not in Target: '&#123;&#125;'"</span>.format(key, s)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: Key: <span class="string">'nothing'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> Target: <span class="string">'nothin is impossible.'</span></span><br></pre></td></tr></table></figure><p>Well, it fixed the problem, but it not elegant.  If you are a QA engineer, you have to do a lot of assertions in thousands of test cases. With above solution, I would choose to die :-|</p><h3 id="Improved-Solution-2"><a href="#Improved-Solution-2" class="headerlink" title="Improved Solution #2"></a>Improved Solution #2</h3><p>You might know about test frameworks, how do they do assertion? Yes, using test framework assertion is a nice alternation. </p><h4 id="py-test"><a href="#py-test" class="headerlink" title="py.test"></a>py.test</h4><p>If you are running tests with <a href="https://pypi.python.org/pypi/pytest" target="_blank" rel="noopener">py.test</a>, you can keep everything unchanged in your code, the failure message will tell you what is going on in failed assertion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_case</span><span class="params">()</span>:</span></span><br><span class="line">    expected = <span class="string">"Hello"</span></span><br><span class="line">    actual = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">assert</span> expected == actual</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pytest.main()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">================================== FAILURES ===================================</span></span><br><span class="line"><span class="string">__________________________________ test_case __________________________________</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def test_case():</span></span><br><span class="line"><span class="string">        expected = "Hello"</span></span><br><span class="line"><span class="string">        actual = "hello"</span></span><br><span class="line"><span class="string">&gt;       assert expected == actual</span></span><br><span class="line"><span class="string">E       assert 'Hello' == 'hello'</span></span><br><span class="line"><span class="string">E         - Hello</span></span><br><span class="line"><span class="string">E         ? ^</span></span><br><span class="line"><span class="string">E         + hello</span></span><br><span class="line"><span class="string">E         ? ^</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">assertion_in_python.py:7: AssertionError</span></span><br><span class="line"><span class="string">========================== 1 failed in 0.05 seconds ===========================</span></span><br><span class="line"><span class="string">"""</span><span class="string">"</span></span><br></pre></td></tr></table></figure><h4 id="unittest"><a href="#unittest" class="headerlink" title="unittest"></a>unittest</h4><p>Python <a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">unittest</a> module provides assertion feature in itself, it recommends <code>self.assertXXX()</code> methods, but not <code>assert XXX</code> statements.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStringMethods</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="string">'foo'</span>.upper(), <span class="string">'FoO'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Failure</span></span><br><span class="line"><span class="string">Expected :'FOO'</span></span><br><span class="line"><span class="string">Actual   :'FoO'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "assertion_in_python.py", line 6, in test_upper</span></span><br><span class="line"><span class="string">    self.assertEqual('foo'.upper(), 'FoO')</span></span><br><span class="line"><span class="string">AssertionError: 'FOO' != 'FoO'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="ptest"><a href="#ptest" class="headerlink" title="ptest"></a>ptest</h4><p>I like <a href="https://pypi.python.org/pypi/ptest" target="_blank" rel="noopener">ptest</a> very much, its assertion feature is more readable and smart. Thanks its author Karl :-)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ptest.decorator <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ptest.assertion <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestClass()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCases</span>:</span></span><br><span class="line"><span class="meta">    @Test()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">        actual = <span class="string">'foo'</span></span><br><span class="line">        expected = <span class="string">'bar'</span></span><br><span class="line">        assert_that(expected).is_equal_to(actual)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Start to run following 1 tests:</span></span><br><span class="line"><span class="string">------------------------------</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">[demo.assertion_in_python.TestCases.test1@Test] Failed with following message:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">AssertionError: Unexpectedly that the str &lt;bar&gt; is not equal to str &lt;foo&gt;.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="Improved-Solution-3"><a href="#Improved-Solution-3" class="headerlink" title="Improved Solution #3"></a>Improved Solution #3</h3><p>It is not only you and me are frustrating on python assertion, so people created packages to replace default assertion. I strongly recommend you should have a try for <a href="https://pypi.python.org/pypi/assertpy" target="_blank" rel="noopener">assertpy</a> package, which is high rating and powerful.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install assertpy</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> assertpy <span class="keyword">import</span> assert_that</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_something</span><span class="params">()</span>:</span></span><br><span class="line">    assert_that(<span class="number">1</span> + <span class="number">2</span>).is_equal_to(<span class="number">3</span>)</span><br><span class="line">    assert_that(<span class="string">'foobar'</span>)\</span><br><span class="line">        .is_length(<span class="number">6</span>)\</span><br><span class="line">        .starts_with(<span class="string">'foo'</span>)\</span><br><span class="line">        .ends_with(<span class="string">'bar'</span>)</span><br><span class="line">    assert_that([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])\</span><br><span class="line">        .contains(<span class="string">'a'</span>)\</span><br><span class="line">        .does_not_contain(<span class="string">'x'</span>)</span><br></pre></td></tr></table></figure><p>From its <a href="https://github.com/ActivisionGameScience/assertpy" target="_blank" rel="noopener">github home page</a> you will see it supports assertion in most test scenarios.</p><ul><li>Strings</li><li>Numbers</li><li>Lists</li><li>Tuples</li><li>Dicts</li><li>Sets</li><li>Booleans</li><li>Dates</li><li>Files</li><li>Objects</li></ul><p>The assertion message is really helpful, they looks like:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expected &lt;foo&gt; to be of length &lt;4&gt;, but was &lt;3&gt;.</span><br><span class="line">Expected &lt;foo&gt; to be empty string, but was not.</span><br><span class="line">Expected &lt;False&gt;, but was not.</span><br><span class="line">Expected &lt;foo&gt; to contain only digits, but did not.</span><br><span class="line">Expected &lt;123&gt; to contain only alphabetic chars, but did not.</span><br><span class="line">Expected &lt;foo&gt; to contain only uppercase chars, but did not.</span><br><span class="line">Expected &lt;FOO&gt; to contain only lowercase chars, but did not.</span><br><span class="line">Expected &lt;foo&gt; to be equal to &lt;bar&gt;, but was not.</span><br><span class="line">Expected &lt;foo&gt; to be not equal to &lt;foo&gt;, but was.</span><br><span class="line">Expected &lt;foo&gt; to be case-insensitive equal to &lt;BAR&gt;, but was not.</span><br></pre></td></tr></table></figure><p>Before I found this package I am thinking about writing common assertion package for Labs, but now, I don’t think I should spend time to invent the wheel again.</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Assertion is pretty important to a system, it can increase stability and save your time in debugging. </p><p>Replacing all built-in assertion to 3rd party assertion in your code is not a good idea, because IDE like PyCharm knows nothing about that, so it will not provide auto-completion for those assertion. </p><p>So my suggestion is, using more powerful assert functions in scenarios that you really want to verify something, keeping built-in assertion where you might fall in a pitfall, and with essential message. Keep It Simple and Stupid.</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software testing </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中不尽如人意的断言Assertion</title>
      <link href="posts/2016-10-20/assertion-in-python/"/>
      <url>posts/2016-10-20/assertion-in-python/</url>
      
        <content type="html"><![CDATA[<p>断言是测试的氧气，无断言，不测试。</p><a id="more"></a><h3 id="Python-Assert-为何不尽如人意"><a href="#Python-Assert-为何不尽如人意" class="headerlink" title="Python Assert 为何不尽如人意"></a>Python Assert 为何不尽如人意</h3><p>Python中的断言用起来非常简单，你可以在<code>assert</code>后面跟上任意判断条件，如果断言失败则会抛出异常。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> isinstance(<span class="string">'Hello'</span>, str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> isinstance(<span class="string">'Hello'</span>, int)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure><p>其实<code>assert</code>看上去不错，然而用起来并不爽。就比如有人告诉你程序错了，但是不告诉哪里错了。很多时候这样的<code>assert</code>还不如不写，写了我就想骂娘。直接抛一个异常来得更痛快一些。</p><h3 id="改进方案-1"><a href="#改进方案-1" class="headerlink" title="改进方案 #1"></a>改进方案 #1</h3><p>一个稍微改进一丢丢的方案就是把必要的信息也放到<code>assert</code>语句后面，比如这样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"nothin is impossible."</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = <span class="string">"nothing"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> key <span class="keyword">in</span> s, <span class="string">"Key: '&#123;&#125;' is not in Target: '&#123;&#125;'"</span>.format(key, s)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: Key: <span class="string">'nothing'</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> Target: <span class="string">'nothin is impossible.'</span></span><br></pre></td></tr></table></figure><p>看上去还行吧，但是其实写的很蛋疼。假如你是一名测试汪，有成千上万的测试案例需要做断言做验证，相信你面对以上做法，心中一定有千万只那种马奔腾而过。</p><h3 id="改进方案-2"><a href="#改进方案-2" class="headerlink" title="改进方案 #2"></a>改进方案 #2</h3><p>既然你是搞测试的，相比听过不少测试框架。你猜到我要说什么了吧？对，不用测试框架里的断言机制，你是不是洒。</p><h4 id="py-test"><a href="#py-test" class="headerlink" title="py.test"></a>py.test</h4><p><a href="https://pypi.python.org/pypi/pytest" target="_blank" rel="noopener">py.test</a> 是一个轻量级的测试框架，所以它压根就没写自己的断言系统，但是它对Python自带的断言做了强化处理，如果断言失败，那么框架本身会尽可能多地提供断言失败的原因。那么也就意味着，用<strong>py.test</strong>实现测试，你一行代码都不用改。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_case</span><span class="params">()</span>:</span></span><br><span class="line">    expected = <span class="string">"Hello"</span></span><br><span class="line">    actual = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">assert</span> expected == actual</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pytest.main()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">================================== FAILURES ===================================</span></span><br><span class="line"><span class="string">__________________________________ test_case __________________________________</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def test_case():</span></span><br><span class="line"><span class="string">        expected = "Hello"</span></span><br><span class="line"><span class="string">        actual = "hello"</span></span><br><span class="line"><span class="string">&gt;       assert expected == actual</span></span><br><span class="line"><span class="string">E       assert 'Hello' == 'hello'</span></span><br><span class="line"><span class="string">E         - Hello</span></span><br><span class="line"><span class="string">E         ? ^</span></span><br><span class="line"><span class="string">E         + hello</span></span><br><span class="line"><span class="string">E         ? ^</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">assertion_in_python.py:7: AssertionError</span></span><br><span class="line"><span class="string">========================== 1 failed in 0.05 seconds ===========================</span></span><br><span class="line"><span class="string">"""</span><span class="string">"</span></span><br></pre></td></tr></table></figure><h4 id="unittest"><a href="#unittest" class="headerlink" title="unittest"></a>unittest</h4><p>Python自带的<a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">unittest</a>单元测试框架就有了自己的断言方法 <code>self.assertXXX()</code> ，而且不推荐使用<code>assert XXX</code>语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStringMethods</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="string">'foo'</span>.upper(), <span class="string">'FoO'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Failure</span></span><br><span class="line"><span class="string">Expected :'FOO'</span></span><br><span class="line"><span class="string">Actual   :'FoO'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "assertion_in_python.py", line 6, in test_upper</span></span><br><span class="line"><span class="string">    self.assertEqual('foo'.upper(), 'FoO')</span></span><br><span class="line"><span class="string">AssertionError: 'FOO' != 'FoO'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="ptest"><a href="#ptest" class="headerlink" title="ptest"></a>ptest</h4><p>我非常喜欢<a href="https://pypi.python.org/pypi/ptest" target="_blank" rel="noopener">ptest</a>，感谢Karl大神写了这么一个测试框架。ptest中的断言可读性很好，而且智能提示也很方便你通过IDE轻松完成各种断言语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ptest.decorator <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ptest.assertion <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestClass()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCases</span>:</span></span><br><span class="line"><span class="meta">    @Test()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">        actual = <span class="string">'foo'</span></span><br><span class="line">        expected = <span class="string">'bar'</span></span><br><span class="line">        assert_that(expected).is_equal_to(actual)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Start to run following 1 tests:</span></span><br><span class="line"><span class="string">------------------------------</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">[demo.assertion_in_python.TestCases.test1@Test] Failed with following message:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">AssertionError: Unexpectedly that the str &lt;bar&gt; is not equal to str &lt;foo&gt;.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="改进方案-3"><a href="#改进方案-3" class="headerlink" title="改进方案 #3"></a>改进方案 #3</h3><p>不仅仅是你和我对Python中的断言表示不满足，所以大家都争相发明自己的assert包。在这里我强烈推荐<a href="https://pypi.python.org/pypi/assertpy" target="_blank" rel="noopener">assertpy</a> 这个包，它异常强大而且好评如潮。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install assertpy</span><br></pre></td></tr></table></figure><p><strong>看例子:</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> assertpy <span class="keyword">import</span> assert_that</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_something</span><span class="params">()</span>:</span></span><br><span class="line">    assert_that(<span class="number">1</span> + <span class="number">2</span>).is_equal_to(<span class="number">3</span>)</span><br><span class="line">    assert_that(<span class="string">'foobar'</span>)\</span><br><span class="line">        .is_length(<span class="number">6</span>)\</span><br><span class="line">        .starts_with(<span class="string">'foo'</span>)\</span><br><span class="line">        .ends_with(<span class="string">'bar'</span>)</span><br><span class="line">    assert_that([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])\</span><br><span class="line">        .contains(<span class="string">'a'</span>)\</span><br><span class="line">        .does_not_contain(<span class="string">'x'</span>)</span><br></pre></td></tr></table></figure><p>从它的<a href="https://github.com/ActivisionGameScience/assertpy" target="_blank" rel="noopener">github 主页</a> 主页文档上你会发现它支持了几乎你能想到的所有测试场景，包括但不限于以下列表。</p><ul><li>Strings</li><li>Numbers</li><li>Lists</li><li>Tuples</li><li>Dicts</li><li>Sets</li><li>Booleans</li><li>Dates</li><li>Files</li><li>Objects</li></ul><p>而且它的断言信息简洁明了，不多不少。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expected &lt;foo&gt; to be of length &lt;4&gt;, but was &lt;3&gt;.</span><br><span class="line">Expected &lt;foo&gt; to be empty string, but was not.</span><br><span class="line">Expected &lt;False&gt;, but was not.</span><br><span class="line">Expected &lt;foo&gt; to contain only digits, but did not.</span><br><span class="line">Expected &lt;123&gt; to contain only alphabetic chars, but did not.</span><br><span class="line">Expected &lt;foo&gt; to contain only uppercase chars, but did not.</span><br><span class="line">Expected &lt;FOO&gt; to contain only lowercase chars, but did not.</span><br><span class="line">Expected &lt;foo&gt; to be equal to &lt;bar&gt;, but was not.</span><br><span class="line">Expected &lt;foo&gt; to be not equal to &lt;foo&gt;, but was.</span><br><span class="line">Expected &lt;foo&gt; to be case-insensitive equal to &lt;BAR&gt;, but was not.</span><br></pre></td></tr></table></figure><p>在发现assertpy之前我也想写一个类似的包，尽可能通用一些。但是现在，我为毛要重新去造轮子？完全没必要！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>断言在软件系统中有非常重要的作用，写的好可以让你的系统更稳定，也可以让你有更多真正面对对象的时间，而不是在调试代码。</p><p>Python中默认的断言语句其实还有一个作用，如果你写了一个类型相关的断言，IDE会把这个对象当成这种类型，这时候智能提示就有如神助。</p><p>要不要把内置的断言语句换成可读性更好功能更强大的第三方断言，完全取决于实际情况。比如你真的需要验证某个东西并且很关心验证结果，那么必须不能用简单的assert；如果你只是担心某个点可能有坑或者让IDE认识某个对象，用内置的assert既简单又方便。</p><p>总之，你自己看着办。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software testing </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Jenkins中TFS Plugin Mapping错误的问题</title>
      <link href="posts/2016-10-19/how-to-fix-TFS-workspace-mapping-error-in-Jenkins/"/>
      <url>posts/2016-10-19/how-to-fix-TFS-workspace-mapping-error-in-Jenkins/</url>
      
        <content type="html"><![CDATA[<p>处理TFS的问题备忘。</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>Once you had update in TFS workspace for Jenkin TFS plugin, you might get error like bellow:</p><p>如果你把 Jenkins 中TFS插件更新过，那么你有可能会遇到Mapping错误的问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[workspace] $ &quot;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\IDE\TF.exe&quot; workspaces -format:brief -server:http:&#x2F;&#x2F;tfs.xxx.com:8080&#x2F;tfs&#x2F;Default ********</span><br><span class="line">Collection: tfs.xxx.com\Default</span><br><span class="line">Workspace   Owner      Computer    Comment</span><br><span class="line">----------- ---------- ----------- --------------------------------------------</span><br><span class="line">MyServer newUser MyServer </span><br><span class="line">[workspace] $ &quot;C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\IDE\TF.exe&quot; workspace -new &quot;Hudson-My build job-MASTER;nam\newUser&quot; -noprompt -server:http:&#x2F;&#x2F;tfs.xxx.com:8080&#x2F;tfs&#x2F;Default ********</span><br><span class="line">The path D:\hudson\jobs\My build job\workspace is already mapped in workspace Hudson-My build job-MASTER;NAM\oldUser.</span><br><span class="line">FATAL: Executable returned an unexpected result code [100]</span><br><span class="line">ERROR: null</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>You should follow bellow steps to fix it.</p><p><strong>Step 1: Remove the TFS workspace</strong></p><ul><li><p>From VS:</p><ol><li>Open Team Explorer</li><li>Click Source Control Explorer</li><li>In the nav bar of the tool window there is a drop down labeled “Workspaces”.</li><li>Extend it and click on the “Workspaces…” option (yeah, a bit un-intuitive)</li><li>The “Manage Workspaces” window comes up. Click edit and you can add / remove / edit your workspace</li></ol></li><li><p>From the command line</p><ol><li>Type “tf workspace” from a developer command promt. It will bring up the “Manage Workspaces” directly!</li></ol></li></ul><p><strong>Step 2: Remove cache on this computer</strong> </p><p>Manually delete all the files in the TFS cache, they located at:</p><ul><li><p>C:\Users{UserName}\AppData\Local\Microsoft\Team Foundation\3.0\Cache</p></li><li><p>If there is a \4.0\Cache and \5.0\Cache existed, delete them all.</p></li></ul><p>你可以尝试通过以下步骤解决。</p><p><strong>Step 1: 删除该 TFS workspace</strong></p><ul><li><p>从Visual Studo操作:</p><ol><li>打开 Team Explorer</li><li>打开 Source Control Explorer</li><li>从工具栏下拉列表中找到 “Workspaces”，展开 “Workspaces…” </li><li>这时 “Manage Workspaces” 窗口会打开，在这里你可以编辑或者删除当前用户所有的 workspace</li></ol></li><li><p>从命令提示符操作</p><ol><li>在VS命令提示符中输入 “tf workspace” 可以看到相关命令，不行就查一下MSDN</li></ol></li></ul><p><strong>Step 2: 删除TFS相关Cache</strong> </p><p>手动清除TFS的Cache文件，参考以下路径。</p><ul><li>C:\Users{UserName}\AppData\Local\Microsoft\Team Foundation\3.0\Cache</li><li>如果3.0找不到就4.0，如果4.0也没有就5.0，取决于你的VS版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> tfs </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome, Andriod, JRE, Selenium各种开源工具的国内镜像</title>
      <link href="posts/2016-10-19/mirror-sites-in-china/"/>
      <url>posts/2016-10-19/mirror-sites-in-china/</url>
      
        <content type="html"><![CDATA[<p>在国内很多时候不翻墙真的很难做开发，本篇博客收集了一些知名工具和类库的国内镜像，当你没有VPN时，说不定能帮上你的大忙。</p><a id="more"></a><h3 id="淘宝镜像"><a href="#淘宝镜像" class="headerlink" title="淘宝镜像"></a>淘宝镜像</h3><p>淘宝的镜像更新速度非常及时，安装它在官网上说的，大概没10分钟会同步一次。</p><ul><li><p><a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p></li><li><p><a href="https://npm.taobao.org/mirrors" target="_blank" rel="noopener">https://npm.taobao.org/mirrors</a> </p></li></ul><p><strong>部分镜像列表</strong> </p><ul><li><p><a href="http://node.js/" target="_blank" rel="noopener">Node.js</a> 镜像: <a href="http://npm.taobao.org/mirrors/node" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/node</a></p></li><li><p>phantomjs 镜像: <a href="http://npm.taobao.org/mirrors/phantomjs" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/phantomjs</a></p></li><li><p>ChromeDriver 镜像: <a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver</a></p></li><li><p>OperaDriver 镜像: <a href="http://npm.taobao.org/mirrors/operadriver" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/operadriver</a></p></li><li><p>Selenium 镜像: <a href="http://npm.taobao.org/mirrors/selenium" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/selenium</a></p></li><li><p>NPM 镜像: <a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/npm/</a></p></li><li><p>Python 镜像: <a href="https://npm.taobao.org/mirrors/python/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/python/</a></p></li><li><p>Atom 镜像: <a href="https://npm.taobao.org/mirrors/atom/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/atom/</a></p></li></ul><h3 id="中国科学院镜像"><a href="#中国科学院镜像" class="headerlink" title="中国科学院镜像"></a>中国科学院镜像</h3><p><a href="http://www.cstnet.cn/" target="_blank" rel="noopener">中国科技网</a>是中国科学院领导下的学术性、非盈利的科研计算机网络。提供了Linux和Android开发相关镜像。</p><ul><li><a href="https://npm.taobao.org/" target="_blank" rel="noopener">http://www.opencas.org/mirrors/</a></li></ul><p><strong>部分镜像列表</strong></p><table><thead><tr><th><strong>Name</strong></th></tr></thead><tbody><tr><td><a href="http://mirrors.opencas.cn/android" target="_blank" rel="noopener">android</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/anthonos" target="_blank" rel="noopener">anthonos</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/apache" target="_blank" rel="noopener">apache</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/archlinux" target="_blank" rel="noopener">archlinux</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/centos" target="_blank" rel="noopener">centos</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/chaos_calmer" target="_blank" rel="noopener">chaos_calmer</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/cran" target="_blank" rel="noopener">cran</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/ctan" target="_blank" rel="noopener">ctan</a></td></tr><tr><td><a href="http://mirrors.opencas.cn/cygwin" target="_blank" rel="noopener">cygwin</a></td></tr></tbody></table><h3 id="gmirror镜像"><a href="#gmirror镜像" class="headerlink" title="gmirror镜像"></a>gmirror镜像</h3><p>这好像是一个个人镜像点，能活多久不知道，提供了Google Chrome，Android和Java相关工具的镜像。</p><ul><li><a href="http://gmirror.org/" target="_blank" rel="noopener">http://gmirror.org/</a></li></ul><p><strong>部分镜像列表</strong></p><ul><li>Chrome</li><li>Atom</li><li>Android SDK Tools Only</li><li>Android Studio</li><li>Android NDK</li><li>Go Lang</li><li>JDK, JRE</li><li>VirtualBox</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取 Google Chrome 谷歌浏览器离线安装包</title>
      <link href="posts/2016-10-18/get-chrome-full-installer/"/>
      <url>posts/2016-10-18/get-chrome-full-installer/</url>
      
        <content type="html"><![CDATA[<p>谷歌浏览器的离线安装包还真有用。</p><a id="more"></a><p>安装到个人用户目录，请使用以下链接：</p><ul><li><a href="http://www.google.com/chrome/eula.html?standalone=1" target="_blank" rel="noopener">Download Google Chrome Standalone Offline Installer (32-bit)</a></li><li><a href="http://www.google.com/chrome/eula.html?standalone=1&platform=win64" target="_blank" rel="noopener">Download Google Chrome Standalone Offline Installer (64-bit)</a></li></ul><p>安装后所有用户可用，请使用以下链接：</p><ul><li><a href="http://www.google.com/chrome/eula.html?system=true&standalone=1" target="_blank" rel="noopener">Google Chrome Offline Installer for All User Accounts (32-bit)</a></li><li><a href="http://www.google.com/chrome/eula.html?system=true&standalone=1&platform=win64" target="_blank" rel="noopener">Google Chrome Offline Installer for All User Accounts (64-bit)</a></li></ul><p>如果你需要安装Beta版本，请使用：</p><ul><li><a href="https://www.google.com/chrome/browser/beta.html?standalone=1" target="_blank" rel="noopener">Google Chrome Beta Version Offline Installer (32-bit)</a></li><li><a href="https://www.google.com/chrome/browser/beta.html?platform=win64&standalone=1" target="_blank" rel="noopener">Google Chrome Beta Version Offline Installer (64-bit)</a></li></ul><p>如果你需要安装Dev版本，请使用：</p><ul><li><a href="https://www.google.com/chrome/browser/index.html?extra=devchannel&standalone=1" target="_blank" rel="noopener">Google Chrome Dev Version Offline Installer (32-bit)</a></li><li><a href="https://www.google.com/chrome/browser/index.html?extra=devchannel&platform=win64&standalone=1" target="_blank" rel="noopener">Google Chrome Dev Version Offline Installer (64-bit)</a></li></ul><blockquote><p>以上安装包适用于Windows平台。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse string by word with Python</title>
      <link href="posts/2016-10-18/reverse-by-word-in-python-en/"/>
      <url>posts/2016-10-18/reverse-by-word-in-python-en/</url>
      
        <content type="html"><![CDATA[<p><strong>Reverse string by word</strong> is a very popular interview question. In python you can solve it easily with code like below.</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_string_by_word</span><span class="params">(s)</span>:</span></span><br><span class="line">    lst = s.split()  <span class="comment"># split by blank space by default</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(lst[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">s = <span class="string">'Power of Love'</span></span><br><span class="line"><span class="keyword">print</span> reverse_string_by_word(s)</span><br><span class="line"><span class="comment"># Love of Power</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Hello    World!'</span></span><br><span class="line"><span class="keyword">print</span> reverse_string_by_word(s)</span><br><span class="line"><span class="comment"># World! Hello</span></span><br></pre></td></tr></table></figure><p>We can see above implementation is good but not enough, in 2nd string we are expecting the <code>!</code> symbol should be reversed as well, and keep original blank spaces between words. (multiple spaces between <code>Hello</code> and <code>World</code> in the example)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> reverse_string_by_word(s)</span><br><span class="line"><span class="comment"># Expected: !World  Hello</span></span><br></pre></td></tr></table></figure><p>To improve the solution, a better choice should be <code>re</code> module. You might want to take a look at <a href="https://docs.python.org/2/library/re.html#re.split" target="_blank" rel="noopener"><code>re.split()</code></a> method.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Hello  World!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, s)    <span class="comment"># will discard blank spaces</span></span><br><span class="line">[<span class="string">'Hello'</span>, <span class="string">'World!'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\s+)'</span>, s)  <span class="comment"># will keep spaces as a group</span></span><br><span class="line">[<span class="string">'Hello'</span>, <span class="string">'  '</span>, <span class="string">'World!'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'&lt; Welcome to EF.COM! &gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, s)  <span class="comment"># split by spaces</span></span><br><span class="line">[<span class="string">'&lt;'</span>, <span class="string">'Welcome'</span>, <span class="string">'to'</span>, <span class="string">'EF.COM!'</span>, <span class="string">'&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\w+)'</span>, s)  <span class="comment"># exactly split by word</span></span><br><span class="line">[<span class="string">'&lt; '</span>, <span class="string">'Welcome'</span>, <span class="string">' '</span>, <span class="string">'to'</span>, <span class="string">' '</span>, <span class="string">'EF'</span>, <span class="string">'.'</span>, <span class="string">'COM'</span>, <span class="string">'! &gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\s+|\w+)'</span>, s)  <span class="comment"># split by space and word</span></span><br><span class="line">[<span class="string">'&lt;'</span>, <span class="string">' '</span>, <span class="string">''</span>, <span class="string">'Welcome'</span>, <span class="string">''</span>, <span class="string">' '</span>, <span class="string">''</span>, <span class="string">'to'</span>, <span class="string">''</span>, <span class="string">' '</span>, <span class="string">''</span>, <span class="string">'EF'</span>, <span class="string">'.'</span>, <span class="string">'COM'</span>, <span class="string">'!'</span>, <span class="string">' '</span>, <span class="string">'&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(re.split(<span class="string">r'(\s+|\w+)'</span>, s)[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">'&gt; !COM.EF to Welcome &lt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(re.split(<span class="string">r'(\s+)'</span>, s)[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">'&gt; EF.COM! to Welcome &lt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(re.split(<span class="string">r'(\w+)'</span>, s)[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">'! &gt;COM.EF to Welcome&lt; '</span></span><br></pre></td></tr></table></figure><p>If you would like to increase the readability a little bit, replacing list slicing to <code>reversed()</code> is a choice.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(reversed(re.split(<span class="string">r'(\s+|\w+)'</span>, s)))</span><br><span class="line"><span class="string">'&gt; !COM.EF to Welcome &lt;'</span></span><br></pre></td></tr></table></figure><p>Bingo, so easy!</p>]]></content>
      
      
      <categories>
          
          <category> Quiz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的反转字符串问题</title>
      <link href="posts/2016-10-18/reverse-by-word-in-python/"/>
      <url>posts/2016-10-18/reverse-by-word-in-python/</url>
      
        <content type="html"><![CDATA[<p><strong>按单词反转字符串</strong>是一道很常见的面试题。在Python中实现起来非常简单。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_string_by_word</span><span class="params">(s)</span>:</span></span><br><span class="line">    lst = s.split()  <span class="comment"># split by blank space by default</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(lst[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">s = <span class="string">'Power of Love'</span></span><br><span class="line"><span class="keyword">print</span> reverse_string_by_word(s)</span><br><span class="line"><span class="comment"># Love of Power</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Hello    World!'</span></span><br><span class="line"><span class="keyword">print</span> reverse_string_by_word(s)</span><br><span class="line"><span class="comment"># World! Hello</span></span><br></pre></td></tr></table></figure><p>上面的实现其实已经能满足大多数情况，但是并不完美。比如第二个字符串中的感叹号并没有被翻转，而且原字符串中的空格数量也没有保留。（在上面的例子里其实Hello和World之间不止一个空格）</p><p>我们期望的结果应该是这样子的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> reverse_string_by_word(s)</span><br><span class="line"><span class="comment"># Expected: !World  Hello</span></span><br></pre></td></tr></table></figure><p>要改进上面的方案还不把问题复杂化，推荐使用<code>re</code>模块。你可以查阅<a href="https://docs.python.org/2/library/re.html#re.split" target="_blank" rel="noopener"><code>re.split()</code></a> 的官方文档。我们看一下具体例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Hello  World!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, s)    <span class="comment"># will discard blank spaces</span></span><br><span class="line">[<span class="string">'Hello'</span>, <span class="string">'World!'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\s+)'</span>, s)  <span class="comment"># will keep spaces as a group</span></span><br><span class="line">[<span class="string">'Hello'</span>, <span class="string">'  '</span>, <span class="string">'World!'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'&lt; Welcome to EF.COM! &gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, s)  <span class="comment"># split by spaces</span></span><br><span class="line">[<span class="string">'&lt;'</span>, <span class="string">'Welcome'</span>, <span class="string">'to'</span>, <span class="string">'EF.COM!'</span>, <span class="string">'&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\w+)'</span>, s)  <span class="comment"># exactly split by word</span></span><br><span class="line">[<span class="string">'&lt; '</span>, <span class="string">'Welcome'</span>, <span class="string">' '</span>, <span class="string">'to'</span>, <span class="string">' '</span>, <span class="string">'EF'</span>, <span class="string">'.'</span>, <span class="string">'COM'</span>, <span class="string">'! &gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\s+|\w+)'</span>, s)  <span class="comment"># split by space and word</span></span><br><span class="line">[<span class="string">'&lt;'</span>, <span class="string">' '</span>, <span class="string">''</span>, <span class="string">'Welcome'</span>, <span class="string">''</span>, <span class="string">' '</span>, <span class="string">''</span>, <span class="string">'to'</span>, <span class="string">''</span>, <span class="string">' '</span>, <span class="string">''</span>, <span class="string">'EF'</span>, <span class="string">'.'</span>, <span class="string">'COM'</span>, <span class="string">'!'</span>, <span class="string">' '</span>, <span class="string">'&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(re.split(<span class="string">r'(\s+|\w+)'</span>, s)[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">'&gt; !COM.EF to Welcome &lt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(re.split(<span class="string">r'(\s+)'</span>, s)[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">'&gt; EF.COM! to Welcome &lt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(re.split(<span class="string">r'(\w+)'</span>, s)[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">'! &gt;COM.EF to Welcome&lt; '</span></span><br></pre></td></tr></table></figure><p>如果你觉得用切片将序列倒序可读性不高，那么其实也可以这样写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(reversed(re.split(<span class="string">r'(\s+|\w+)'</span>, s)))</span><br><span class="line"><span class="string">'&gt; !COM.EF to Welcome &lt;'</span></span><br></pre></td></tr></table></figure><p>一句话搞定，so easy!</p>]]></content>
      
      
      <categories>
          
          <category> Quiz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的下划线和双下划线</title>
      <link href="posts/2016-10-11/underscore-in-python/"/>
      <url>posts/2016-10-11/underscore-in-python/</url>
      
        <content type="html"><![CDATA[<p>下划线在Python中有很特别的意义。</p><a id="more"></a><h3 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a>开门见山</h3><p>下划线在Python中有特殊的意义，简单来说，可以总结成两点。</p><ol><li>单下划线在前一般用于声明私有成员，比如 <code>_private_var</code></li><li>单下划线在后一般用于命名已经被保留关键字占用的变量，比如 <code>class_</code>,<code>type_</code></li><li>双下划线一般被用于Python内置的特殊方法或者属性，比如 <code>__name__</code>,<code>__file__</code></li></ol><p>更多细节的讨论，可以看StackOverflow上的这个主题 <a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python。" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python。</a></p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p>下面是思维导图的总结</p><p><img src="https://tobyqin.github.io/images/underscore-in-Python.png" alt=""></p><h3 id="附录：-如何调用魔法方法"><a href="#附录：-如何调用魔法方法" class="headerlink" title="附录： 如何调用魔法方法"></a>附录： 如何调用魔法方法</h3><p>一些魔法方法直接和内建函数对应，这种情况下，如何调用它们是显而易见的。然而，另外的情况下，调用魔法方法的途径并不是那么明显。这个附录旨在展示那些不那么明显的调用魔法方法的语法。</p><table><thead><tr><th>魔法方法</th><th>什么时候被调用</th><th>解释</th></tr></thead><tbody><tr><td><code>__new__(cls [,...])</code></td><td><code>instance = MyClass(arg1, arg2)</code></td><td><code>__new__</code>在实例创建时调用</td></tr><tr><td><code>__init__(self [,...])</code></td><td><code>instance = MyClass(arg1,arg2)</code></td><td><code>__init__</code>在实例创建时调用</td></tr><tr><td><code>__cmp__(self)</code></td><td><code>self == other</code>, <code>self &gt; other</code> 等</td><td>进行比较时调用</td></tr><tr><td><code>__pos__(self)</code></td><td><code>self</code></td><td>一元加法符号</td></tr><tr><td><code>__neg__(self)</code></td><td><code>-self</code></td><td>一元减法符号</td></tr><tr><td><code>__invert__(self)</code></td><td><code>~self</code></td><td>按位取反</td></tr><tr><td><code>__index__(self)</code></td><td><code>x[self]</code></td><td>当对象用于索引时</td></tr><tr><td><code>__nonzero__(self)</code></td><td><code>bool(self)</code></td><td>对象的布尔值</td></tr><tr><td><code>__getattr__(self, name)</code></td><td><code>self.name</code> #name不存在</td><td>访问不存在的属性</td></tr><tr><td><code>__setattr__(self, name)</code></td><td><code>self.name = val</code></td><td>给属性赋值</td></tr><tr><td><code>__delattr__(self, name)</code></td><td><code>del self.name</code></td><td>删除属性</td></tr><tr><td><code>__getattribute__(self,name)</code></td><td><code>self.name</code></td><td>访问任意属性</td></tr><tr><td><code>__getitem__(self, key)</code></td><td><code>self[key]</code></td><td>使用索引访问某个元素</td></tr><tr><td><code>__setitem__(self, key)</code></td><td><code>self[key] = val</code></td><td>使用索引给某个元素赋值</td></tr><tr><td><code>__delitem__(self, key)</code></td><td><code>del self[key]</code></td><td>使用索引删除某个对象</td></tr><tr><td><code>__iter__(self)</code></td><td><code>for x in self</code></td><td>迭代</td></tr><tr><td><code>__contains__(self, value)</code></td><td><code>value in self, value not in self</code></td><td>使用in进行成员测试</td></tr><tr><td><code>__call__(self [,...])</code></td><td><code>self(args)</code></td><td>“调用”一个实例</td></tr><tr><td><code>__enter__(self)</code></td><td><code>with self as x:</code></td><td>with声明的上下文管理器</td></tr><tr><td><code>__exit__(self, exc, val, trace)</code></td><td><code>with self as x:</code></td><td>with声明的上下文管理器</td></tr><tr><td><code>__getstate__(self)</code></td><td><code>pickle.dump(pkl_file, self)</code></td><td>Pickling</td></tr><tr><td><code>__setstate__(self)</code></td><td><code>data = pickle.load(pkl_file)</code></td><td>Pickling</td></tr></tbody></table><p>如果你还想了解关于魔方方法的更多细节，那么你一定不能错过：</p><ul><li>魔法方法指南 <a href="http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html" target="_blank" rel="noopener">http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html</a></li><li>Magic method guide: <a href="http://www.rafekettler.com/magicmethods.html" target="_blank" rel="noopener">http://www.rafekettler.com/magicmethods.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tips </tag>
            
            <tag> python underscore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find and replace text with Python</title>
      <link href="posts/2016-10-10/python-text-replacement-en/"/>
      <url>posts/2016-10-10/python-text-replacement-en/</url>
      
        <content type="html"><![CDATA[<p>Tips of Python programming.</p><a id="more"></a><h3 id="Basic-find-and-replace"><a href="#Basic-find-and-replace" class="headerlink" title="Basic find and replace"></a>Basic find and replace</h3><p>Search and replace text in Python is simple, you can find a specific string with <code>find()</code> or <code>index()</code> method, it will return the index of first match occasion.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Cat and Dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">'Dog'</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.index(<span class="string">'Dog'</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">'Duck'</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><p>To replace <code>Cat</code> to <code>Dog</code>, you can simply call <code>replace()</code> method.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Cat and Dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">'Cat'</span>, <span class="string">'Dog'</span>)</span><br><span class="line"><span class="string">'Dog and Dog'</span></span><br></pre></td></tr></table></figure><h3 id="Wildcards-matching"><a href="#Wildcards-matching" class="headerlink" title="Wildcards matching"></a>Wildcards matching</h3><p>So how about searching string with wildcards pattern? You should try <a href="https://docs.python.org/2/library/fnmatch.html" target="_blank" rel="noopener">fnmatch</a> library, it is built-in python.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Cat and Dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.fnmatch(s,<span class="string">'Cat*'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.fnmatch(s,<span class="string">'C*and*D?'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.fnmatch(s,<span class="string">'C*and*D*'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="Regex-find-and-replace"><a href="#Regex-find-and-replace" class="headerlink" title="Regex find and replace"></a>Regex find and replace</h3><p>To use advanced text search and replacement, regular expression is your best friend. To find string with pattern, here is an example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'We will fly to Thailand on 2016/10/31'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = <span class="string">r'\d+'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(pattern, s)</span><br><span class="line">[<span class="string">'2016'</span>, <span class="string">'10'</span>, <span class="string">'31'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(pattern, s)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x03A8FD40</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(pattern, s).group()</span><br><span class="line"><span class="string">'2016'</span></span><br></pre></td></tr></table></figure><p>To replace string with pattern, hmm, it is an advanced feature, you might want to try <code>re.sub()</code> function(sub =&gt; substitution).</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"I like &#123;color&#125; car."</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'\&#123;color\&#125;'</span>,<span class="string">'blue'</span>,s)</span><br><span class="line"><span class="string">'I like blue car.'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'We will fly to Thailand on 10/31/2016'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, s)</span><br><span class="line"><span class="string">'We will fly to Thailand on 2016-10-31'</span></span><br></pre></td></tr></table></figure><p>The <code>re.sub()</code> function is really powerful, in above example, <code>{color}</code> is a pattern that might be updated when string finally published. You can create pattern like this as a template. And <code>r&#39;\3-\1-\2&#39;</code> is the reference to regex matching groups.</p><p>Let’s see another example:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"Tom is talking to Jerry."</span></span><br><span class="line">name1 = <span class="string">"Tom"</span></span><br><span class="line">name2 = <span class="string">"Jerry"</span></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r'(.*)(&#123;0&#125;)(.*)(&#123;1&#125;)(.*)'</span>.format(name1, name2)</span><br><span class="line"><span class="keyword">print</span> re.sub(pattern, <span class="string">r'\1\4\3\2\5'</span>, s)</span><br><span class="line"><span class="comment"># Jerry is talking to Tom.</span></span><br></pre></td></tr></table></figure><p>Let’s see how to customize the replace function.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_date</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> calendar <span class="keyword">import</span> month_abbr</span><br><span class="line">    mon_name = month_abbr[int(m.group(<span class="number">1</span>))]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(m.group(<span class="number">2</span>), mon_name, m.group(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">s = <span class="string">'We will fly to Thailand on 10/31/2016'</span></span><br><span class="line">pattern = <span class="string">r'(\d+)/(\d+)/(\d+)'</span></span><br><span class="line"><span class="keyword">print</span> re.sub(pattern, change_date, s)</span><br><span class="line"><span class="comment"># We will fly to Thailand on 31 Oct 2016</span></span><br></pre></td></tr></table></figure><p>OK, the ultimate example goes here. Hope you enjoy :)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_case</span><span class="params">(word)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(m)</span>:</span></span><br><span class="line">        text = m.group()</span><br><span class="line">        <span class="keyword">if</span> text.isupper():</span><br><span class="line">            <span class="keyword">return</span> word.upper()</span><br><span class="line">        <span class="keyword">elif</span> text.islower():</span><br><span class="line">            <span class="keyword">return</span> word.lower()</span><br><span class="line">        <span class="keyword">elif</span> text[<span class="number">0</span>].isupper():</span><br><span class="line">            <span class="keyword">return</span> word.capitalize()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> word</span><br><span class="line">    <span class="keyword">return</span> replace</span><br><span class="line"></span><br><span class="line">s = <span class="string">"LOVE PYTHON, love python, Love Python"</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">'python'</span>, match_case(<span class="string">'money'</span>), s, flags=re.IGNORECASE)</span><br><span class="line"><span class="comment"># LOVE MONEY, love money, Love Money</span></span><br></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Oh, last but not least, do you want to do use <code>re.sub()</code> for wildcards, yes, you can do it! <code>fnmatch</code> provide a function to let you <strong>translate</strong> wildcards pattern into regular expression pattern.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.translate(<span class="string">'C*and*D*'</span>)</span><br><span class="line"><span class="string">'C.*and.*D.*'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Python中查找和替换文本</title>
      <link href="posts/2016-10-10/python-text-replacement/"/>
      <url>posts/2016-10-10/python-text-replacement/</url>
      
        <content type="html"><![CDATA[<p>Python编程中的小技巧。</p><a id="more"></a><h3 id="最简单的查找替换"><a href="#最简单的查找替换" class="headerlink" title="最简单的查找替换"></a>最简单的查找替换</h3><p>在Python中查找和替换非常简单，如果当前对象是一个字符串<code>str</code>时，你可以使用该类型提供的<code>find()</code>或者<code>index()</code>方法查找指定的字符，如果能找到则会返回字符第一次出现的索引，如果不存在则返回-1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Cat and Dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">'Dog'</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.index(<span class="string">'Dog'</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find(<span class="string">'Duck'</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如果要替换目标字符串，用<code>replace()</code>方法就好了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Cat and Dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.replace(<span class="string">'Cat'</span>, <span class="string">'Dog'</span>)</span><br><span class="line"><span class="string">'Dog and Dog'</span></span><br></pre></td></tr></table></figure><h3 id="通配符查找匹配"><a href="#通配符查找匹配" class="headerlink" title="通配符查找匹配"></a>通配符查找匹配</h3><p>当然，如果你觉得上面的功能还不能满足你，你想使用通配符来查找字符串？没问题！<a href="https://docs.python.org/2/library/fnmatch.html" target="_blank" rel="noopener">fnmatch</a>这个库就能满足你的要求，看例子！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'Cat and Dog'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.fnmatch(s,<span class="string">'Cat*'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.fnmatch(s,<span class="string">'C*and*D?'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.fnmatch(s,<span class="string">'C*and*D*'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式查找替换"><a href="#正则表达式查找替换" class="headerlink" title="正则表达式查找替换"></a>正则表达式查找替换</h3><p>如果你需要查找比较复杂的字符规则，正则表达式是你不二的选择。下面是正则查找的简单示例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'We will fly to Thailand on 2016/10/31'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = <span class="string">r'\d+'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(pattern, s)</span><br><span class="line">[<span class="string">'2016'</span>, <span class="string">'10'</span>, <span class="string">'31'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(pattern, s)</span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x03A8FD40</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(pattern, s).group()</span><br><span class="line"><span class="string">'2016'</span></span><br></pre></td></tr></table></figure><p>接下来你可能需要用正则表达式去替换某些字符，那么你需要了解<code>re.sub()</code>方法，看例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"I like &#123;color&#125; car."</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'\&#123;color\&#125;'</span>,<span class="string">'blue'</span>,s)</span><br><span class="line"><span class="string">'I like blue car.'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'We will fly to Thailand on 10/31/2016'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, s)</span><br><span class="line"><span class="string">'We will fly to Thailand on 2016-10-31'</span></span><br></pre></td></tr></table></figure><p>其实<code>re.sub()</code>远比你相像的强大的多。在上面的例子里你可以替换类似于<code>{color}</code>这样的模板字符，也可以把正则匹配到的所有分组调换顺序，例如第二个例子一共匹配了3个分组，然后把第3个分组放到最前面 <code>r&#39;\3-\1-\2&#39;</code>，看明白了吗？</p><p>接下来看另外一个例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"Tom is talking to Jerry."</span></span><br><span class="line">name1 = <span class="string">"Tom"</span></span><br><span class="line">name2 = <span class="string">"Jerry"</span></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r'(.*)(&#123;0&#125;)(.*)(&#123;1&#125;)(.*)'</span>.format(name1, name2)</span><br><span class="line"><span class="keyword">print</span> re.sub(pattern, <span class="string">r'\1\4\3\2\5'</span>, s)</span><br><span class="line"><span class="comment"># Jerry is talking to Tom.</span></span><br></pre></td></tr></table></figure><p>其实你还可以自定义替换函数，也就是<code>re.sub()</code>的第二个参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_date</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> calendar <span class="keyword">import</span> month_abbr</span><br><span class="line">    mon_name = month_abbr[int(m.group(<span class="number">1</span>))]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(m.group(<span class="number">2</span>), mon_name, m.group(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">s = <span class="string">'We will fly to Thailand on 10/31/2016'</span></span><br><span class="line">pattern = <span class="string">r'(\d+)/(\d+)/(\d+)'</span></span><br><span class="line"><span class="keyword">print</span> re.sub(pattern, change_date, s)</span><br><span class="line"><span class="comment"># We will fly to Thailand on 31 Oct 2016</span></span><br></pre></td></tr></table></figure><p>最后给大家一个终极版的例子，里面用到了函数的闭包，着酸爽，你懂的！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_case</span><span class="params">(word)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(m)</span>:</span></span><br><span class="line">        text = m.group()</span><br><span class="line">        <span class="keyword">if</span> text.isupper():</span><br><span class="line">            <span class="keyword">return</span> word.upper()</span><br><span class="line">        <span class="keyword">elif</span> text.islower():</span><br><span class="line">            <span class="keyword">return</span> word.lower()</span><br><span class="line">        <span class="keyword">elif</span> text[<span class="number">0</span>].isupper():</span><br><span class="line">            <span class="keyword">return</span> word.capitalize()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> word</span><br><span class="line">    <span class="keyword">return</span> replace</span><br><span class="line"></span><br><span class="line">s = <span class="string">"LOVE PYTHON, love python, Love Python"</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">'python'</span>, match_case(<span class="string">'money'</span>), s, flags=re.IGNORECASE)</span><br><span class="line"><span class="comment"># LOVE MONEY, love money, Love Money</span></span><br></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>其实正则表达式还有很多玩法，如果你想让正则和通配符混合着用，一点问题都没有，因为<code>fnmatch</code>还有一个<code>translate()</code>的方法，可以让你把通配符无痛转换成正则表达式，你爱怎么玩就怎么玩。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch.translate(<span class="string">'C*and*D*'</span>)</span><br><span class="line"><span class="string">'C.*and.*D.*'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的logging模块</title>
      <link href="posts/2016-10-08/use-logging-in-python/"/>
      <url>posts/2016-10-08/use-logging-in-python/</url>
      
        <content type="html"><![CDATA[<p>最近修改了项目里的logging相关功能，用到了python标准库里的logging模块，在此做一些记录。</p><a id="more"></a><p>主要是从官方文档和stackoverflow上查询到的一些内容。</p><ul><li><a href="https://docs.python.org/2.7/library/logging.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="http://blog.csdn.net/balderfan/article/details/7644807" target="_blank" rel="noopener">技术博客</a></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>下面的代码展示了logging最基本的用法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取logger实例，如果参数为空则返回root logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">"AppName"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定logger输出格式</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s %(levelname)-8s: %(message)s'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件日志</span></span><br><span class="line">file_handler = logging.FileHandler(<span class="string">"test.log"</span>)</span><br><span class="line">file_handler.setFormatter(formatter)  <span class="comment"># 可以通过setFormatter指定输出格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台日志</span></span><br><span class="line">console_handler = logging.StreamHandler(sys.stdout)</span><br><span class="line">console_handler.formatter = formatter  <span class="comment"># 也可以直接给formatter赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为logger添加的日志处理器</span></span><br><span class="line">logger.addHandler(file_handler)</span><br><span class="line">logger.addHandler(console_handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志的最低输出级别，默认为WARN级别</span></span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出不同级别的log</span></span><br><span class="line">logger.debug(<span class="string">'this is debug info'</span>)</span><br><span class="line">logger.info(<span class="string">'this is information'</span>)</span><br><span class="line">logger.warn(<span class="string">'this is warning message'</span>)</span><br><span class="line">logger.error(<span class="string">'this is error message'</span>)</span><br><span class="line">logger.fatal(<span class="string">'this is fatal message, it is same as logger.critical'</span>)</span><br><span class="line">logger.critical(<span class="string">'this is critical message'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2016-10-08 21:59:19,493 INFO    : this is information</span></span><br><span class="line"><span class="comment"># 2016-10-08 21:59:19,493 WARNING : this is warning message</span></span><br><span class="line"><span class="comment"># 2016-10-08 21:59:19,493 ERROR   : this is error message</span></span><br><span class="line"><span class="comment"># 2016-10-08 21:59:19,493 CRITICAL: this is fatal message, it is same as logger.critical</span></span><br><span class="line"><span class="comment"># 2016-10-08 21:59:19,493 CRITICAL: this is critical message</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除一些日志处理器</span></span><br><span class="line">logger.removeHandler(file_handler)</span><br></pre></td></tr></table></figure><p>除了这些基本用法，还有一些常见的小技巧可以分享一下。</p><h3 id="格式化输出日志"><a href="#格式化输出日志" class="headerlink" title="格式化输出日志"></a>格式化输出日志</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line">service_name = <span class="string">"Booking"</span></span><br><span class="line">logger.error(<span class="string">'%s service is down!'</span> % service_name)  <span class="comment"># 使用python自带的字符串格式化，不推荐</span></span><br><span class="line">logger.error(<span class="string">'%s service is down!'</span>, service_name)  <span class="comment"># 使用logger的格式化，推荐</span></span><br><span class="line">logger.error(<span class="string">'%s service is %s!'</span>, service_name, <span class="string">'down'</span>)  <span class="comment"># 多参数格式化</span></span><br><span class="line">logger.error(<span class="string">'&#123;&#125; service is &#123;&#125;'</span>.format(service_name, <span class="string">'down'</span>)) <span class="comment"># 使用format函数，推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2016-10-08 21:59:19,493 ERROR   : Booking service is down!</span></span><br></pre></td></tr></table></figure><h3 id="记录异常信息"><a href="#记录异常信息" class="headerlink" title="记录异常信息"></a>记录异常信息</h3><p>当你使用logging模块记录异常信息时，不需要传入该异常对象，只要你直接调用<code>logger.error()</code> 或者 <code>logger.exception()</code>就可以将当前异常记录下来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录异常信息</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 等同于error级别，但是会额外记录当前抛出的异常堆栈信息</span></span><br><span class="line">    logger.exception(<span class="string">'this is an exception message'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2016-10-08 21:59:19,493 ERROR   : this is an exception message</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "D:/Git/py_labs/demo/use_logging.py", line 45, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     1 / 0</span></span><br><span class="line"><span class="comment"># ZeroDivisionError: integer division or modulo by zero</span></span><br></pre></td></tr></table></figure><h3 id="logging配置要点"><a href="#logging配置要点" class="headerlink" title="logging配置要点"></a>logging配置要点</h3><h4 id="GetLogger"><a href="#GetLogger" class="headerlink" title="GetLogger()"></a>GetLogger()</h4><p>这是最基本的入口，该方法参数可以为空，默认的logger名称是root，如果在同一个程序中一直都使用同名的logger，其实会拿到同一个实例，使用这个技巧就可以跨模块调用同样的logger来记录日志。</p><p>另外你也可以通过日志名称来区分同一程序的不同模块，比如这个例子。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logger = logging.getLogger(<span class="string">"App.UI"</span>)</span><br><span class="line">logger = logging.getLogger(<span class="string">"App.Service"</span>)</span><br></pre></td></tr></table></figure><h4 id="Formatter"><a href="#Formatter" class="headerlink" title="Formatter"></a>Formatter</h4><p>Formatter对象定义了log信息的结构和内容，构造时需要带两个参数：</p><ul><li>一个是格式化的模板<code>fmt</code>，默认会包含最基本的<code>level</code>和 <code>message</code>信息</li><li>一个是格式化的时间样式<code>datefmt</code>，默认为 <code>2003-07-08 16:49:45,896 (%Y-%m-%d %H:%M:%S)</code></li></ul><p><code>fmt</code>中允许使用的变量可以参考下表。</p><ul><li><strong>%(name)s</strong>       Logger的名字</li><li><strong>%(levelno)s</strong>    数字形式的日志级别</li><li><strong>%(levelname)s</strong>  文本形式的日志级别</li><li><strong>%(pathname)s</strong>    调用日志输出函数的模块的完整路径名，可能没有</li><li><strong>%(filename)s</strong>       调用日志输出函数的模块的文件名</li><li><strong>%(module)s</strong>      调用日志输出函数的模块名|</li><li><strong>%(funcName)s</strong>   调用日志输出函数的函数名|</li><li><strong>%(lineno)d</strong>           调用日志输出函数的语句所在的代码行</li><li><strong>%(created)f</strong>         当前时间，用UNIX标准的表示时间的浮点数表示|</li><li><strong>%(relativeCreated)d</strong>  输出日志信息时的，自Logger创建以来的毫秒数|</li><li><strong>%(asctime)s</strong>     字符串形式的当前时间。默认格式是“2003-07-08 16:49:45,896”。逗号后面的是毫秒</li><li><strong>%(thread)d</strong>         线程ID。可能没有</li><li><strong>%(threadName)s</strong>     线程名。可能没有</li><li><strong>%(process)d</strong>        进程ID。可能没有</li><li><strong>%(message)s</strong>        用户输出的消息</li></ul><h4 id="SetLevel"><a href="#SetLevel" class="headerlink" title="SetLevel"></a>SetLevel</h4><p>Logging有如下级别: DEBUG，INFO，WARNING，ERROR，CRITICAL<br>默认级别是WARNING，logging模块只会输出指定level以上的log。这样的好处, 就是在项目开发时debug用的log，在产品release阶段不用一一注释，只需要调整logger的级别就可以了，很方便。</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>最常用的是StreamHandler和FileHandler, Handler用于向不同的输出端打log。<br>Logging包含很多handler, 可能用到的有下面几种</p><ul><li><strong>StreamHandler</strong> instances send error messages to streams (file-like objects).</li><li><strong>FileHandler</strong> instances send error messages to disk files.</li><li><strong>RotatingFileHandler</strong> instances send error messages to disk files, with support for maximum log file sizes and log file rotation.</li><li><strong>TimedRotatingFileHandler</strong> instances send error messages to disk files, rotating the log file at certain timed intervals.</li><li><strong>SocketHandler</strong> instances send error messages to TCP/IP sockets.</li><li><strong>DatagramHandler</strong> instances send error messages to UDP sockets.</li><li><strong>SMTPHandler</strong> instances send error messages to a designated email address.</li></ul><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>logging的配置大致有下面几种方式。</p><ol><li>通过代码进行完整配置，参考开头的例子，主要是通过getLogger方法实现。</li><li>通过代码进行简单配置，下面有例子，主要是通过basicConfig方法实现。</li><li>通过配置文件，下面有例子，主要是通过 <code>logging.config.fileConfig(filepath)</code></li></ol><h5 id="logging-basicConfig"><a href="#logging-basicConfig" class="headerlink" title="logging.basicConfig"></a>logging.basicConfig</h5><p>basicConfig提供了非常便捷的方式让你配置logging模块并马上开始使用，可以参考下面的例子。具体可以配置的项目请查阅<a href="https://docs.python.org/2/library/logging.html#logging.basicConfig" target="_blank" rel="noopener">官方文档</a>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">'example.log'</span>,level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">'This message should go to the log file'</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(levelname)s:%(message)s'</span>, level=logging.DEBUG)</span><br><span class="line">logging.debug(<span class="string">'This message should appear on the console'</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s %(message)s'</span>, datefmt=<span class="string">'%m/%d/%Y %I:%M:%S %p'</span>)</span><br><span class="line">logging.warning(<span class="string">'is when this event was logged.'</span>)</span><br></pre></td></tr></table></figure><p>备注： 其实你甚至可以什么都不配置直接使用默认值在控制台中打log，用这样的方式替换print方法对日后项目维护会有很大帮助。</p><h5 id="通过文件配置logging"><a href="#通过文件配置logging" class="headerlink" title="通过文件配置logging"></a>通过文件配置logging</h5><p>如果你希望通过配置文件来管理logging，可以参考这个<a href="https://docs.python.org/2/library/logging.config.html" target="_blank" rel="noopener">官方文档</a>。在log4net或者log4j中这是很常见的方式。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># logging.conf</span></span><br><span class="line"><span class="section">[loggers]</span></span><br><span class="line"><span class="attr">keys</span>=root</span><br><span class="line"></span><br><span class="line"><span class="section">[logger_root]</span></span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">handlers</span>=consoleHandler</span><br><span class="line"><span class="comment">#,timedRotateFileHandler,errorTimedRotateFileHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="section">[handlers]</span></span><br><span class="line"><span class="attr">keys</span>=consoleHandler,timedRotateFileHandler,errorTimedRotateFileHandler</span><br><span class="line"></span><br><span class="line"><span class="section">[handler_consoleHandler]</span></span><br><span class="line"><span class="attr">class</span>=StreamHandler</span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">formatter</span>=simpleFormatter</span><br><span class="line"><span class="attr">args</span>=(sys.stdout,)</span><br><span class="line"></span><br><span class="line"><span class="section">[handler_timedRotateFileHandler]</span></span><br><span class="line"><span class="attr">class</span>=handlers.TimedRotatingFileHandler</span><br><span class="line"><span class="attr">level</span>=DEBUG</span><br><span class="line"><span class="attr">formatter</span>=simpleFormatter</span><br><span class="line"><span class="attr">args</span>=(<span class="string">'debug.log'</span>, <span class="string">'H'</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">[handler_errorTimedRotateFileHandler]</span></span><br><span class="line"><span class="attr">class</span>=handlers.TimedRotatingFileHandler</span><br><span class="line"><span class="attr">level</span>=WARN</span><br><span class="line"><span class="attr">formatter</span>=simpleFormatter</span><br><span class="line"><span class="attr">args</span>=(<span class="string">'error.log'</span>, <span class="string">'H'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="section">[formatters]</span></span><br><span class="line"><span class="attr">keys</span>=simpleFormatter, multiLineFormatter</span><br><span class="line"></span><br><span class="line"><span class="section">[formatter_simpleFormatter]</span></span><br><span class="line"><span class="attr">format</span>= %(levelname)s %(threadName)s %(asctime)s:   %(message)s</span><br><span class="line"><span class="attr">datefmt</span>=%H:%M:%S</span><br><span class="line"></span><br><span class="line"><span class="section">[formatter_multiLineFormatter]</span></span><br><span class="line"><span class="attr">format</span>= ------------------------- %(levelname)s -------------------------</span><br><span class="line"> Time:      %(asctime)s</span><br><span class="line"> Thread:    %(threadName)s</span><br><span class="line"> File:      %(filename)s(line %(lineno)d)</span><br><span class="line"> Message:</span><br><span class="line"> %(message)s</span><br><span class="line"></span><br><span class="line"><span class="attr">datefmt</span>=%Y-%m-%d %H:%M:%S</span><br></pre></td></tr></table></figure><p>假设以上的配置文件放在和模块相同的目录，代码中的调用如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">filepath = os.path.join(os.path.dirname(__file__), <span class="string">'logging.conf'</span>)</span><br><span class="line">logging.config.fileConfig(filepath)</span><br><span class="line"><span class="keyword">return</span> logging.getLogger()</span><br></pre></td></tr></table></figure><h3 id="日志重复输出的坑"><a href="#日志重复输出的坑" class="headerlink" title="日志重复输出的坑"></a>日志重复输出的坑</h3><p>你有可能会看到你打的日志会重复显示多次，可能的原因有很多，但总结下来无非就一个，日志中多个重复的handler。</p><h4 id="第一坑"><a href="#第一坑" class="headerlink" title="第一坑"></a>第一坑</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">fmt = <span class="string">'%(levelname)s:%(message)s'</span></span><br><span class="line">console_handler = logging.StreamHandler()</span><br><span class="line">console_handler.setFormatter(logging.Formatter(fmt))</span><br><span class="line">logging.getLogger().addHandler(console_handler)</span><br><span class="line"></span><br><span class="line">logging.info(<span class="string">'hello!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO:root:hello!</span></span><br><span class="line"><span class="comment"># INFO:hello!</span></span><br></pre></td></tr></table></figure><p>上面这个例子出现了重复日志，因为在第3行调用<code>basicConfig()</code>方法时系统会默认创建一个handler，如果你再添加一个控制台handler时就会出现重复日志。</p><h4 id="第二坑"><a href="#第二坑" class="headerlink" title="第二坑"></a>第二坑</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_logger</span><span class="params">()</span>:</span></span><br><span class="line">    fmt = <span class="string">'%(levelname)s:%(message)s'</span></span><br><span class="line">    console_handler = logging.StreamHandler()</span><br><span class="line">    console_handler.setFormatter(logging.Formatter(fmt))</span><br><span class="line">    logger = logging.getLogger(<span class="string">'App'</span>)</span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line">    logger.addHandler(console_handler)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_me</span><span class="params">()</span>:</span></span><br><span class="line">    logger = get_logger()</span><br><span class="line">    logger.info(<span class="string">'hi'</span>)</span><br><span class="line"></span><br><span class="line">call_me()</span><br><span class="line">call_me()</span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO:hi</span></span><br><span class="line"><span class="comment"># INFO:hi</span></span><br><span class="line"><span class="comment"># INFO:hi</span></span><br></pre></td></tr></table></figure><p>在这个例子里<code>hi</code>居然打印了三次，如果再调用一次<code>call_me()</code>呢？我告诉你会打印6次。why? 因为你每次调用<code>get_logger()</code>方法时都会给它加一个新的handler，你是自作自受。正常的做法应该是全局只配置logger一次。</p><h4 id="第三坑"><a href="#第三坑" class="headerlink" title="第三坑"></a>第三坑</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_logger</span><span class="params">()</span>:</span></span><br><span class="line">    fmt = <span class="string">'%(levelname)s: %(message)s'</span></span><br><span class="line">    console_handler = logging.StreamHandler()</span><br><span class="line">    console_handler.setFormatter(logging.Formatter(fmt))</span><br><span class="line">    logger = logging.getLogger(<span class="string">'App'</span>)</span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line">    logger.addHandler(console_handler)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    logging.basicConfig(format=<span class="string">'[%(name)s]: %(message)s'</span>)</span><br><span class="line">    logging.warn(<span class="string">'some module use root logger'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    logger = get_logger()</span><br><span class="line">    logger.info(<span class="string">'App start.'</span>)</span><br><span class="line">    foo()</span><br><span class="line">    logger.info(<span class="string">'App shutdown.'</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO: App start.</span></span><br><span class="line"><span class="comment"># [root]: some module use root logger</span></span><br><span class="line"><span class="comment"># INFO: App shutdown.</span></span><br><span class="line"><span class="comment"># [App]: App shutdown.</span></span><br></pre></td></tr></table></figure><p>为嘛最后的<code>App shutdown</code>打印了两次？所以在Stackoverflow上很多人都问，我应该怎么样把root logger关掉，root logger太坑爹坑妈了。只要你在程序中使用过root logger，那么默认你打印的所有日志都算它一份。上面的例子没有什么很好的办法，我建议你招到那个没有经过大脑就使用root logger的人，乱棍打死他或者开除他。</p><p>如果你真的想禁用root logger，有两个不是办法的办法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging.getLogger().handlers = []  <span class="comment"># 删除所有的handler</span></span><br><span class="line">logging.getLogger().setLevel(logging.CRITICAL)  <span class="comment"># 将它的级别设置到最高</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python中的日志模块作为标准库的一部分，功能还是比较完善的。个人觉得上手简单，另外也支持比如过滤，文件锁等高级功能，能满足大多数项目需求。</p><p>不过切记，小心坑。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> logging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《霍乱时期的爱情》</title>
      <link href="posts/2016-10-04/book-love-in-the-time-of-cholera/"/>
      <url>posts/2016-10-04/book-love-in-the-time-of-cholera/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/love-in-cholera.jpg" alt=""></p></center><p>作者歌颂的应该不是爱情，至于男女主最后终在一起，我也不认为那是爱情。</p><a id="more"></a><p>文章开篇写了医生一个老朋友的自杀，有意的自杀，无非想表达，衰老，有些人不愿意面对，而像医生、女主、男主，都最终到了衰老的年纪，衰老会面临很多问题，最大的问题应该是孤独。老人需要陪伴，费尔明娜最后和男主在一起，是因为她需要最后的陪伴而已，不是爱情。</p><p>纵观男主弗洛伦蒂诺一生，那扭曲的爱情观所，他对费尔明娜的爱情，他认为的永恒的忠诚和不渝的爱情，真让人唏嘘。弗洛伦蒂诺和费尔明娜只不过青春期有过信件往来嘛，没有任何现实基础啊，话也没正儿八经说过几句啊，都是幻想啊幻想啊，有木有！以至于最后费尔明娜在街头看见弗洛伦蒂诺的时候，不禁讶异：我怎么会喜欢这个人！才有了后来的索还信件，断绝往来之事。这哪里是真爱？</p><p>弗洛伦蒂诺让我觉得恶心，他的一生都在意淫。不仅如此，他的桃色笔记，51年里的25个笔记本622个与他有较长情史的角色，大部分的寡妇，难道都是表达对费尔明娜的思念吗？对，寡妇，他看到过那些寡妇的饥渴，所以一直期望费尔明娜成为寡妇的那天，幻想着费尔明娜也会饥渴的扑向他的怀抱扑向他的床，Sick。还有他糟蹋的那个14岁的小萝莉，人家父母把孩子交给你，让你做监护人，你却把小朋友睡了，这搁现代，这就是嫖宿幼女啊，70多岁的老头和14岁的少女，最后还让人自杀的，良知何在？而当他们最终睡在一起时，不要脸的弗洛伦蒂诺还说我为你保留了童真，我呸，Sick。世人没能揭穿你这虚伪的面纱而已，在门后偷袭了女佣后，害怕被揭穿，还找了个替死鬼。</p><p>相比较来说，费尔明娜同医生的感情到是让我觉得正常的多。虽然他们结婚时并没有感情基础，却有长达50多年的陪伴，人不是说嘛，陪伴是最长情的告白。两人后经历了热恋、生子、家庭矛盾、出轨，那难道不是人世间大多数夫妻所经历的嘛。看看人家医生，生活规律，专业上有建树，还不忘教书育人，参与公益，参与社会建设，虽也有短暂的出轨，但不会影响社会对他的评价。再看看弗洛伦蒂洛的一生，除了25本桃色日记，还留下了什么。</p><p>最后72岁和费尔明娜和76的弗洛伦蒂洛终于睡在一起了，就像是现代社会的屌丝男终于泡上白富美，在白富美老公死后，在50多年后。有人这么说道：“被许多人津津乐道的半个多世纪的爱情等待，怎么看都像是一场’吃着碗里看着锅里的‘阴险猎捕计划’。踩过622朵浮云，弗洛伦蒂诺终于吃到了梦寐以求的终极猎物”。</p><p>这个故事告诉我们，好好活着，别纱布垃圾就知道挣钱，你要是死的早，你的枕边人被别人睡了多可惜！还好故事里的医生活了80多岁，这让男主在垂暮之前，基本丧失生理能力的时候，才得以如愿以偿。再次证明，作者根本没有歌颂他的爱情的意思。</p><p>马尔克斯的文章还是很精彩的，看过《百年孤独》，惊叹不已。有机会你自己也应该好好去看一遍吧。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《月亮与六便士》</title>
      <link href="posts/2016-10-03/book-moon-and-peny/"/>
      <url>posts/2016-10-03/book-moon-and-peny/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/moon-and-peny.jpg" alt=""></p></center><p>一个伟大的艺术家，40岁时，有稳定的家庭及职业，却突然放弃了一切，只为追求自己心中所深信的真理：“我必须画画！”</p><a id="more"></a><p>我必须得说，我等普通老板姓是无法理解伟大艺术家自私、奔放、狂野、无道德约束的灵魂的，更别说那些食不果腹的日子。</p><p>有人说，这时高更人物传记。我也不了解。抛却不能理解的部分，故事本事还是很精彩的。</p><p>不剧透，有兴趣自己了解。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《活着》</title>
      <link href="posts/2016-10-03/book-huo-zhe/"/>
      <url>posts/2016-10-03/book-huo-zhe/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/huo-zhe.jpg" alt=""></p></center><p>没什么好说的，白花花的语言，依托中国抗日战后至今的时代背景，以富贵的经历叙述了很多中国式悲哀。</p><a id="more"></a><p>富二代的富贵，吃喝嫖赌，散尽家财，老爹气死。</p><p>搬出豪宅，交出家财，开始辛勤劳作，不料老丈人八抬大轿把嫁出去的女儿接了回去。</p><p>媳妇终究还是回来了，这时的母亲却生病了。</p><p>去城里请医生，却被国民党抓了去做炮兵。</p><p>仗也没怎么打。日本鬼子撤出中国，继而开始了国共内战。</p><p>战场上的每个人都想活着，都想活着回家去。</p><p>后国军被围，被俘虏。共军优待俘虏，给了路费，富贵回家了。</p><p>回家后发现老母已不再，女儿凤霞不会说话了。</p><p>想带着老婆儿女好好过日子，发现挣得太少，没法让儿子上学。</p><p>心生一妙计，把女儿送给大户人家，就供得起儿子上学了。</p><p>好不容易送走的女儿，最后还是偷偷跑回来了，心一横，还是自己养着吧。</p><p>这时候，村里搞炼钢铁，收了每户人家的锅。还收了儿子的羊，说是从此以后吃食堂了，再也不用自己家做饭了，方便啊。</p><p>儿子在学校跑步跑的好，体育老师说可以训练，日后出国比赛，为国争光。富贵不懂，硬是阻止了。</p><p>富贵带着老婆、女儿，一家三个轻壮年劳动，日子倒也可以。</p><p>不料老婆却病了，身体一天比一天差。</p><p>国庆节来的时候，富贵一家守着锅炉，终于把铁给融化了。</p><p>村长高高兴兴带着一帮人去县里汇报。富贵背着老婆去城里看病。</p><p>天有不测风云，儿子学校的校长，县长的老婆，生孩子大出血。</p><p>学校把他们年级的孩子都拉到医院，不料只有富贵儿子的血型匹配，医生心一横，抽血往死里抽，最后出了人命。</p><p>儿子死了，老婆的病更加重了，眼看一天天不行了，却撑住了。</p><p>村里人娶媳妇嫁女儿，看得凤霞眼红，虽然她不会说话，也是羡慕别人家的。</p><p>富贵托村长给凤霞介绍婚事，村长还真找来了，就是头有点偏，人在城里还有正经工作。</p><p>好在偏头对凤霞挺好，不久还怀上了。</p><p>不料凤霞生孩子时难产，又挂了。</p><p>到这时，富贵老婆终于顶不住，也归西了。</p><p>富贵就经常去看偏头和外孙，没想一天偏头干活时被砸死，留下外孙一人。</p><p>富贵把外孙接回家一同过。</p><p>一天，收棉花时，外孙不舒服，富贵就把他送回家，还给他煮了好多豆子。</p><p>真是，屋漏偏逢连夜雨，富贵回家发现外孙吃豆子噎死了，嘴里塞着豆子。</p><p>最后，富贵买了头牛，相依相伴。</p><p>不太愿意相信，富贵是集所有悲剧于一身的人。</p><p>故事太刻意了些，不推荐。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《无声告白》</title>
      <link href="posts/2016-10-02/book-everthing-i-told-you/"/>
      <url>posts/2016-10-02/book-everthing-i-told-you/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/never-told-you.jpg" alt=""></p></center><p>故事以莉迪亚之死为主线，讲述了Lee一家的故事，父母对子女教育的失败，父母婚姻的失败。</p><a id="more"></a><p>故事中的母亲玛莉琳，从小就是个特别的孩子，虽是个女孩，却异于其他女孩，立志长大做一名医生。这与她的母亲期望一直相悖，母亲一直希望她成为一个家庭主妇，有房子、老公、孩子。当玛莉琳接到哈佛的录用通知书时，母亲也是那样告诉她的：你在那里会遇见你未来老公的。</p><p>故事中的父亲Lee先生是为亚裔，从小与周围环境格格不入。同时由于父亲是学校里扫地的，母亲是学校厨房里的帮工，是他常年累月的压抑着自卑的情绪，没有朋友，没有社交。</p><p>Lee虽没有俊朗的外表，却深深吸引了玛莉琳。那时Lee在哈佛做助教，玛莉琳来听他的课。黑头发、黑眼睛的Lee在极短的时间里吸引了玛莉琳的注意，俩人迅速确定了恋爱关系。</p><p>由于玛莉琳怀孕了，她不得不放弃未完成的大四学业。Lee在哈佛攻读博士，毕业后却未能如期取得哈佛教授的工作。</p><p>那时候他们的婚姻是不合法的，不被祝福的。当玛莉琳的母亲得知她要结婚时非常高兴，却因Lee的种族问题，对他们的婚姻表示反对。导致母女二人后来的8年联系中断。</p><p>玛莉琳再次回到母亲家时，是在母亲去世后。她想起母亲对她的期待，想想自己现在的生活，不就是母亲所期待的吗？不，这是不对的，玛莉琳想，我的理想是做一名医生。想到隔壁那位单亲妈妈，听说她是一位医生，玛莉琳不由得羡慕。当她回家以后，玛莉琳去了医院拜访了隔壁那位医生。对职业医生的向往，让她酝酿了一次离家出走。她买了书，用母亲留给她的积蓄，租了一间公寓，她要在那里为自己未完成的学业努力。</p><p>可是她却没有把事情告诉Lee，以及两个孩子：内斯和莉迪亚。玛莉琳是自私的，她忘却了老公和孩子，她从没有想过她莫名的失踪会给家人带来什么样的影响，尽管她坚持自己理想的心也无可厚非。Lee和孩子们的失落是她无法想象的。直至她再次因怀孕放弃她的计划。</p><p>当她回到家时，她发现莉迪亚是个很聪明，有天赋的孩子，于是她把自己的全部心思压在了莉迪亚身上，她认为莉迪亚会成为一个出色的医生，没错，她那么优秀呢。</p><p>此时的莉迪亚再也不想失去母亲，于是只要母亲想让她做的，她都会迎合母亲，都会去做。而她的这种迎合，玛莉琳却没有察觉。</p><p>母亲给她买各种各样的自然科学的书，带她去看自然展览，只要玛莉琳觉得对莉迪亚有帮助，她都会不惜一切代价去做。</p><p>莉迪亚不想做医生，她也不爱自然科学。</p><p>于此同时，Lee也把重心放在莉迪亚的身上，她觉得莉迪亚那么优秀，有那么多朋友，真是很不错呢。他不爱他的儿子内斯，因为他觉得内斯不管做什么事情，都是自己小时候的缩影，看到内斯，他有种厌恶感。</p><p>其实莉迪亚也不爱交朋友，她的同学都觉得她是个性格孤僻的孩子。</p><p>她只是为了迎合父亲的期望，假装自己有很多朋友，假装自己很开心。</p><p>这样的生活过了好久，直至莉迪亚发现哥哥内斯的哈佛录用通知书。在这个家里，内斯是缺乏父母关心的，内斯也是见证莉迪亚在父母的压力下成长的人。内斯羡慕莉迪亚在这个家里的地位，却也深知，父母的过多的期望成了莉迪亚不能承受之重。内斯和莉迪亚相互了解，相互安慰。她不愿意面对哥哥即将离家的现实。</p><p>于是她把哈佛寄过来的一封封录用通知书藏起来，她以为这样内斯就不会离开家。直至隔壁的邻居把又一封通知书送到他们家里。内斯难以抑制的激动，这次他终于可以离开这个家了，他一分钟都不想再呆了。</p><p>莉迪亚很失落，她的成绩也出现了问题，可是没人帮她。她知道自己没那种天赋，物理的不及格不是偶然。可是母亲却不愿意面对。母亲相信这是个偶然。</p><p>莉迪亚和隔壁的坏孩子杰克做了朋友，当她发现杰克喜欢哥哥内斯说，俩人发生了争执。</p><p>在莉迪亚生日那天，在发现父亲的婚外情后，终于发现再也无力承担这一切：父母的期望、哥哥的离去、家庭的压抑。</p><p>那天晚上，她独自坐在湖岸边，想明白了一切。她想对父母坦白，说她不想做医生，不想社交。想对哥哥坦白，说她愿意哥哥离去。没关系，莉迪亚想，我可以独自生活。她想做个告别，于是她爬上了小船，划到湖心，莉迪亚是不会游泳的。</p><p>她举起双手，她想跳入湖中，想象自己只要努力踢这双腿，就可以游到岸边，像内斯教她那样，努力踢着双腿。她告诉自己，可以的，自己能做到。</p><p>莉迪亚死了，玛莉琳和Lee，花了好长时间，才明白，自己才是害了莉迪亚的凶手。过多的期待，让莉迪亚绝望，也让另外两个孩子内斯和汉娜长久的被冷落。汉娜还那么小，她总是像个可怜的小狗一样，躲在拐角里期望父母能注意到她，能给予她多一点点的爱。</p><p>现在，他们终于注意到她了，汉娜原来是那么可爱，如同她姐姐莉迪亚小时那样。</p><p>此故事是父母坑害孩子的经典著作，建议父母们都可以看看。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个鸡蛋的问题</title>
      <link href="posts/2016-10-01/egg-test/"/>
      <url>posts/2016-10-01/egg-test/</url>
      
        <content type="html"><![CDATA[<p>前段时间有个朋友在问了这个关于鸡蛋和楼层的问题。一开始我也是懵逼的，没弄明白说的是什么意思，且让我从头细细道来。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假如给你<strong>两个</strong>完全一样的鸡蛋，现在有<code>n</code>层楼高的房子，鸡蛋最高可以从<code>t</code>层掉下来不会碎，再往上加一层就碎了。请问，最少需要尝试多少次可以得知<code>t</code>是多少层？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果我没在题目中着重说明是两个鸡蛋，很多人看到题目是都是茫然的。假设你忽略了鸡蛋个数的约束，得到的方案有可能是千变万化的。因为只有两个鸡蛋，所以大家且用且珍惜，一旦碎了，尝试的机会就会大大减少。另外，只要蛋还没碎，是可以重复利用的。</p><h3 id="最直观的办法-二分法"><a href="#最直观的办法-二分法" class="headerlink" title="最直观的办法 - 二分法"></a>最直观的办法 - 二分法</h3><p>相信大部分人看到这个问题想到的第一个方法应该是二分法。我们把问题具体化，假如<code>n=100</code>，那么我们要找的答案就是二分法最坏的情况需要扔多少次。</p><p>举例说明，第一次就从50层开始扔第一个鸡蛋。</p><ul><li>假如没碎，我们再从75层扔第二次。以此类推</li><li>假如碎了，那么我们只剩一个鸡蛋了，那么我们只能从第1层开始尝试扔第二个鸡蛋，一直扔到到它碎为止。我们把第二次扔碎蛋的楼层指定为<code>x</code>，那么<code>t=x-1</code>。</li></ul><p>二分法最坏的情况应该在分支2出现，当<code>x=50</code>时情况最坏。也就说，第一个蛋在50层碎了，然后我们很苦逼地从第1层开始往上扔，第二个蛋扔到49层还没碎。那么说明<code>t</code>就是坑爹的49，这时候我们可以得出二分法最坏的结果是<code>n/2</code>。</p><h3 id="进阶的办法-等分法"><a href="#进阶的办法-等分法" class="headerlink" title="进阶的办法 - 等分法"></a>进阶的办法 - 等分法</h3><p>从二分法我们可以看出，其实那并不是一个很好的方案。我们可以在此基础上使用等分的方法来改进。具体的例子如下。</p><ul><li>将<code>n</code>等分为<code>x</code>等分，使<code>x</code>的平方大于或等于<code>n</code></li><li>在<code>n=100</code>的例子里，我们使<code>x=10</code></li><li>第一个鸡蛋从第1个等分开始扔<ul><li>如果碎了，那么我们从第1层开始尝试，最多还需要尝试<code>x-1</code>次。</li><li>如果没碎，我们从第二个等分再扔一次。<ul><li>不管碎了还是没碎，跟外面一层的思路一样。</li></ul></li></ul></li></ul><p>等分法最坏的情况应该是在最后一个等分出现，比如100层楼，当扔到最后一个等分时，也就是100层时鸡蛋碎了，那么我们只能从第91层开始扔第二个鸡蛋，一直扔到99层，蛋没碎，那么最多尝试了<code>2x</code>次，也就是20次。</p><p>所以等分法最坏的情况是<code>2x</code>，并且<code>x**2&gt;=n</code></p><h3 id="最优的解法-动态规划"><a href="#最优的解法-动态规划" class="headerlink" title="最优的解法 - 动态规划"></a>最优的解法 - 动态规划</h3><p>说了这么多，应该到揭示BOSS解法的时候了。最优的解法需要动态规划楼层。</p><p>我们回到实际的问题中，假如从<code>x</code>层开始扔第一次，如果碎了就需要再从下往上试<code>x-1</code>次。这是无论如何也不能避免的事实。</p><p>那如果没碎呢，我们可以考虑就往上加<code>x-1</code>层，如果碎了就从<code>x</code>层一直尝试到<code>x+(x-1)</code>层，最多还是<code>x</code>次。</p><p>现在的问题就可以转化为<code>x+(x-1)+(x-2)+...+1</code>大于或者等于最高楼层。这个加法是不是有一点眼熟，你没看错，其实这就是从1一直加到<code>x</code>，我们可以用初中时学习过的高斯公式表示为<code>x(x+1)/2 ≥ n</code>。</p><p>如果<code>n</code>是100层的话，<code>x</code>的最小值就是14，我们开始扔鸡蛋。</p><ul><li>从<code>14</code>楼扔第一次，如果碎了你懂的，从第1层开始。</li><li>如果没碎就往<code>14+13</code>层扔，如果碎了你懂的，从第15层开始。</li><li>如果没碎就往<code>14+13+12</code>层扔，以此类推。</li><li>最多尝试次数会小于等于<code>x</code>。</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实这道题目是一道挺出名的面试题，据说是Google家的。如你没能想出完美的办法也是正常的。祝大家国庆玩的开心。</p>]]></content>
      
      
      <categories>
          
          <category> Quiz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quiz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《挪威的森林》</title>
      <link href="posts/2016-10-01/book-nuo-wei-de-sen-lin/"/>
      <url>posts/2016-10-01/book-nuo-wei-de-sen-lin/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/nwdsl.jpg" alt=""></p></center><p>不清楚村上在表达什么，故事里的木月、直子、直子的姐姐、永泽的女朋友初美，以及哪所疗养院里的许许多多的人，忧郁、自杀。那么多人死了，也没有交代原因，我想这应该是那个年代日本社会经常发生的事情。</p><a id="more"></a><p>故事里也又例外，像永泽这样的不缺钱的富二代，头脑清楚，目标明确，即使在考取公务员后，回到宿舍还自学班牙语，即使他已经自学掌握了好几门外语了。永泽的私生活，涉及到另外一个话题，性。整个故事里，对性的开放程度也是令人惊讶。不过在青少年成长时期，这也是没法回避的一个话题。</p><p>还有一个人，就是绿子，虽然经历种种挫折，也始终没有放弃对爱情的追求，这个姑娘还是蛮讨人喜爱的，她也是为数不多的精神正常的人。</p><p>村上的文字真是令人受不了，虽有幽默，却低沉的让人受不了。如果说那是一座森林，有人在森林里迷失了，有些人再也没有出来过，如木月等人；有些人在迷失中走出来了，如疗养院里走出的玲子；也有些人，生活好也罢、坏也罢，始终向前行走，如绿子、渡边。</p><p>青春，就是这样。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《西厢记》</title>
      <link href="posts/2016-09-30/book-xi-xiang-ji/"/>
      <url>posts/2016-09-30/book-xi-xiang-ji/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/xxj.jpg" alt=""></p></center><blockquote><p>这本书是某人要求我读的，啊。</p></blockquote><p>故事以崔莺莺和张生的爱情展开，毫无疑问，故事的主题就是歌颂爱情。整个故事中，给人印象最深，让人最喜欢的要数红娘，这也是故事得以发展的最重要的线索。没有红娘的机智与聪慧，任凭张生才高有八斗十斗，任凭小姐有多聪慧有多貌美，最终都不可能得到圆满的结局。</p><a id="more"></a><p>另有一个巴掌拍不响，若不是初次见面崔莺莺眉目传情，张生也不会痴心妄想，以至于相思病病入膏肓。故事告诉大家，在爱情面前，畏首畏尾，是修不成正果的。纵使张生一无所有，他勇敢追求爱情的心，是他成功的另一种要点。艺高人胆大，哈哈。白富美就在那里，看你有没有胆去追求了。</p><p>张生虽有潘安之貌，状元之才，却由于门第原因，不被相爷夫人看中。像张生那样的穷酸，要出人头地，也是万分艰难，后崔老夫人打发张生进京赶考，也交代过，考取功名之事，也是要看时运的。其实这同当代的公务员考试是同理的，时运不济，考个十年八年也未必能成，哈哈，历史总是惊人的相似。</p><p>故事的转机是孙飞虎围攻普救寺，相爷夫人当众承诺许婚。此时张生想起自己还有一位挚友白马将军杜确，没有此人相助，活捉孙飞虎是不敢想的。后崔老夫人在强行将莺莺许配与自己侄儿之时，若非白马将军及时现身，张生能不能同莺莺在一起，还未可知。由此可见，朋友，关键时刻可以帮忙，这也是非常重要的。</p><p>当然，最后张生考中状元之后，京城岁美女如云，达官贵人遍地开花，却一心要回家娶莺莺。作者在此此告诫世人，功名利禄虽可诱惑人心，仍须警醒，不忘初心，不忘糟糠之妻，才是最重要的。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《解忧杂货店》</title>
      <link href="posts/2016-09-30/book-jie-you-za-huo-dian/"/>
      <url>posts/2016-09-30/book-jie-you-za-huo-dian/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/jyzhd.jpg" alt=""></p></center><blockquote><p><strong>五星好评，强烈推荐！</strong></p></blockquote><p>这本书让人最惊叹的地方，在于作者的逻辑安排，整本书以几个独立的故事铺展开来，各个故事之间却紧密相连，环环相扣。同时，作者想要表达的人生感悟，在故事中缓缓道来。</p><a id="more"></a><p>第一个是关于击剑女运动员静子的故事，也是关于爱情与理想的故事。男朋友重病，却在男友与奥运梦之间是无从选择。虽然杂货店里人，从后人角度看到，那届奥运会在后来由于日本对俄罗斯入侵阿富汗的不满而遭到日本政府的抵制，坚持奥运梦，最后肯定是徒劳。虽然回信建议她放弃奥运梦，可她并没有放弃，回过头看，她也并没有为当日的选择后悔。爱情同理想，对人们都是那么重要，那么不管在什么时候，坚持对理解的追求，不放弃，日后才不会后悔。纵使知道结局的人告诉你，这条路会很艰辛，没有结果，但自己没有走过，又怎能知道其中滋味呢？生活是需要亲身体会的。</p><p>静子斜对面的小妹妹，武藤晴美，从小父母双亡，被奶奶的姐姐田村秀代收养。后由于田村秀代女婿破产，全家搬到田村家同住，晴美不得已在丸光园呆了几年。后再次回到田村秀代家时，境况不如从前，秀代的劳动患病，晴美想报答收养之恩，企图放弃学业做陪酒女郎。后杂货店回信，告诉她不要放弃学业，陪酒可以作为一段时间的谋生手段，但绝不是长远之计。后晴美听从建议，投资房产，在顺应时代的前提下，走向成功。这个故事告诉我们，不断的学习是非常重要的事情，在时代的发展中谋求个人发展才是正确的选择，不要逆风向行驶，所谓站在风口的猪也能飞起来，哈哈。</p><p>后丸光园着火，晴子前去看望，遇见儿时伙伴藤川博，其真名为和久浩介。由于表哥去世，浩介要回了表哥的披头士唱片，从此开始对披头士的喜爱。后浩介的父亲生意失败，全家计划逃走。心智尚不成熟的浩介，选择离开父母。父母为了保护浩介自杀，让人以为浩介也一同自杀。真可谓父母之爱子女，则为之计深远。可是年轻的浩介并没有选择同父母在一起渡过艰难的阶段。如一家人在一起，浩介的父母无论如何也不会选择自杀的。亲情，长大成人的浩介想必也会为此后悔一生。</p><p>由于晴美和浩介是丸光园里的伙伴，在丸光园失火后，两人同来看望。后忆起前任院长皆月晓子，杂货店主人浪矢雄治年轻时追求的人。那时候的雄治是个穷小子，被皆月家父母所反对，后两人私奔未果。后雄治遇到丸光园现任院长皆月晓子弟弟，为当年的鲁莽像皆月家里道歉。</p><p>在丸光园的火灾中，松岗克朗救人牺牲。此人同静子和晴美住在同一个地方，年轻时为追求音乐梦想，与父母意见不合，放弃大学。但在奶奶过世时回家悼念时，父亲却鼓励他坚持下去。就算父亲身体不好，就算克朗在音乐上并没有什么天赋，父母还是鼓励他继续为他的理想努力。父母之爱子女，则为之计深远。</p><p>克朗后并未成名，却在每年圣诞节时坚持去丸光园义演。其中有个孩子水芹原，由于火灾时克朗救了她的弟弟。日后的水芹原成为著名歌手，为了感怀克朗，将克朗的歌发扬并传承。而杂货店的三人组，由于了解水芹原的故事，了解了克朗对水芹原的影响，知道了他的努力并不会白白付出，所以鼓励克朗坚持：你对音乐的追求，并不会白白付出，将会有人因为你的歌而得到救赎，你创作的音乐也必将流传下去。虽然克朗最后的结局让人唏嘘不已，但朝圣的路上，注定要有人牺牲，注定要有人成为殉道者。</p><p>水芹原的经纪人，川边绿的孩子，也同样在丸光园长大。川边绿由于与有妇之夫有染，怀孕，犹豫要不要生下孩子，并前来咨询杂货店。后川边绿意外坠海，孩子长大后一直以为当年母亲不想要他。多年以后孩子看到当年杂货店的信件，知道当年杂货店鼓励其母亲勇敢活下去，知道母亲并不是想放弃自己，特写信感恩杂货店。这一点应该是呼应了浪矢爷爷的初衷。浪矢交代，33年时空再开启，其实就是想知道，当年他所做的努力，有没有真正帮助别人。而川边绿孩子的回答，无疑是肯定的。</p><p>最后，丸光园失火，富有的晴美来看望，让在丸光园长大的杂货店三人组误以为晴美要买了丸光园另作它用，一气之下闯入晴美的家，抢劫。而此时的晴美在回家取东西之时，想赶在时光之门关闭之前，投递她的感谢信。不料车里的感谢信被劫走。而杂货店三人组看了后，才明白，他们抢的人，原来就是33年前来信咨询的迷途的小狗，三人不禁唏嘘。并决定将物归原主，从此以后再也不做小偷了。</p><p>纵观全书，所有人都向杂货店咨询烦恼，而所有人（除静子外）均与丸光园有着不解的渊源。杂货店的主人浪矢雄治，丸光园的创始人皆月晓子，俩人的爱情在当年并未开花结果，但杂货店同丸光园却始终缠绕在一起。实在有趣。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码让浏览器变成记事本</title>
      <link href="posts/2016-09-28/one-line-browser-as-notepad/"/>
      <url>posts/2016-09-28/one-line-browser-as-notepad/</url>
      
        <content type="html"><![CDATA[<p>有时候你为了测试富文本的显示效果，需要新建一个html或者word？</p><a id="more"></a><p>太麻烦了。把下面这行代码贴到Chrome浏览器地址栏，按下回车，一切都搞定了，so easy！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:text&#x2F;html,&lt;html contenteditable&gt;</span><br></pre></td></tr></table></figure><p>现在你可以往浏览器里输入任何内容，爽不？</p><p>其实这也不是什么核武器，只是让浏览器直接执行一下它本身就支持的东西。这这个例子我们用的是<code>Data:</code>这个URI格式，当然你还可以用<code>javascript:</code>这个URI格式让浏览器立马执行一段js脚本，比如这样。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">javascript:alert(<span class="string">'牛逼大了！'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《傲慢与偏见》</title>
      <link href="posts/2016-09-28/book-pride-and-prejudice/"/>
      <url>posts/2016-09-28/book-pride-and-prejudice/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/pride_prejudice.jpg" alt=""></p></center><p>很经典的爱情故事，情节比较简单，结合英国那个时代背景看会更好，如当时的社交文化，当时遗产继承制度（如无男嗣，则传给亲戚关系里最近的男嗣。由于班纳特夫妇无儿子，因此，班纳特老爷的侄子柯林斯，成为日后继承班纳特家庭财产的人选）。</p><a id="more"></a><p>作者比较擅长对人物性格的刻画。伊丽莎白聪慧、漂亮，却对威廉编织的谎言深信不疑，并以此对达西的人格妄下判断。达西英俊、富有，却无法摆脱心中对阶级的偏见。最终俩人摆脱心中的傲慢与偏见，结合在一起。</p><p>性格决定命运。纵观这样一个乡绅家庭，五个女儿，愣是一个都没嫁出去，愁死这个老母亲班纳特太太。她的恨嫁之心，毛不夸张的说，超出了她任何一个女儿。</p><p>大女儿吉英，年龄近30，待嫁。其美丽无可言喻，加上过分的善良，在爱情里总是容易轻信别人。在其老爹看来，她就是缺脑子。而彬格莱的出现刚好拯救了她，两人为对方的容貌、对方的善良相互吸引。</p><p>二女儿伊丽莎白，年龄稍小一点，待嫁。相貌平常，聪慧，见识、胆量均是这五姐妹中最出色的一个，也是姐妹在中唯一一个让班纳特老爷喜欢的。有着所有姑娘一样的小虚荣心，却也有着故事里所有姑娘都不具备的自尊自爱的心。当他的表格柯林斯怀着高高在上的心想她求婚时，她断然拒绝。柯林斯虽有舒适的生活，稳定的职业，她却不为所动，因为她看到了柯林斯有着贫穷的灵魂，丑陋的外表，却深不自知。而她的闺蜜夏绿蒂却甘心忍受这些，为后半生的衣食无忧，依然决定嫁给柯林斯。这让伊丽莎白在一段时间内无法接受。</p><p>自负的柯林斯说以后不可能再有人向她求婚了，她再也嫁不出去。这让人觉得真是生气，求婚不成，还诅咒人嫁不出去，足见有多么自私狭隘。而当班纳特太太也这么想时，她请求班纳特老爷同她一起给伊丽莎白施压，让她答应求婚。出人意料，班纳特老爷却这么回答：</p><blockquote><p>丽萃，你可怎么办是好呢，你现在面临一个很艰难的选择。你要是不嫁给柯林斯，你妈妈就再也不见你了。而如果你嫁给柯林斯，我就再也不见你了。</p></blockquote><p>听到父亲这话的回答，伊丽莎白兴奋无比。班纳特老爷再次让夫人衰弱的神经崩溃，尽管他说班纳特太太的脆弱神经是他20年的老朋友。</p><p>当伊丽莎白面对彬格莱家姐妹的高高在上，从容淡定。当她面对达西姨妈包尔夫人的颐指气使，不卑不亢。当达西第一次向她求婚时，达西表达了自己克服心中的偏见、家族的期望，期望能与她在一起时，却让伊丽莎白愤怒。在她看来，如果爱情需要有这么多的附加条件，爱一个人不是出于本能，这又能算是什么爱情呢。</p><p>无疑，这次的拒绝，让达西痛定思痛，同时让他对伊丽莎白有了更深刻的认识：她不是普通的姑娘，不是那种为了财富、地位会随便屈从的姑娘。她有着自己的爱情观，独立、自爱。虽然她的家庭，她的母亲、妹妹，无处不表现出不得体，让她自己也颇感尴尬，但她却是那样的与众不同。</p><p>而后达西意识到，自己也有不得体的亲戚，比如包尔姨妈，他有什么理由对她的家庭表现出那样的傲慢呢。伊丽莎白最终明白自己有多么愚蠢，轻信了威廉编织的谎言，一直对达西心存偏见，多么不应该啊。</p><p>达西的感情变化是比较有意思的。从开始默默暗恋女主，到表白被拒，再到默默为女主付出，最后当有一线生机时，毫不犹豫再次跟女主表白。个人觉得作者的女性视角比较突出。所谓每个女人心中都住着个高富帅，达西就是作者心中的白马王子，哈哈。</p><p>除了不自爱的夏绿蒂，还有女主的妹妹丽迪亚，不顾礼义廉耻，和兵官们成天混在一起，最后还私奔了。害的全家人替她担忧、擦屁股。</p><p>这是一本值得女性拜读的故事。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用教育邮箱激活JetBrains全家桶</title>
      <link href="posts/2016-09-27/get-jetbrains-student-licence/"/>
      <url>posts/2016-09-27/get-jetbrains-student-licence/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/tobyqin/img/master/20190208185616.png" alt=""></p><p>如果你还有在校时的邮箱，比如<code>your_name@xxx.edu</code>或者<code>your_name@xxx.edu.cn</code>的邮箱，那么你可以免费激活JetBrains全家桶。</p><a id="more"></a><h3 id="JetBrains-Toolbox-专业开发工具-学生免费授权计划"><a href="#JetBrains-Toolbox-专业开发工具-学生免费授权计划" class="headerlink" title="JetBrains Toolbox 专业开发工具 学生免费授权计划"></a>JetBrains Toolbox 专业开发工具 学生免费授权计划</h3><blockquote><p>工欲善其事，必先利其器。无论是学习 Java，PHP，Ruby，Python，JavaScript，Objective-C，.NET 任何一种开发技术，国际知名且年年获奖的 JetBrains 专业开发工具都能有效帮助您。更棒的是：您可以完全免费使用！</p></blockquote><p>地址：<a href="https://www.jetbrains.com/student/" target="_blank" rel="noopener">https://www.jetbrains.com/student/</a></p><p>免费学生计划里保护JetBrains所有专业版开发工具： IntelliJ IDEA Ultimate，ReSharper Ultimate 和所有集成开发工具。取得方式很简单，学生只要提供校园邮箱。</p><p>更多的申请说明请参考：<a href="https://www.jetbrains.com/student/#faq" target="_blank" rel="noopener">常见问题</a>。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol><li><p>学生授权是一种免费的永久授权吗？</p><p> 不是的。学生授权每次是一年的效期，可以申请延长但不提供永久授权。在学生授权过期后只要还具有学生身份就可以再申请延长，毕业生可以选择购买授权。</p></li><li><p>如何申请延长学生授权？</p><p> 只要还具有学生身份，欢迎您利用 JetBrains account 内的链接申请延长。在学生授权即将到期的前一周我们会寄出提醒邮件，在该邮件中也带有申请延长用的链接。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《一个人的朝圣》</title>
      <link href="posts/2016-09-27/book-unlikely-pilgrimage-of-harold-fry/"/>
      <url>posts/2016-09-27/book-unlikely-pilgrimage-of-harold-fry/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/haroldfry.jpg" alt=""></p></center><blockquote><p><strong>四星好评，不错哦！</strong></p></blockquote><p>哎哟喂，写作手法很有意思，故事从头到尾都很平淡。</p><a id="more"></a><p>本是带着疑惑上路的，一个退休的65岁的老头，莫名其妙的想靠走路的精神力量去拯救生命垂危的故人奎妮。想知道哈罗德跟奎妮之间到底是什么样的关系，是情人吗？他老婆莫林跟邻居都深以为然，哈罗德为了旧情人将老婆一个人抛弃在家！</p><p>更别提后文，当媒体大肆的报道哈罗德这位朝圣者时，哈罗德同奎妮之间的关系，在吃瓜观众面前越来越微妙！不过当我们细细梳理时，又发现不是那么回事。从哈罗德徒步的第一天开始，他每天都会给老婆莫林打电话，每次购买纪念品时，除了给奎妮带去的，一定还会有莫林的那一份。哈罗德心理深深的爱着他的妻子莫林。</p><p>哈罗德的妻子莫林，一直在同他们的儿子戴维对话。她告诉儿子哈罗德做了疯狂的决定，要徒步去看奎妮，儿子说他知道奎妮。她告诉儿子，今天她一个人去医院看病了，儿子说可以陪她去的。而在哈罗德的回忆中，好似他同儿子之间有不可逾越的鸿沟；好似因为这道鸿沟，导致他同妻子的关系也出现了问题，最终导致了哈罗德的离家出走。</p><p>不过你真要这么以为，就错啦。最后你会明白，他们儿子戴维，很多年前因为抑郁症自杀。什么，惊天霹雳！原来莫林是有精神病哟，一直在跟死人对话！NO，作者给你的回答要委婉一点，人家只不过思念儿子，多年了养成了这个习惯而已。那么奎妮又是为什么呢？原来是当初丧子的哈罗德在悲愤之中所犯下的过错，奎妮默默的替他承担了后果，而哈罗德却连声谢谢都没来得及对她说过。这才是他不顾一切踏上这道路的原因，不是爱情！</p><p>哈罗德在将近3个月的时间里，600度英里的路上，回顾了他的一生，他的父母，他的妻子莫林，他的儿子戴维。他们匆忙的一生，他们来不及做的事情，他们所亏欠的事情，他们所怨恨的事情。最终莫林明白，这么多年，她盲目的将儿子的问题归咎于哈罗德，是不对的。</p><p>当她仔细去回忆，去查看，戴维的成长过程是有哈罗德的陪伴的！奎妮的死是无法避免的结局，哈罗德同莫林，在经历这么多年的相互埋怨之后，终于相互原谅了对方。</p><p>人生路上，我们会遇到很多形形色色的人，他们来了，又走了。但终会有人陪伴你走完全程。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书 - 《追风筝的人》</title>
      <link href="posts/2016-09-27/book-kite-runner/"/>
      <url>posts/2016-09-27/book-kite-runner/</url>
      
        <content type="html"><![CDATA[<center>文/大橙子<p><img src="https://tobyqin.github.io/images/kiterunner.png" alt="Kite Runner"></p></center><blockquote><p><strong>五星好评，强烈推荐！</strong></p></blockquote><p>贯穿整本书的是作者（阿米尔）的懦弱与自私，整个故事，直至最后，当阿米尔决定去挽救哈桑的儿子叫索拉博时，才是救赎的开始。</p><a id="more"></a><p>整个故事的背景是俄罗斯入侵阿富汗，以及后来的阿富汗内战，以及种族问题。善良的哈桑被人始终被对立种族看不起，内战也是因为种族对立的问题。战争带来的是可怕的毁灭，尤其对儿童的造成的毁灭性影响，世人值得惊醒。善良的人，应该被世界善待。</p><p>拉辛汗是位智者：当阿米尔还是个孩子的时候，在屡屡被父亲忽视的时候，拉辛汗鼓励他读书、写作，这也会日后阿米尔的写作奠定了基础；当阿米尔的父子逃难离开美国后，拉辛汗找到了哈桑，并接回一同住；最后也是拉辛汗，将远隔千山万水，大洋彼岸的阿米尔拉回阿富汗，开始救赎的路。</p><p>哈桑写给阿米尔的信真让人心碎。</p><p>信里有他们的童年，童年时的阿富汗，阿富汗天空下那一群群追着风筝跑的孩子。信里有现在的阿富汗，满目疮痍。信里有哈桑的儿子索拉博，聪明的索拉博、会识字的索拉博、开心的索拉博。信里有病重的拉辛汗，一个令人敬爱的男人。信里有哈桑的梦，鲜花盛开的喀布尔街头、风筝再次在天空飞翔，而他的朋友阿米尔再次回到他们儿时的土地。读完哈桑的信，有种特别想哭的冲动。</p><blockquote><p>“如果你回来，你会发现有个忠诚的老朋友在等着你。愿安拉永远与你用在”。</p></blockquote><p>故事的最后，哈桑原谅了从出生那天起就抛弃了自己的母亲，并陪伴她终老。拉辛汗说主会原谅你的父亲，而最终阿米尔承认了那些年自己和父亲所犯下的错，而当他决心为他们曾经的过错做出弥补的时候，他便原谅了父亲，开始了救赎的道路。</p><blockquote><p><strong>为你，千千万万遍。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从C#到Python - 语言特性和概览</title>
      <link href="posts/2016-09-27/from-csharp-to-python-overview/"/>
      <url>posts/2016-09-27/from-csharp-to-python-overview/</url>
      
        <content type="html"><![CDATA[<p>因为工作的原因，目前主力编程语言从C#转移到Python，所以在此记录这两种语言的一些异同点和自己的感悟收获。本系列文章数量不限，随想随写。</p><a id="more"></a><h2 id="语言特性和特点"><a href="#语言特性和特点" class="headerlink" title="语言特性和特点"></a>语言特性和特点</h2><h3 id="C"><a href="#C" class="headerlink" title="C#"></a><code>C#</code></h3><p>C#是微软公司主推的编程语言，在Windows平台的首选开发语言，需要.net framework的支持，非微软平台支持目前并不完善。主要特点是语法简单，IDE强悍(VS是我用过最强悍和人性化的IDE，没有之一)，C#是强类型高级编程语言。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><code>Python</code></h3><p>是开源的动态解释型语言，由Guido van Rossum于1989年发明。它天生具有跨平台的能力，默认集成在MacOS和Linux系统中。Windows平台需要单独安装。主要特点是语法简洁，第三方类库丰富强大，数据处理能力异常优秀。</p><h3 id="漫谈瞎扯"><a href="#漫谈瞎扯" class="headerlink" title="漫谈瞎扯"></a>漫谈瞎扯</h3><p>我使用C#编程的时间大概有5年左右，对于它的各种特性还算比较了解。接触Python大概只有三个多月，不过三观已经被刷新。限于我个人水平，本文对C#和Python特别深入的东西不会特别介绍，仅从我个人的角度来帮助C#的程序猿认识Python。</p><p>很明显我感觉C#是<strong>简单</strong>，但Python是<strong>简洁</strong>。两个不完全一样的概念，简洁之中蕴含了简单，但是简洁也意味着信息的省略和丢失。举一些具体的例子</p><h4 id="标识语句块"><a href="#标识语句块" class="headerlink" title="标识语句块"></a>标识语句块</h4><p>C#用花括号，和大多数编程语言一样。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">csharp_example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Hello C#!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Python用的是缩进。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        name = <span class="string">'python!'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"hello"</span>, name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say_hello()</span><br></pre></td></tr></table></figure><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>C#对文件系统的命名空间是System.IO。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br></pre></td></tr></table></figure><p>Python只有io，只有两个字母，还是小写的！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h4 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h4><p>C#中for迭代是这样的，已经很简洁了。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;() &#123; <span class="number">1</span>,, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python是这样的，真的不能再简洁了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>还有不少细节的地方在你接触Python之后也一定深有体会。</p><ul><li>比如为了不切换大小写，Python推荐使用全小写的命名规范（类命名除外）</li><li>Python要求省略句尾的分号</li><li>Python不推荐在逻辑判断后使用括号，比如 <code>if i &gt; 0:</code> 而不是 <code>if (i &gt; 0):</code></li></ul><p>这样的例子枚不胜举，如果语意可读性上来说，我比较喜欢C#的做法，因为使用驼峰命名规则，基本上一个语句就是一小段英文。而且从命名规范上来说，C#推荐使用完整的英文单词来命名变量和类名。</p><p>Python就不见得了，很多类库和命名都是极度简洁的，比如<code>pytz</code>, <code>wrapt</code>, <code>isalnum()</code>。最令人发指的是居然连中间的下划线也省了，比如<code>altsep</code>, <code>execl</code>, <code>getcwdu</code>, <code>spawnle</code>，尼玛，这些是什么鬼，这一点也不考虑其他人的感受，很多时候你只能yy或者查文档，这就是简洁的代价。</p><p>不过话说回来，正因为Python这也省布料，所以使用Python实现与C#，JAVA相同功能，至少可以少20%的代码量。夸张的说法甚至60%到80%，我保留意见，但不得不承认是极有可能的。</p><p>最后从动态语言和非动态语言的角度简单说一下，动态语言的特点就是程序在运行时才能确定类型和行为，动态语言也叫鸭子类型<code>ducking typing</code>，源自于来自James Whitcomb Riley这句有名的话。</p><blockquote><p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p><p>如果它看起来像一只鸭子，游起来也像鸭子，而且还会像鸭子一样叫，那么它极有可能就是一只鸭子。</p></blockquote><p>在动态语言里变量只是一个标记，具体的行为可以在程序运行时才确定，比如两个变量相加，Python可以这样写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>你不需要<strong>也不能</strong>指定这个a, b的类型，当程序在运行时，他们的相加行为会根据传入的具体类型确定。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="string">'hi '</span>, <span class="string">'toby'</span>)</span><br><span class="line"><span class="string">'hi toby'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="string">'hi'</span>, <span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#7&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    add(<span class="string">'hi'</span>, <span class="number">1</span>)</span><br><span class="line">  File <span class="string">"&lt;pyshell#2&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> add</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">TypeError: cannot concatenate <span class="string">'str'</span> <span class="keyword">and</span> <span class="string">'int'</span> objects</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>反观C#，Visual Studio会对你的语法进行检查，没有泛型之前，你只能这样写。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">AddInt</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">AddString</span>(<span class="params"><span class="keyword">string</span> a, <span class="keyword">string</span> b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有泛型和dynamic类型之后，情况好一些。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T Add&lt;T&gt;(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> x = a;</span><br><span class="line">    <span class="keyword">dynamic</span> y = b;            </span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这种和C#本身格格不入的编码方式并不流行，而且IDE支持也不好。或许你能从这个小例子明白动态语言的厉害之处。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>写了那么多，希望你对Python有一个比较直观的印象。</p><p>两种语言各有特点，不能说谁好谁坏。具体用哪个一般只有一个原因，工作环境和项目需求。但就学习而言，如果已经熟悉C#，转而学习Python还是比较简单和容易接受的，因为做的的减法。但是如果之前是Python而后转到C#，就不是那么好受了，因为做的是加法。</p><p>Python的作者有处女情节，所以处处都要追求优雅，简单，完美。想适应这种情节真的需要刷三观，费半条命。</p><p>而且写Python的人一般都短命，因为喜欢Python的人都喜欢这句话。</p><p><code>Life is short, I use Python. （人生苦短，我用Python）</code></p><blockquote><p>本文源码地址：<a href="https://github.com/tobyqin/csharp_vs_python" target="_blank" rel="noopener">https://github.com/tobyqin/csharp_vs_python</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python：将数组中的元素导出到变量中 (unpacking)</title>
      <link href="posts/2016-09-24/python-unpack-list-elements/"/>
      <url>posts/2016-09-24/python-unpack-list-elements/</url>
      
        <content type="html"><![CDATA[<p>Python 算法备忘。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>你需要将数组（list）或元组（tuple）中的一些元素导出到<code>N</code>个变量中。可能你并不希望通过遍历的方式。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>任何序列都可以通过简单的变量赋值方式将其元素分配到对应的变量中，唯一的要求就是变量的数量和结构需要和序列中的结构完全一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">x, y = p</span><br><span class="line"><span class="comment"># x = 1</span></span><br><span class="line"><span class="comment"># y = 2</span></span><br><span class="line"></span><br><span class="line">data = [<span class="string">'google'</span>, <span class="number">100.1</span>, (<span class="number">2016</span>, <span class="number">5</span>, <span class="number">31</span>)]</span><br><span class="line">name, price, date = data</span><br><span class="line"><span class="comment"># name = 'google'</span></span><br><span class="line"><span class="comment"># price = 100.1</span></span><br><span class="line"><span class="comment"># date = (2016, 5, 31)</span></span><br><span class="line"></span><br><span class="line">name, price, (year, month, day) = data</span><br><span class="line"><span class="comment"># name = 'google'</span></span><br><span class="line"><span class="comment"># price = 100.1</span></span><br><span class="line"><span class="comment"># year = 2016</span></span><br><span class="line"><span class="comment"># month = 5</span></span><br><span class="line"><span class="comment"># day = 31</span></span><br></pre></td></tr></table></figure><p>如果变量结构和元素结构不一致，你将会遇到以下错误：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">x, y, z = p</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#12&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    x, y, z = p</span><br><span class="line">ValueError: <span class="keyword">not</span> enough values to unpack (expected <span class="number">3</span>, got <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其实这样的操作不限于元组和数组，在字符串中也是可以用的。Unpacking支持大多数我们常见的序列，比如文件迭代，各种生成器等等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'Hello'</span></span><br><span class="line">a,b,c,d,e = s</span><br><span class="line"><span class="comment"># a = 'H'</span></span><br><span class="line"><span class="comment"># b = 'e'</span></span><br></pre></td></tr></table></figure><p>如果导出过程中你想丢掉一些元素，其实Python并不支持这样的语法，不过你可以指定一些不常用的变量来达到你的目的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="string">'google'</span>, <span class="number">100.1</span>, (<span class="number">2016</span>, <span class="number">5</span>, <span class="number">31</span>)]</span><br><span class="line">name, _, (_,month,_) = data</span><br><span class="line"><span class="comment"># name = 'google'</span></span><br><span class="line"><span class="comment"># month = '5'</span></span><br><span class="line"><span class="comment"># other fileds will be discarded</span></span><br></pre></td></tr></table></figure><p>本文主要是为了测试Markdown排版工具，微信公众号里的高亮代码一直是很麻烦的事情，让我头疼了很长一段时间。现在看起来不错哦。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tips </tag>
            
            <tag> python list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Turn off logging in python selenium</title>
      <link href="posts/2016-09-24/Turn-off-logging-in-python-selenium-en/"/>
      <url>posts/2016-09-24/Turn-off-logging-in-python-selenium-en/</url>
      
        <content type="html"><![CDATA[<p>Python selenium will print a lot of debug info for selenium driver, which will mess up important information for your testing.</p><a id="more"></a><p><img src="https://tobyqin.github.io/images/selenium-debug-logging.png" alt=""></p><p>To turn it off, please add bellow code before test case.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.remote.remote_connection <span class="keyword">import</span> LOGGER</span><br><span class="line">LOGGER.setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> above code should be put before webdriver initialization.</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> selenium </tag>
            
            <tag> logging </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置 Python Selenium 中的Log显示信息</title>
      <link href="posts/2016-09-24/Turn-off-logging-in-python-selenium/"/>
      <url>posts/2016-09-24/Turn-off-logging-in-python-selenium/</url>
      
        <content type="html"><![CDATA[<p>Python Selenium默认会往控制台和Log文件里写入大量的DEBUG信息，比如下面这张图。</p><a id="more"></a><p>这样的相信在测试过程中有一定帮助，但大部分情况下都是没有营养的，而且会把你自己打印的Log信息淹没在汪洋大海中。</p><p><img src="https://tobyqin.github.io/images/selenium-debug-logging.png" alt=""></p><p>如果想要停止显示或者关闭Selenium中的Log，你可以通过以下代码更改其默认LOGGER的级别。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.remote.remote_connection <span class="keyword">import</span> LOGGER</span><br><span class="line"></span><br><span class="line">LOGGER.setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以上代码一定要在初始化<code>WebDriver</code>前进行。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> selenium </tag>
            
            <tag> logging </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语录</title>
      <link href="posts/2016-09-24/programming-notes/"/>
      <url>posts/2016-09-24/programming-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>编程语言的最终目的是什么？是为了让编程更容易。</li><li>人们对编程语言有一个必然要求，就是能为公共的模式命名，建立抽象，然后直接在抽象的层次上工作。</li><li>动态语言之所以很流行，就是因为人们可以在很短的时间内建立起一种原型。</li><li>编程应该有一整套系统，包括人，技能，库，框架，工具。</li><li>如何才能让程序功能更加丰富，如何才能让它更加有趣，如何组织代码。</li><li>人们总是尝试做着软件的模块化结构，并且这种手段越来越先进。</li><li>编程技术的历史，首先是使用机器码，然后是符号化的汇编语言，接下来是高级语言，后面是结构化编程，现在又来到了面向对象的时代。</li><li>在我设计困难算法的经验中，我发现了一个扩展自己能力的方法。一个具有挑战性的问题解决之后，我从头再做一遍，回顾之前方法中的关键点。重复这么做，直到解决方案如我所希望的那样明确和直接。然后我们考虑类似问题的通用准则，这将促使我在起初的时候更有效的解决问题。通常，这样的法则具有永恒的价值。</li><li>递归，编程工具库中一件最强大的工具。</li><li>优秀程序员的一个衡量标准，必须有所进展，还得能加以改进。</li><li>就基本技能而言，编程所包含的就是逻辑和数学，我们应当学会逻辑思考，学会清晰的思考。</li><li>建设性的懒惰，坚持复用，遵循DRY（Don’t Repeat Yourself）原则，拒绝编写重复的胶合代码。</li><li>所谓的主流，实际上是以实效为主导。</li><li>培养构建大型应用程序的能力，因为写大程序非常耗时费力，这需要我们发明新方法，以减轻由于大程序的功能和细节而引起的沉重负担。</li><li>实现复杂度——代码的数量很重要，因为开发一个程序所耗费的时间主要取决于程序的长度。</li><li>面向对象编程只是程度不同的问题，事实上只有两种，某些语言允许以这种方式编程，另一些语言则强迫你一定要这样编程。</li><li>有了对象，我们就可以对任何事物建模；用对象做模拟是威力强大的，因为它非常符合我们对身处其中并与之交互的世界的看法。</li><li>Duck Typing (generic programming) ——如果它走路像鸭子，而且叫起来像鸭子，我就会称之为鸭子。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于软件稳定性测试的思路</title>
      <link href="posts/2014-10-19/how-to-make-sure-system-is-stable/"/>
      <url>posts/2014-10-19/how-to-make-sure-system-is-stable/</url>
      
        <content type="html"><![CDATA[<p>如何测试软件的稳定性其实是很难的，按照常规思路，只有长期的用户场景测试才能一定程度上保证软件的稳定性是可靠的，但并不能百分之百确定软件就是稳定的。软件测试本身就是由局限和尽头的，无穷的测试只能带来高成本的投入和无限期的计划延长。 </p><a id="more"></a><p>其实，可以从反面角度来看待软件的稳定性，我们从一个简单的数学定理入手：</p><blockquote><p><strong>原命题成立，则逆否命题也成立。</strong></p></blockquote><ul><li>原命题：软件没有明显缺陷，所以是足够稳定的。</li><li>逆否命题：软件并不是很稳定，所以有明显的缺陷。</li></ul><p>假设原命题是正确的，那么你否命题应该也是正确的。 </p><p>我们从原命题出发，很难说服团队去相信软件是足够稳定的，因为稳定的软件是没有明显缺陷的，没有数据的支撑和客观的事实，简单的例子就是，一我们不可能发现软件中所有的缺陷；二我们不可能花2~3个月不定地运行软件然后生成报告说经过长时间的实验软件十分稳定，时间不允许，就算时间允许我们也不敢保证3个月后程序是否还继续稳定如初。 </p><p>从逆否命题出发会简单许多，我们可以短时间内投入足够的精力去想办法证明软件很不稳定，比如让软件在高负荷下持续运行，给不同的压力和并发请求，进行破坏操作等等，如果软件没有出现明显的缺陷那么说明原命题也是成立的，从这个角度思考就可以从容地解决软件稳定性验证的问题。</p><ul><li>a</li><li>b</li><li>啊啊啊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些打鸡血的人生</title>
      <link href="posts/2013-07-16/do-the-right-thing/"/>
      <url>posts/2013-07-16/do-the-right-thing/</url>
      
        <content type="html"><![CDATA[<p>聊天的时候，总会有人一腔热血的向我推荐，“这部电影太励志了”，“这本书讲正能量诶”，或者是“昨天那个讲座我听得热血澎湃，讲的太有道理了”，刚开始我还会说，这些都是骗人的，后来，每次我都是摸摸我的狗头笑了，我明白，这些人都得了一种病，一种叫做鸡血狂躁症的沉疴，一种会间歇性发作的痼疾。这种病会让人免疫退化，犹如习武之人内力全失，让你在亢奋和低落之间跌宕起伏，而且传染力极强，会让你头脑发热。</p><a id="more"></a><p>这样的病人，究竟是怎样的一群人呢？当我看到他们每次学习的时候书都是从第一页翻起的时候，我若有所思，有所悟。按照熵的社会学解释，人总是会慢慢衰落，消亡，可是这些人，总是在追赶最后一趟火车。他们有雄心壮志，最后往往半途夭折。他们拥有的是表面的热情，深藏的却是内心的狂躁，他们营造着自欺欺人的假象，让自己在岁月的杀猪刀下消亡殆尽。</p><p>人生总是逃脱不了与生俱来的困境，很多打鸡血的人，往往深陷泥潭却不自知，他们从来不去思考自身的困境，把自己逼进了进退维谷的地步，最后却寄希望于天上掉馅饼，馅饼掉下来了，你接得住吗？期待着武侠小说的情怀，到头来却是拔剑四顾心茫然，欲渡黄河冰塞川，将登太行雪满山。总有那么一群人，在一个慵懒的午后，满心期待着通过一两本书，一两部电影，一两场讲座，希望从中得到所谓的真传，让自己脱胎换骨，顿悟法门，那你做梦去吧！</p><blockquote><p>“即便你真的能排除思想上的障碍，将计划付诸行动，在过个程中，也有无数这样那样的困难，挡住你前进的道路——这是一个漫长而艰苦的过程，决不是一时意气就能坚持下来的。”</p></blockquote><p>在现在这个糟糕的时代，打鸡血变换着各种戏法，作恶江湖，无孔不入，所谓的成功学，励志，正能量，不都是他披上的新装吗？ “只要有信心，人永远不会挫败”“人生的道路很长，但关键的时候，往往只有几步”，经常在海报上，网路上看到这样的文字，乍眼一看，觉得是无可辩驳的箴言，让人内心澎湃，仿佛是人生的福音书，仔细一想，又是如此的理所当然，用冯唐的话来讲，顿觉心头肿胀，然而，认真思考却是如此的荒谬与戏谑，就让他们扯淡去吧！</p><p>看看你的身边，你会发现，那些过早放弃的人，往往是对于未来很乐观的人，现实世界的糟糕会让他们过早的退出循环，那些鸡血打得最多的人，呐喊得最强烈的人，往往是最先逃跑的人，而那些能够一直坚持到底的人，往往是清楚地认识到前路所会遇到的苦难但是坚信自己的人，就是我们所谓的“呆子”，“nerd”，我不知道为什么，世界总是偏爱青睐那些“偏执”的人，想到这里，不禁让我唏嘘的纳闷:上帝是nerd吗？如果上帝不是nerd，又为什么对于“nerd”钟爱有加呢？</p><p>《大学》云：“知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。”不知止，何以定，不定不静不安，孰能得？知止者，又何用打鸡血？</p><p>那些打了鸡血的人生终究会变得很狗血！</p><p>想想那些昨天还跟你满腔热血，高谈阔论”励志“，”正能量“的人吧，大梦初醒时，天依旧清亮，风依旧分明，他应该都不记得他昨天说过什么吧，或许只记得昨天吃了什么吧！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AHU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走得太远，忘记了为什么出发</title>
      <link href="posts/2011-03-14/forget-why-start/"/>
      <url>posts/2011-03-14/forget-why-start/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可以颠覆掉所有的春天<br>用一小片枯薄了的秋叶<br>而昨夜犹在梦中<br>所以围脖和小火炉<br>还搁在去年的架上<br>去年还搁在<br>小小的记忆里</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暧昧很近，爱情很远</title>
      <link href="posts/2008-07-18/love-is-far-away/"/>
      <url>posts/2008-07-18/love-is-far-away/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文 / 蔚蓝</p></blockquote><p>忘了是谁曾经说过：这是个离暧昧很近，却离爱情很远的年代。这句话堪称经典！ </p><a id="more"></a><p>　　　　 　　<br>是的，我们总是可以随意的暧昧，眼神的暧昧，双手的暧昧，言语的暧昧，甚至是同床共枕的暧昧。<br>　　　　 　　<br>可惜，却始终找寻不到真正感觉上的爱情。爱情离我们越来越远，我们却天真的以为它就在身边，触手可及。孰不知，其实它远在千里之外，也许根本未曾走近你。<br>　　　　 　　<br>或许它留下了它的影子——那就是我们喜欢哼唱的泛滥成灾的情歌。情歌之所以泛滥，是因为我们需要它来伪装我们内心深处的寡情并借它来宣泄难以排遣的歇斯底里的寂寞。可惜自古情歌伤情，所以越唱越悲。而我们共鸣的眼泪却越来越少，几近干涸；纤细的，伤感的心，更始越来越麻木。<br>　　　　 　　<br>爱情的远离使我们失落，失落又使我们伤感，伤感后我们失去了心灵的空灵，开始变得迟钝，变得愚笨。<br>　　 　　<br>我们为爱情而扼腕叹息，为它不惜流出珍藏已久的眼泪，那是因为我们知道其实爱情只有天人永隔才能永恒。这不是残忍，于最美的时候结束最美的爱情，这是最美的结局。况天意如此，岂可逆转？<br>　　　　 　　<br>可惜，现实中没有泰坦尼克了，沉没了的始终是沉寂的了。我们深深地向往《缘分天注定》的浪漫，在影片落幕之后仍久久不忍离去。他们一见钟情却受命运的捉弄；他们在历经辗转10年之后还能确定唯有对方是真爱。而且为了这份飘渺的爱各自离开了身边的恋人，在兜了一大圈之后，恰巧不期而遇靠的是一个信念一个冥冥之中的感觉，一张写着他的电话的美元，一本写着她的电话的早已脱销的书不是神话是什么？是的，因为是神话，而且神话得很唯美，即使有点小小的虚伪，也仍然令我们感慨。可惜电影与现实有差距，浪漫与坚持互不成立。我无法超凡脱俗，所以如果我是女主角，那么当我遇见他的时候，也许我正带着我的小BABY在公园里散布。<br>　　　　 　　<br>离爱情很远的年代，一些人早已经失去了信念，也没有余力再去坚持什么，只能随波逐流。<br>　　<br>是的，我们离暧昧越来越近，而爱情却始终没有向我们迈近半步。偶尔感觉到一丝丝一点点，伸出手去，却只是捕捉到空气，也许只是它无意中遗留下来的气息。<br>　　<br>仅此而已！<br>　　<br>所以一些人注定在暧昧中生活——不明的暧昧，模糊的暧昧，脆弱的暧昧，不堪一击的暧昧。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AHU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安青事件详细过程</title>
      <link href="posts/2008-07-16/adyouth-bbs-close/"/>
      <url>posts/2008-07-16/adyouth-bbs-close/</url>
      
        <content type="html"><![CDATA[<p>狗血的青春。</p><a id="more"></a><h3 id="发生了什么"><a href="#发生了什么" class="headerlink" title="发生了什么"></a>发生了什么</h3><p>2008年7月3日晚上，安青在线论坛访问提示出错，细心的坛友可能会发现，和以往成百次的crash不同，这次的错误提示似乎与以往有些不同，不寻常的错误提示预示着不寻常的事件，也有着不寻常的原因。几天过去了(写作时间:2008年7月5日)，安青依然没有恢复过来。在这之前的一些事情十分耐人寻味。</p><blockquote><p>7月2日的晚上论坛中一个非常活跃的ID被封禁，网友开始集体声讨论坛管理层。 一名负责论坛日常管理事务的版主关于此次事件的一篇帖子被删除。</p><p>7月3日，另一名超级版主辞职(?) </p><p>7月3日晚上，一些版主的在自己的板块进行非常规的加威望操作。同时在一些群里，流传7月4日凌晨集体辞职的传言 </p></blockquote><p>接着就出现了此节开头提到的一幕。据推测这次安青停机可能与管理层内部的矛盾激化有关。至于给论坛带来多大的影响，现在还难以确定。 </p><h3 id="知情者言论"><a href="#知情者言论" class="headerlink" title="知情者言论"></a>知情者言论</h3><p>貌似是某些人和别人掐架，然后被投诉。最后发现确实理亏，然后找替死鬼。<br>人都是父母生的，为啥要当替死鬼。<br>何必受夹缝气？<br>得道多助，失道寡助 。<br>自古如此。<br>疯狂和不理智都是有原因的，而且也是为了一定目的的。<br>没有毫无理由的爱，也没有毫无理由的绝望。</p><hr><h3 id="被迫关闭前"><a href="#被迫关闭前" class="headerlink" title="被迫关闭前"></a>被迫关闭前</h3><p>超级斑竹<strong>YAGUY</strong>如是说：</p><p>7月2日凌晨，ID为“他们说我摸蛆”在站务建议发帖，《关于永久封禁ADM的公告》，内容大概是说ADM平时乱删帖引发网友不满，故永久封禁，纯属恶搞。之后，我将其帖移往水区，但是帖子已经上最热，考虑到帖子会引起网友的误会以及可能的埋怨甚至谩骂ADM的现象，于是跟“他们说我摸蛆”交流，其本人也将帖子改为《（搞笑版）关于永久封禁ADM的公告》。以为应该没什么事了然后我就睡觉准备第二天的考试。当时犹豫了一下没有删除该帖，没想到却带来了这么多事，真是悔不当初。 </p><p>中午一点半左右，我考完试打开电脑上安青，发现最热帖依然是原来那个，但是标题里没有出现“搞笑版”，点击进入发现帖子已经被ADYOUTH关闭，立马感觉大事不妙。随即站长联系上我，跟我说ADM上午已经找了“他们说我摸蛆”本人交流，现在需要将这个ID永久封禁，我当时不能接受，问他到底违反了版规的哪一条。后来站长说因为他恶搞ADM，已经是算是攻击的一种。</p><p>我以为是团委下达的封禁指示，所以就用“安青值班管理员”的帐号将其永久封禁，并生拉硬扯了一些封禁理由。这是我的又一大失误，本来自己都说服不了自己为什么要封禁他，还要勉强让自己编一些烂理由。所以当投诉帖质疑封禁理由的时候，我发誓，如果以后团委要封禁什么人，麻烦他们把理由写好给我，试问一个连我自己都不能接受的理由如何想博得别人的理解？失误！太大的失误！ </p><p>下午2点半左右，封禁帖一出，立马大批网友跟帖质疑，其中网友“动力火锅”更是在站务建议发帖投诉。帖子内容我还没有仔细看，就被ADYOUTH给编辑了，初步估计ADYOUTH是站长在用，他不了解ADYOUTH的作用，是不用来处理帖子的，一般都是发公告在用，当黑脸的是“安青值班管理员”。被ADYOUTH编辑后的帖子标题没有变，内容变成了“。。。”，原以为“动力火锅”会继续反抗投诉，没想到没有音讯了，而此时的所谓投诉帖已经没有意义了，为避免不必要的麻烦，我将该帖移往回收站。 </p><p>随后忽然发现欢迎新进会员来了一个“NEWADYOUTH”，根据论坛版规，跟管理员帐号类似的ID是不允许存在，于是我点击进入，准备删除该ID，却发现该ID所属用户组居然是管理员，应该不是恶搞，所以立马询问站长是不是他所为。没想到事实的确如此，他的理由是：以后ADYOUTH唱红脸，NEWADYOUTH唱白脸，更荒谬的是他预备NEWADYOUTH供他自己使用。这是史无前例的。也从侧面说明该新任站长对论坛规则的不熟悉。还有，居然不跟我们内部人员说一声就私自申请管理员帐号。</p><p>这件事情令当时论坛部部长也就是破天荒同学尤为恼怒，也是次日的辞职事件的导火索。于此同时我和破天荒一直与站长交涉，站长不肯退让，一直不肯删号，后来导致破天荒同学情绪浮躁，更是在某投诉帖中发表了不应有的言论（某位网友说“干脆把论坛给关了，至少某些版块”，破天荒引用该句话：好主意，我同意）。我看到后立马联系其本人，告诉是不对的，并删除该回帖。但是没想到这个回帖还是被网友看到了，并站务建议投诉。</p><p>由于与该网友有一面之交，所以说明原因后该网友同意我删除该帖，于是没有造成太大的混乱。但是与此同时与站长的交流已经停止，因为有些事说不清，只好搬出前任站长，希望他能出面解决。果然过了一会站长给我电话了，说他已经将那个号给删除，并希望晚上能与我和破天荒交流一下。 </p><p>于此同时，越来越多的投诉帖浮现，有激愤，有理智，但是基本都将矛头指向ADM，大家都以为是他下的手。被避免混乱，我将更多的投诉帖合并，企图让事情缓和，但是没有效果。 </p><p>晚上和站长交流，本来想质疑他下午的所作所为，没想到却被他倒打一耙，责备破天荒下午的言辞。说实话，破天荒做论坛部主任以来就对团委有一些意见，我们都有，只是他更强烈。在当我们深刻了解到“团委要的只是论坛的存在，而我们要的是论坛的发展”这句话后，更是觉得心灰意冷。我们再有能力可能也做不到一个大家理想中的论坛。不甘啊那是！在中间，我还了解到“他们说我摸蛆”的号不是团委要求封的，还是站长本人，当时很是气愤，觉得恨死自己了，封什么啊！不封不就没这些事了。 </p><p>3日凌晨，我用大号的名义发了一个帖子，企图阐释ADM的不同，并妄图平息大家的怨恨，我觉得我说的很中立，甚至我感觉自己怎么有点好像开始倾向团委了。但是这个帖在没有被更多的人看到的情况下，被ADM编辑了，因为我说了一些不该说的话，我真是奇了怪了，我到底说了什么，我感觉我说的是论坛的现状没错啊，我貌似也没说什么对团委不利的话，算了，他们说不行就不行吧，帖子既然内容已经被编辑了，那也失去了原有的价值，我于是自删帖子。不过马上就有人站务建议询问我的那个帖子为什么不见了，我连忙给删了，怕大家以为是ADM所为，还好那个人是认识的人，理解了，也没说什么。 </p><p>中午左右，动力火锅归来，原来他昨天发完帖子就走了，不知道自己的帖子已经被处理了，所以其本人很恼怒，发帖要站方给个说法，同时还有“他们说我摸蛆”用新号在投诉，当时我因为要准备考试，不能再浪费一天的时间在论坛上，所以把论坛上的事务交由破天荒处理。但是后来却出事了。 </p><p>应该是破天荒把动力火锅的投诉帖给关了，然后动力火锅公开要求其道歉，并言辞恶劣，直接质疑其智商之类的。此期间我虽然在自习，但一直和破天荒保持联络，感觉到了他内心的变化。被网友指着鼻子骂让他到了可以说是崩溃的极限。没过多久，破天荒本人发来了一条短信，转发自ADM，意思是破天荒被暂时取消了线下管理员和线上超版的权限，预备考试结束后和他谈谈。末了，破天荒来一句，很好，我解放了。</p><p>当时被这件事弄得很晕，和ADM本人还有站长也联系了，被告知破天荒在论坛上又说了不该说的话（好像是要道歉找团委，跟我们论坛内部没有关系），匆忙自习完回去打开安青，发现破天荒已经回归普通用户组，但是没有关于此的公告，然后我想把破天荒的权限给恢复了，毕竟团委的意思还有转机，并不是要一直撤销，而这样没有公告不声不响的让大家看见了该如何解释？下意识的，我试图用“安青值班管理员”的帐号登陆，发现不可以，那么ADYOUTH呢？也不可以。忽然一下冷笑，真够绝的。密码被改了。我打电话问站长要，他说他在吃饭，回头给我。我当时等不及，立马打电话给ADM，一直打不通，发短信想要密码，得到的回复是现在不会给我们。还是想说，狠。。。 </p><p>接着，前站长邀我出去想跟我谈谈。在此过程，我申明我的观点：如果团委真的是还想要回复破天荒本人的权限，那么，线下的工作可以停，线上的工作也可以警告其让其不邀管理以及发言，但是没有必要撤销其用户组，这样没有公告的撤销，让网友发现了该如何解释？前站长告知，晚上大概就会发公告，暂时取消破天荒线上超版权限的公告。意思是说如果考试后双方的交流达到团委预想的效果，那么破天荒的线上线下权限还是会被恢复。当时我反对，这样对破天荒本人不公平，以后破天荒再处理事情的时候，公信力或多或少地会打折。在与破天荒交流后，确信他去意已决，我建议他自己辞职，于是他的辞职帖便立马出现在站务建议，并被很多人发现。</p><p>一部分人表示挽留，一部分表示不解，但是更多的人觉得破天荒是这件事情团委推出来的替罪羊，一时众愤，站务建议又迎来了新一轮的投诉热。于此同时，在论坛首页的最新发表帖子一栏，紧接着破天荒的辞职贴，ADYOUTH发布了所谓对此次事件的处理结果，其中，封禁了两个近期投诉较多的网友，包括动力火锅，还用一句话粗略提到破天荒的解职，还有安青值班管理员暂时停止使用。几乎于此同时，破天荒的辞职帖被ADYOUTH关闭，还有其回复，要知道已经很久ADYOUTH没有回帖了，这再次证明，论坛管理已经出现了脱节，是沟通不够还是出发点不同，仁者见仁智者见智。 </p><p>我要说的是，这两个帖子一前一后正好同时出现，很巧合，也更加坚定了网友以及版主们原本的想法，即破天荒是团委推出来企图化解整件事情的替罪羊。一时间群情激奋，尤其是在一些版主的带领下，论坛出现了前所未有的混乱。版主任意加威望加精华、版主商量集体辞职并在版主交流群里说12点一过开始“攻击”论坛。 </p><p>与此同时，安青的访问速度越来越慢，最后打不开了，安青被关了。这大概是有史以来第一次因为无法控制安青的局面而将论坛关闭。关了也好，论坛需要整改，我们之前都想错了，安青是取不了大进步，我们只能让论坛在存在的基础上尽量的为大家服务。 </p><p>在整件事还有一个人不能忽略，那就是王鹏，哪里有乱哪里就有他，这个人不想多提，我已经从一开始还对他抱有一丝幻想到现在的彻底厌恶。 </p><p>我觉得反正这件事情使安青大伤元气，但是到底是好还是坏也说不定。可能一时间安青的人气会急剧下降，但是也可能安青迎来了从头起步的好机会。到底怎么样，还是要看论坛负责人的态度，以及和团委的磨合度。我就说那么多，现在很多已经回忆不起来了。只是还是想安青能够好。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AHU </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
